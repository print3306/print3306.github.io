<!DOCTYPE html><html class="theme-next pisces use-motion" lang=zh-Hans><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width, initial-scale=1, maximum-scale=1"><meta name=theme-color content=#222><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel=stylesheet><meta http-equiv=Cache-Control content=no-transform><meta http-equiv=Cache-Control content=no-siteapp><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel=stylesheet type=text/css><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel=stylesheet type=text/css><link href="/css/main.css?v=5.1.4" rel=stylesheet type=text/css><link rel=apple-touch-icon sizes=180x180 href="/images/avatar1.png?v=5.1.4"><link rel=icon type=image/png sizes=32x32 href="/images/avatar1.png?v=5.1.4"><link rel=icon type=image/png sizes=16x16 href="/images/avatar1.png?v=5.1.4"><link rel=mask-icon href="/images/logo.svg?v=5.1.4" color=#222><meta name=keywords content=Spring,><meta name=description content="概述1. 什么是spring：1. 分层的Java SE&#x2F;EE的轻量级开源框架 2. 提供了展现层Spring MVC 和持久层Spring JDBC以及业务层事务管理的众多技术 3. 展现层和持久层的中间部分，业务层2. spring的核心：1. IoC（Inversion of Control）: 控制反转 2. AOP（Aspect Oriented Programming）: 面向切面编程"><meta property=og:type content=article><meta property=og:title content=Spring><meta property=og:url content=http://print3306.github.io/2020/09/09/spring/index.html><meta property=og:site_name content=浊酒一杯><meta property=og:description content="概述1. 什么是spring：1. 分层的Java SE&#x2F;EE的轻量级开源框架 2. 提供了展现层Spring MVC 和持久层Spring JDBC以及业务层事务管理的众多技术 3. 展现层和持久层的中间部分，业务层2. spring的核心：1. IoC（Inversion of Control）: 控制反转 2. AOP（Aspect Oriented Programming）: 面向切面编程"><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/autowired.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/IoC_exp_pom.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/Ioc_xml_exp.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/IoC_anno_exp.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/Ioc_structure.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/anno_withoutxml_1.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/anno_withoutxml_2.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/proxy.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/proxy_test.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/advice.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/xml_AOP.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/advice_types.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/around_advice.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/AOP_anno.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/dao_xml.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/dao_anno.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/tran_xml.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/tran_anno.png><meta property=og:image content=http://print3306.github.io/2020/09/09/spring/tx_without_xml.png><meta property=article:published_time content=2020-09-09T11:45:05.000Z><meta property=article:modified_time content=2020-11-29T07:28:10.084Z><meta property=article:author content=浊酒一杯><meta property=article:tag content=Spring><meta name=twitter:card content=summary><meta name=twitter:image content=http://print3306.github.io/2020/09/09/spring/autowired.png><script type=text/javascript id=hexo.configurations>
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script><link rel=canonical href="http://print3306.github.io/2020/09/09/spring/"><title>Spring | 浊酒一杯</title><meta name=generator content="Hexo 4.2.1"></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-Hans><div class="container sidebar-position-left page-post-detail"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-wrapper><div class=site-meta><div class=custom-logo-site-title><a href="/" class=brand rel=start><span class=logo-line-before><i></i></span> <span class=site-title>浊酒一杯</span> <span class=logo-line-after><i></i></span></a></div><p class=site-subtitle></p></div><div class=site-nav-toggle><button><span class=btn-bar></span> <span class=btn-bar></span> <span class=btn-bar></span></button></div></div><nav class=site-nav><ul id=menu class=menu><li class="menu-item menu-item-home"><a href="/" rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel=section><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel=section><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span> <span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索... spellcheck=false type=text id=local-search-input></div></div><div id=local-search-result></div></div></div></nav><script>
    
    window.onload = function(){
        var path = 'https://malizhi.cn'; //这里要改成你博客的地址
        var localhostItem = String(window.location).split(path)[1];
        var LiNode = document.querySelectorAll('#menu > li > a')
        
        for(var i = 0; i< LiNode.length;i++){
            var item = String(LiNode[i].href).split(path)[1];
            if(item == localhostItem && item != undefined){
                LiNode[i].setAttribute('style','border-bottom:1px solid black');
            }
        }
    };

 </script></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><div id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><div class=post-block><link itemprop=mainEntityOfPage href="http://print3306.github.io/2020/09/09/spring/"><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=name content=浊酒一杯><meta itemprop=description><meta itemprop=image content=/images/avatar1.jpg></span> <span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content=浊酒一杯></span><header class=post-header><h1 class=post-title itemprop="name headline">Spring</h1><div class=post-meta><span class=post-time><span class=post-meta-item-icon><i class="fa fa-calendar-o"></i></span> <span class=post-meta-item-text>发表于</span><time title=创建于 itemprop="dateCreated datePublished" datetime=2020-09-09T19:45:05+08:00>2020-09-09</time><span class=post-meta-divider>|</span> <span class=post-meta-item-icon><i class="fa fa-calendar-check-o"></i></span> <span class=post-meta-item-text>更新于&#58;</span><time title=更新于 itemprop=dateModified datetime=2020-11-29T15:28:10+08:00>2020-11-29</time></span> <span class=post-category><span class=post-meta-divider>|</span> <span class=post-meta-item-icon><i class="fa fa-folder-o"></i></span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing><a href="/categories/SpringFramework/" itemprop=url rel=index><span itemprop=name>SpringFramework</span></a></span></span><div class=post-wordcount><span class=post-meta-item-icon><i class="fa fa-file-word-o"></i></span> <span class=post-meta-item-text>字数统计&#58;</span> <span title=字数统计>6.9k</span></div></div></header><div class=post-body itemprop=articleBody><h2 id=概述><a href=#概述 class=headerlink title=概述></a>概述</h2><h3 id=1-什么是spring：><a href=#1-什么是spring： class=headerlink title="1. 什么是spring："></a>1. 什么是spring：</h3><pre><code>1. 分层的Java SE/EE的轻量级开源框架
2. 提供了展现层Spring MVC 和持久层Spring JDBC以及业务层事务管理的众多技术
3. 展现层和持久层的中间部分，业务层</code></pre><h3 id=2-spring的核心：><a href=#2-spring的核心： class=headerlink title="2. spring的核心："></a>2. spring的核心：</h3><pre><code>1. IoC（Inversion of Control）: 控制反转
2. AOP（Aspect Oriented Programming）: 面向切面编程</code></pre><h3 id=3-发展历程和优势><a href=#3-发展历程和优势 class=headerlink title=3.发展历程和优势></a>3.发展历程和优势</h3><pre><code>spring优势：
    1. 方便解耦，简化开发
    2. AOP编程的支持
    3. 声明式事务的支持
    4. 方便程序的测试
    5. 方便集成各种优秀的框架</code></pre><h2 id=程序的耦合和解耦><a href=#程序的耦合和解耦 class=headerlink title=程序的耦合和解耦></a>程序的耦合和解耦</h2><h4 id=耦合><a href=#耦合 class=headerlink title=耦合></a>耦合</h4><pre><code>1. 什么是耦合：
    程序之间的依赖关系：
        * 类之间的依赖关系
        * 方法之间的依赖关系

2. 开发中的做法：
    编译期不依赖，运行时依赖

3. 方法：
    1. 使用读取配置文件来获取要创建的对象的全限定名称
        使用类加载器，获取配置文件的输入流
    2. 使用反射（reflection）来创建对象，而不是使用new关键字
        * 使用反射，如果字符串写死，以后无法再次使用别的数据库配置</code></pre><h4 id=解耦><a href=#解耦 class=headerlink title=解耦></a>解耦</h4><pre><code>1. 什么是解耦：
    降低程序之间的依赖关系

2. 解耦的方式：使用工厂模式创建Bean对象
      * bean: 可重用组件
      * javaBean &gt; 实体类
      * javaBean 用java语言编写的可重用组件
      * beanfactory：创建bean对象的工厂

3. 如何创建工厂模式
    1. 读取配置文件来反射bean对象
    2. 配置文件来创建service和dao
        唯一标识=全限定类名，key = value，根据对应的value创建实例对象</code></pre><h2 id=IoC（Inversion-of-Control）><a href=#IoC（Inversion-of-Control） class=headerlink title="IoC（Inversion of Control）"></a>IoC（Inversion of Control）</h2><pre><code>1. 概念：
    把创建对象的权力交给框架，是框架的重要特征，包括依赖注入（Dependency Injection,DI）和依赖查找（Dependency Lookup）

2. 作用
    * 降低程序之间的耦合度
    * 将类中的对象创建工作交给spring框架来完成，只要获取该对象就可以了
    * 使用依赖注入进行属性值的填充，在创建对象的同时完成赋值</code></pre><h3 id=基于XML的IoC配置><a href=#基于XML的IoC配置 class=headerlink title=基于XML的IoC配置></a>基于XML的IoC配置</h3><h4 id=初步使用><a href=#初步使用 class=headerlink title=初步使用></a>初步使用</h4><pre><code>1. 步骤
    * 读取配置文件创建IoC容器（ApplicationContext）
    * 根据id，获取容器中的文件

2. 配置文件的内容
    * 主要是&lt;bean&gt;标签，id:查找对象的唯一标识符，class:要创建的对象的全限定类名

3. 读取配置文件创建容器
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    根据类路径下的xml配置文件创建容器，配置文件需要放置在类路径下

    ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;bean.xml&quot;);
    可以加载磁盘任意路径下的配置文件

    ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class);
    根据类上有@Configuration的类创建容器

4. 根据id获取对象
    as.getBean(&quot;id&quot;);</code></pre><h4 id=BeanFactory和ApplicationContext><a href=#BeanFactory和ApplicationContext class=headerlink title=BeanFactory和ApplicationContext></a>BeanFactory和ApplicationContext</h4><pre><code>1. Beanfactory接口
    * 创建核心容器时，创建对象的方式采用延迟加载的方式，什么时候根据ID获取对象的时候，什么时候开始创建真正的对象
     * 多例模式适用

2. ApplicationContext接口
    * 创建核心容器时，创建对象的方式采用立即加载的方式，只要一读取完配置文件马上创建配置文件中的对象
     * 单例模式时适用：只创建一个对象

3. 具体的使用
    BeanFactory是顶层接口，功能不如ApplicationContext，实际使用的接口为ApplicationContext接口

    ApplicationContext可以根据配置文件的不同，选择合适的加载方式
    可以感知到对象的单例还是多例，从而选择不同的方式创建对象</code></pre><h4 id=spring对bean对象的管理细节><a href=#spring对bean对象的管理细节 class=headerlink title=spring对bean对象的管理细节></a>spring对bean对象的管理细节</h4><h5 id=1-创建bean的三种方式><a href=#1-创建bean的三种方式 class=headerlink title="1. 创建bean的三种方式"></a>1. 创建bean的三种方式</h5><pre><code>1. 使用默认构造函数创建：
   在spring的配置文件中使用bean标签，配以id 和 class属性，且没有其他的属性和标签时
   采用的就是默认构造函数创建bean对象(Class类的实例反射)，如果此时没有默认构造函数，则无法创建</code></pre><blockquote><pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_IoC_bean.service.impl.AccountServiceImpl&quot;/&gt;</code></pre></blockquote><pre><code>2. 使用普通工厂中的方法创建对象
    使用某个类中的方法创建对象，并存入spring容器中</code></pre><blockquote><pre><code>&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.spring_03_IoC_bean.factory.InstanceFactory&quot;/&gt;
&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;/&gt;</code></pre></blockquote><pre><code>3. 使用工厂的静态方法创建对象（
    使用某个类的静态方法创建对象(可以不创建该对象)，并将其存入spring容器</code></pre><blockquote><pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_IoC_bean.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;/&gt;</code></pre></blockquote><h5 id=2-bean对象的作用范围><a href=#2-bean对象的作用范围 class=headerlink title="2. bean对象的作用范围"></a>2. bean对象的作用范围</h5><pre><code>1. bean标签的scope属性规定bean对象的范围
2. 类型
    * singleton: 单例模式（默认）
    * prototype：多例模式
    * requset:web应用的一次请求
    * session：web应用中的一次会话
    * global-session：web应用中的全局会话</code></pre><h5 id=3-bean对象的生命周期><a href=#3-bean对象的生命周期 class=headerlink title="3. bean对象的生命周期"></a>3. bean对象的生命周期</h5><pre><code>1. 单例对象：singleton
  出生：当容器创建时，对象出生
  活着：只要容器还在，对象活着
  死亡：容器销毁，对象死亡
2. 多例对象：prototype
  出生：当使用对象时，spring框架创建
  活着：只要在使用的时候一直存在
  死亡：只有在对象长时间不用，且没有其他的对象引用的时候，由垃圾回收机制回收</code></pre><h4 id=依赖注入（dependency-injection-DI）><a href=#依赖注入（dependency-injection-DI） class=headerlink title="依赖注入（dependency injection:DI）"></a>依赖注入（dependency injection:DI）</h4><pre><code>1. 什么是依赖？    
    当前类中引用到其他类的对象，叫做依赖。
    在spring框架中，依赖对象由框架提供，我们只需要提供配置文件的说明（IoC方式）

2. spring降低程序之间的依赖关系?
    IoC控制反转
    依赖注入

3. 依赖注入的数据类型：
    1. 基本数据类型和String类型
    2. 其他bean对象
    3. 复杂类型（集合类型）

4. 依赖注入的方式：
    1. 通过默认构造函数注入依赖
    2. 使用set方法注入 ***
    3. 通过注解注入</code></pre><h5 id=1-通过默认构造函数注入><a href=#1-通过默认构造函数注入 class=headerlink title="1. 通过默认构造函数注入"></a>1. 通过默认构造函数注入</h5><pre><code>标签：constructor-arg
位置：bean中的内部
属性含义：
    type: 指定要注入的数据类型，该数据类型是构造函数的某个或者某些参数的类型
    index: 指定要注入数据给构造函数的参数指定索引的位置的赋值
    name: 用于指定给构造函数的指定名称的参数赋值（主要方式）
    ===================指定给构造函数的那个参数赋值=======================

    value: 提供基本类型和String类型的数据
    ref: 指定其他的bean类型的数据，在spring的IoC的核心容器中的bean对象

优势：
    在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功
缺点：
    改变了bean对象的实例化方式，在我们创建对象时，即使用不到这些数据，也必须提供数据</code></pre><blockquote><pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;李某&quot;/&gt;
    &lt;constructor-arg name=&quot;age&quot; value=&quot;23&quot;/&gt;
    &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;
&lt;/bean&gt;</code></pre></blockquote><blockquote><pre><code>&lt;!-- 配置一个日期对象 --&gt;
&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;/&gt;</code></pre></blockquote><h5 id=2-使用set进行依赖注入><a href=#2-使用set进行依赖注入 class=headerlink title="2. 使用set进行依赖注入"></a>2. 使用set进行依赖注入</h5><pre><code>标签：property
位置：bean标签内部
参数：
    name:    指定注入的时候的方法的名称
    value:     指定基本数据类型和String类型
    ref:     指定其他的bean类型的数据，只要是在spring核心容器中的bean对象都可以

优势：创建bean对象的时候，可以直接使用默认构造函数
   缺点：
      如果某个成员必须有值，获取对象的set方法可能没有执行</code></pre><blockquote><pre><code>&lt;bean id=&quot;accountService2&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl2&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;22&quot;/&gt;
    &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;
&lt;/bean&gt;</code></pre></blockquote><blockquote><pre><code>&lt;!-- 配置一个日期对象 --&gt;
&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;/&gt;</code></pre></blockquote><h5 id=3-使用注解进行依赖注入><a href=#3-使用注解进行依赖注入 class=headerlink title="3. 使用注解进行依赖注入"></a>3. 使用注解进行依赖注入</h5><pre><code>@Autowired
@Qualifier
@Resource
@Value
进行依赖注入</code></pre><h5 id=4-注入复杂数据类型><a href=#4-注入复杂数据类型 class=headerlink title="4. 注入复杂数据类型"></a>4. 注入复杂数据类型</h5><pre><code>List Set      
Map Properties

标签：property
位置：property内部
其中：只要数据集合的结构相同，可以使用同一种标签进行依赖注入
    list set arrsy: 都可以使用&lt;list&gt;,&lt;array&gt;,&lt;set&gt;，序列格式
    map property:&lt;map&gt;,&lt;pros&gt;，键值对格式</code></pre><blockquote><pre><code>private String[] myStr;
private List&lt;StringmyList;
private Set&lt;StringmySet;
private Map&lt;String,StringmyMap;
private Properties myProp;</code></pre></blockquote><pre><code>具体的调用方法</code></pre><blockquote><pre><code>&lt;bean id=&quot;accountService3&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl3&quot;&gt;
&lt;property name=&quot;myStr&quot;&gt;
  &lt;array&gt;
    &lt;value&gt;AAA&lt;/value&gt;
    &lt;value&gt;VVVDDD&lt;/value&gt;
    &lt;value&gt;SS&lt;/value&gt;
    &lt;value&gt;SSDDD&lt;/value&gt;
  &lt;/array&gt;
&lt;/property&gt;
&lt;!-- map --&gt;
&lt;property name=&quot;myMap&quot;&gt;
  &lt;map&gt;
    &lt;entry key=&quot;1&quot; value=&quot;11111&quot;/&gt;
    &lt;entry key=&quot;2&quot; value=&quot;22222&quot;/&gt;
  &lt;/map&gt;
&lt;/property&gt;</code></pre></blockquote><h3 id=基于注解的IoC配置><a href=#基于注解的IoC配置 class=headerlink title=基于注解的IoC配置></a>基于注解的IoC配置</h3><pre><code>使用注解和xml开发要实现的功能都是一致的：降低程序之间的耦合，将xml中对应的功能交由注解来实现</code></pre><h4 id=1-用于创建bean对象的注解><a href=#1-用于创建bean对象的注解 class=headerlink title="1. 用于创建bean对象的注解"></a>1. 用于创建bean对象的注解</h4><pre><code>* 与xml配置文件中的&lt;bean&gt;标签的作用相同：创建一个bean对象，将其放置在容器中
* 如果想让spring知道存在组件，需要使用spring中的包扫描，将需要创建bean对象的包传入&lt;context&gt;标签中

1. @Component:组件注解
    * 作用：将当前对象存入spring容器中(写在类名上)
    * 属性：value:
            用于指定获取容器中bean的id，当我们不写时，默认是当前类名，首字母小写    

2. @Controller:一般用于表现层
3. @Service：一般用于业务层
4. @Repository:一般用于持久层
以上的三个注解和@Component的作用和属性完全一致，是spring框架为我们明确提供的三层注解，让我们的三层结构更加清晰</code></pre><h4 id=2-用于数据注入的注解><a href=#2-用于数据注入的注解 class=headerlink title="2. 用于数据注入的注解"></a>2. 用于数据注入的注解</h4><pre><code>* 与xml配置文件的&lt;property&gt;作用一致：进行数据注入

1. @Autowired:自动按照类型注入
     * 只要IoC容器中有唯一的bean对象和要注入的变量类型相同，就可以自动注入
     * 如果IoC容器中没有任何bean对象和要注入的变量类型相同，无法自动注入
     * 如果IoC容器中有多个bean对象和要注入的变量类型相同，
     * 首先圈定类型相同的bean对象的范围，然后会在进行变量名称的比对,如果名称相同，就可以注入数据</code></pre><blockquote></blockquote><p><img src=/2020/09/09/spring/autowired.png alt=autowired注解></p><pre><code>2. @Qualifier
    * 先按照类型自动注入，如果包含有多个相同类型的bean对象，会按照名称进行数据注入
    * 在按照类型注入的基础上，再按照名称注入，在给类成员的注入的时候不能单独使用，但是在给方法注入的时候可以，，将@Qualifier()中的名称所对应的Bean对象注入到方法中
    * 参数：
        value:用于指定注入的bean的id

3. @Resource
    * 直接按照bean的id进行注入，可以单独使用
    * 参数：
        name:用于指定注入的bean的id

注意：
     以上的三种注入方式只能注入其他的bean类型的数据，基本类型和String类型无法通过上述方法注入
          集合类型只能通过xml方式注入

4. @Value
    * 注入基本数据类型和String类型
    * 参数：    
        value:用于指定数据的值，可以使用SpEL（spring的El表达式）                      SpEL的写法：${表达式}</code></pre><h4 id=3-用于改变作用范围的注解><a href=#3-用于改变作用范围的注解 class=headerlink title="3. 用于改变作用范围的注解"></a>3. 用于改变作用范围的注解</h4><pre><code>* 与xml文件中的&lt;bean&gt;标签的scope属性作用相同

1. @Scope
    * 参数：
        value:singleton prototype</code></pre><h4 id=4-用于改变生命周期的注解><a href=#4-用于改变生命周期的注解 class=headerlink title="4. 用于改变生命周期的注解"></a>4. 用于改变生命周期的注解</h4><pre><code>1. @PreDestroy
    * 销毁容器
2. @PostConstruct
    * 初始化容器</code></pre><h3 id=使用IoC的一个简单案例><a href=#使用IoC的一个简单案例 class=headerlink title=使用IoC的一个简单案例></a>使用IoC的一个简单案例</h3><pre><code>1. 环境配置
    使用DBUtils进行Dao数据交互
    spring框架
    mybatis进行JDBC连接
    c3p0作为数据源</code></pre><blockquote></blockquote><p><img src=/2020/09/09/spring/IoC_exp_pom.png alt=pom.xml></p><pre><code>2. bean文件结构
    1. xml配置</code></pre><blockquote></blockquote><p><img src=/2020/09/09/spring/Ioc_xml_exp.png alt=xml配置的bean></p><pre><code>2. annotation配置</code></pre><blockquote></blockquote><p><img src=/2020/09/09/spring/IoC_anno_exp.png alt=annotation配置的bean></p><blockquote><p>注解的形式以及文件结构<br><img src=/2020/09/09/spring/Ioc_structure.png alt=annotation的结构></p></blockquote><h4 id=问题><a href=#问题 class=headerlink title=问题></a>问题</h4><pre><code>在案例中，配置文件存在annotation和xml同时存在，下面将其改造为纯注解方式

1. 改变xml中的组件扫描
    @Configurtion:
        * 作用：用于指定当前类是配置类
         * 当配置类作为AnnotationConfigApplicationContext()的参数时可以不写@Configuration，由扫描器直接扫描该配置类
         * 如果是子配置类，而且子配置类的字节码没有作为参数传入，必须写@Configuration

    @ComponentScan
        * 作用：用于指定spring在创建容器是需要扫描的包
        * 参数：value basePackages作用一样（@Alisafor）    
                类似&lt;context:component-scan base-package=&quot;com.spring_04_exp&quot;/&gt;

    一旦这个类上写了@Configuration 和@ComponentScan ,spring就会自动扫描配置包，并且创建对象将其放入容器，只需要拿到这个bean对象就可以了。

2. 根据方法的返回值创建Bean对象
    @Bean
        * 作用：把当前方法的返回值作为Bean对象存入spring容器中
        * 参数：name:
            用于指定bean的id,当不写时，方法名作为默认值
        * 使用注解配置方法时，spring框架会在容器中查找相对于的bean容器，查找方法与@AutoWired相同

3. 配置文件的读取
    @PropetySource
        * 作用：读取配置文件，用于指定properties文件的位置
        * 参数：value
            文件的名称:文件的路径
        * classpath关键字，表示在类路径下

4. 导入其他的配置类
    @Import
        * 作用：用于导入其他的配置类
        * 参数：value
            用于指定其他配置类的的字节码
        * 当我们使用Import注解时，拥有Import的配置类就是父配置类，写在value中的就是子配置类</code></pre><blockquote></blockquote><p><img src=/2020/09/09/spring/anno_withoutxml_1.png alt=配置类><br><img src=/2020/09/09/spring/anno_withoutxml_2.png alt=配置类></p><pre><code>5. spring整合junit
    1. 程序的入口
        main方法
    2. JUnit单元测试
        没有main方法也能执行，其实junit中集成了main方法
        该方法就会判断当前测试类中有哪些方法上由@Test方法
        junit就会让Test注解执行该方法
    3. junit不知道spring框架
        在执行测试方法的时候，junit根本不知道由spring框架
        所以不会读取配置文件/创建spring容器

    4. 当测试方法执行时，没有IoC容器，就算写了@Autowired注解，也无法注入

    5. 解决方式    
        1. 导入spring整合test的jar包
        2. 使用junit的main方法替换为spring提供的main方法
            1. @Runwith
                * 作用：改变junit的main方法，使用spring框架提供的main方法，可以创建容器
                * 替换的方法的类的字节码
        3. 告诉spring运行器，spring和IoC容器的创建基于xml还是注解
            2. @ContextConfiguration
                * 作用：指定spring和IoC容器的创建基于xml还是注解
                * 参数：
                    locations : 指定xml文件的位置，加上classpath关键字，表示在类路径下
                    classes: 指定配置类位置，字节码文件

    6. 出现问题
        1. spring框架的5.x版本整合junit必须在4.12版本以上
        2. spring-context以及spring-test的版本号要一致
        3. 如果一直无法导入jar包，可以先将本地maven仓库对应的jar包删除，重新导入坐标</code></pre><h2 id=spring的AOP><a href=#spring的AOP class=headerlink title=spring的AOP></a>spring的AOP</h2><h3 id=完善account的案例><a href=#完善account的案例 class=headerlink title=完善account的案例></a>完善account的案例</h3><h4 id=进行账户之间的转账><a href=#进行账户之间的转账 class=headerlink title=进行账户之间的转账></a>进行账户之间的转账</h4><pre><code>1. 增加新的转账方法
2. 防止转账异常，应该在持久层增加事务控制
3. 将事务控制放在业务层控制
4. 增加数据库连接工具类
5. 为了保证每次连接都只有一个事务控制，将连接和线程绑定
6. 增加事务管理工具类 
7. 改变连接池对象，增加数据注入

增加很多冗余代码，配置文件变得更为复杂</code></pre><h3 id=动态代理><a href=#动态代理 class=headerlink title=动态代理></a>动态代理</h3><pre><code>1. 优势
    * 字节码随用随创建，随用随代理
    * 在不改变源码的时候对方法进行增强</code></pre><h4 id=基于接口的动态代理><a href=#基于接口的动态代理 class=headerlink title=基于接口的动态代理></a>基于接口的动态代理</h4><pre><code>1. 涉及的类
    * Proxy类
    * JDK官方

2. 创建代理对象的方法
    * Proxy.newProxyInstance()

3. 要求
    * 被代理对象至少要实现一个接口，如果没有，不能使用

4. newProxyInstance()的参数
    * ClassLoader:类加载器
        用于加载代理对象的字节码，和被代理对象使用相同的类加载器：固定写法

    * Class[]:字节码数组
        用于指定代理和被代理对象实现相同的方法，代理谁就写谁的接口：固定写法

    * InvacationHandler
        用于指定增强的代码
        让我们写任何实现代理，一般在某个实现方法上进行改变
        一般情况下，为匿名内部类，但是不是必须的
        此接口的实现类，都是谁用谁写

5. InvacationHandler的实现方法的参数</code></pre><blockquote><pre><code>实现类中需要重写invoke方法,执行被代理对象的任何方法都会经过该方法
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
   return null;
 }
    * proxy : 被代理对象的引用
    * method : 当前执行的方法
    * args : 当前方法执行的参数
    * 返回类型：和被代理对象的相同方法有相同的返回值类型</code></pre></blockquote><h4 id=基于子类的动态代理><a href=#基于子类的动态代理 class=headerlink title=基于子类的动态代理></a>基于子类的动态代理</h4><pre><code>1. 导入jar包
    cglib包

2. 涉及的类
    * Enhancer类
    * 第三方cglib库

3. 创建代理对象的方法
    * Enhancer.create()方法

4. create方法的参数
    * Class:被代理对象的字节码
    * Callback:
        * 用于提供增强的方法
         * 如何代理对象，该接口的实现类，通常情况下为匿名内部类，但不是必须的
         * 此接口的方法都是谁用谁写
         * 实现该接口的子接口的实现类，MethodInterceptor方法拦截器

5. MethodInterceptor方法的参数</code></pre><blockquote><pre><code>方法的重写
@Override
public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
    return null;
}
参数：
    * 执行被代理对象的方法都经过该方法
    * @param o 被代理对象
    * @param method 当前执行的方法
    * @param objects 当前方法执行的对象
    *                和基于接口的方法的invoke参数相同
    * @param methodProxy 当前执行方法的代理对象
    * @return 和当前方法的返回值类型相同
    * @throws Throwable    </code></pre></blockquote><h4 id=动态代理在案例中的使用><a href=#动态代理在案例中的使用 class=headerlink title=动态代理在案例中的使用></a>动态代理在案例中的使用</h4><pre><code>1. 创建代理工厂类，在获取AccountService的基础上，对原有的方法进行增强，增加事务控制</code></pre><blockquote><pre><code>public class BeanFactory {
    private IAccountService accountService;
    private TransactionManager transactionManager;</code></pre></blockquote><pre><code>public void setTransactionManager(TransactionManager transactionManager) {
    this.transactionManager = transactionManager;
}</code></pre><blockquote></blockquote><pre><code>public final void setAccountService(IAccountService accountService) {
    this.accountService = accountService;
}</code></pre><blockquote></blockquote><pre><code>/**
 * 获取代理对象的返回方法
 * @return
 */
public IAccountService getAccountService(){
    return (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(),
            accountService.getClass().getInterfaces(), new InvocationHandler() {
                /**
                 * 增强方法,对事务进行增强
                 */
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    Object rtValue = null;
                    try {
                        //1.开启事务
                        transactionManager.beginTransaction();
                        //2.执行操作
                        rtValue = method.invoke(accountService,args);
                        //3.提交事务
                        transactionManager.commitTransaction();
                        //4.返回结果
                        return rtValue;
                    } catch (Exception e) {
                        //5.回滚事务
                        transactionManager.rollbackTransaction();
                        throw new RuntimeException(e);
                    } finally {
                        //6.释放资源
                        transactionManager.releaseTransaction();
                    }
                }
           });
     }
  }

2. bean.xml的配置
    * 增加新的bean对象，beanFactory
    * 使用工厂的方法，创建代理类对象，由于代理类对象的数据类型和被代理对象的数据类型相同，在测试的时候需要对注入的数据进行指定</code></pre><p><img src=/2020/09/09/spring/proxy.png alt=代理类对象的配置文件></p><pre><code>3. 测试类</code></pre><p><img src=/2020/09/09/spring/proxy_test.png alt=动态代理的测试类></p><h3 id=AOP的概念><a href=#AOP的概念 class=headerlink title=AOP的概念></a>AOP的概念</h3><pre><code>1. Aspect Oriented Programming:面向切面编程
    通过预编译和运行期动态代理的方式，实现程序功能的统一维护的一种技术。AOP是OOP编程的延续，是函数式编程的一种衍生泛型，可以使用AOP对业务逻辑进行隔离，降低程序之间的耦合性，提高代码的可重用率。

    简单来说，将重复的代码抽取出来，在需要使用的时候，通过动态代理的方式，在不修改源码的基础上，对已有的方法进行增强。

2. AOP的优势
    1. 作用
        * 在程序的运行期间不改变源码的基础上，对已有的方法进行增强

    2. 优势
        * 减少重复代码
        * 提高开发效率
        * 方便维护

3. 实现方式
    动态代理
    spring会根据是否实现了接口，动态的选择实现代理的方式

4. AOP的相关术语
    * Joinpoint(连接点)：
        所谓连接点是指那些被拦截到的点，在spring中，只支持对方法类型的连接点。
        （业务层接口中的所有方法），连接业务和增强方法的点

    * Pointcut(切入点)：
        被增强的方法，叫做切入点，我们对于哪些joinpoint方法进行增强的定义

    切入点都是连接点，但不是所有的连接点都是切入点

    * Advice(通知/增强):
        拦截到Joinpoint之后所作的事情叫做通知。
        通知的类型：
            前置通知，后置通知，异常通知，最后通知，环绕通知</code></pre><p><img src=/2020/09/09/spring/advice.png alt=advice_types></p><pre><code>    * Target(目标对象)：
        代理的目标对象，即被代理对象

    * Weaving(织入)：
        把增强应用到目标对象来创建新的代理对象的过程。
        spring采用动态代理技术进行织入

    * Proxy(代理)：
        一个类被AOP织入后，产生一个代理对象

    * Aspect(切面)：
        切入点和通知的结合，切入点和通知的有序组合
5. 明确
    1. 开发阶段：
        核心业务代码，大部分程序员
        把公共代码抽取出来，制作成通知（最后才做）
        在配置文件中，声明切入点和通知的关系，即切面，

    2. 运行阶段：
        spring框架监控切入点的执行，一旦检测到切入点方法正在执行，则立即使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理的对应位置，将通知的功能织入，完成代码的逻辑运行。</code></pre><h3 id=基于XML的AOP配置><a href=#基于XML的AOP配置 class=headerlink title=基于XML的AOP配置></a>基于XML的AOP配置</h3><pre><code>1. 配置步骤
    1. 把通知的bean交给spring来管理（由spring来统一控制）
    2. 使用aop:config标签表明开始aop配置,开始配置
    3. 使用aop:aspect:配置切面
          id：给切面提供唯一属性
          ref:通知类的bean的id

    4. 在aop:aspect标签的内部使用对应的标签配置通知的类型
         现在的示例的通知类型是printlog方法在切入点的执行，为前置类型
            aop:before表示配置前置通知
                  method属性用于指定那个方法是前置通知

    5. pointcut属性：指定切入点表达式，该表达式的含义：对业务层的那些方法增强
        写法；关键字：execution(表达式)
          表达式：
              访问修饰符 返回值 包名.包名...类名.方法名（参数列表）
          标准表达式：
              execution(public void com.spring_AOP_xml.service.impl.AccountServiceImpl.saveAccount())</code></pre><p><img src=/2020/09/09/spring/xml_AOP.png alt=XML配置AOP></p><pre><code>2. 切入点表达式的化简
    1. 通配表达式写法：* *..*.*(..),所有包下的方法都被增强
    * 步骤
        public void com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        1. 访问修饰符可以省略：
            void com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        2. 返回值类型可以使用通配符*代替：
            * 
    com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        3. 包名可以使用*.来代替，有几级包，需要写几个 
            * *.*.*.*.IAccountServiceImpl.saveAccount()
            使用*..可以表示当前包和子包，代表所有的包
        4. 类名和方法名可以使用*来表示
            * *..*.*()
        5. 参数：
            基本数据类型：直接写类型  int
            引用数据类型: 包名.类名  java.lang.String
            可以使用*来代表有无参数
                * *..*.*()和* *..*.*(*)不一样
            可以使用 ..来表示有无参数
        所以：
            * *..*.*(..):表示对所有类上的所有方法都进行增强

    2. 开发中：对业务层上的所有方法都进行增强
        * com.spring_AOP_xml.service.impl.*.*(..)

    3. 通用切入点表达式简化最终版：
        aop:pointcut标签：写在&lt;aop:aspect&gt;标签内部，但只能在当前标签内部使用，也可以写在外部，所有切面都可以使用，此时必须出现在切面之前
            id 切入点的唯一表示 
            expression：指定表达式内容
          &lt;aop:pointcut id=&quot;pc1&quot; expression=&quot;execution(* com.spring_AOP_xml.service.impl.*.*(..))&quot;/&gt;

        使用方式：
            &lt;aop:after method=&quot;printLog&quot; pointcut-ref=&quot;pc1&quot;/&gt;

3. 通知的类型（advice）
    前置通知：切入点方法执行之前
    后置通知：切入点方法正常执行之后执行
    异常通知：切入点方法异常的时候执行
    最终通知：无论怎样都会执行

    后置通知和异常通知只会执行一个</code></pre><p><img src=/2020/09/09/spring/advice_types.png alt=通知类型></p><pre><code>环绕通知：
    * 问题：
        在配置环绕通知之后，业务层方法没有执行，环绕通知执行了
    * 分析：
        没有对切入点的方法的明确调用
    * 解决：
        spring提供了一个接口，ProceedingJoinPoint的方法中proceed(),明确切入点方法的调用，该方法可以传入环绕通知参数，在程序执行期间，spring框架会为我们创建实现类。</code></pre><p><img src=/2020/09/09/spring/around_advice.png alt=aroundadvice></p><pre><code>* 环绕通知是spring框架为我们提供的一种方式：可以手动控制增强代码执行的方式</code></pre><h3 id=基于注解的AOP配置><a href=#基于注解的AOP配置 class=headerlink title=基于注解的AOP配置></a>基于注解的AOP配置</h3><pre><code>1. 加入context扫描
2. 配置注解产生对象
3. 改变增强类的信息，切面的方法
4. 在bean.xml中增加开启注解配置AOP的标签
    &lt;aop:aspectj-autoproxy/&gt;:有这个标签才使用注解配置AOP</code></pre><p><img src=/2020/09/09/spring/AOP_anno.png alt=通知和切面类注解></p><h2 id=JdbcTemlate><a href=#JdbcTemlate class=headerlink title=JdbcTemlate></a>JdbcTemlate</h2><h3 id=spring中的JdbcTemplate><a href=#spring中的JdbcTemplate class=headerlink title=spring中的JdbcTemplate></a>spring中的JdbcTemplate</h3><pre><code>1. 概念    
    * spring框架的提供的一个对象，是对原始Java API的简单封装，spring为我们提供了很多操作模板类。
    * 操作关系型数据库：
    * 操作nosql数据库
    * 操作消息队列:

    使用的时候需要导入spring-jdbc-5.1.10.RELEASE.jar
                    spring-tx-5.1.10.RELEASE.jar(事务相关)

2. 作用
    * 用于和数据库进行交互的，实现数据的CRUD

3. 如果重复的代码过多
    可以抽取重复代码，形成父类，使AccountDaoImpl继承该父类，也可以实现Dao的实现类</code></pre><blockquote><p>Dao的两种实现方式:<br><img src=/2020/09/09/spring/dao_xml.png alt=dao的xml配置方式><br><img src=/2020/09/09/spring/dao_anno.png alt=dao的annotation配置方式></p></blockquote><h2 id=事务控制><a href=#事务控制 class=headerlink title=事务控制></a>事务控制</h2><h3 id=spring的事务><a href=#spring的事务 class=headerlink title=spring的事务></a>spring的事务</h3><pre><code>1. 明确
    * Java EE体系进行开发，事务处理位于业务层，spring提供分层设计业务层的事务处理方法
    * spring框架为我们提供一组事务控制的接口，位于spring-tx-5.1.10.RELEASE.jar
    * spring的事务控制基于AOP的，可以使用配置的控制和编程，主要使用配置事务

2. 事务API
    * platformTransactionManager</code></pre><h3 id=基于xml的事务控制><a href=#基于xml的事务控制 class=headerlink title=基于xml的事务控制></a>基于xml的事务控制</h3><pre><code>1. 使用
    1. 配置事务管理器（DataSourceTransactionManager）
    2. 配置事务通知(tx:advice)
          此时需要导入事务的约束,tx的名称约束，同时也需要aop的支持
          使用tx:advice配置事务通知 
            id:唯一标志 
            transaction-manager:提供事务管理器使用
    3. 配置aop的通用切入点表达式
    4. 建立事务通知和切入点表达式的关联
    5. 配置事务的属性：事务的通知tx:advice的内部
        * isolation: 指定事务的隔离级别，默认值式DEFAULT,
        * propagation: 事务的传播行为REQUESTED 表示一定会有事务，增删改的选择，查询可以选择SUPPORTS
        * read-only: 事务是否只读，默认为false
        * time-out: 事务的超时时间,默认-1，表示永不超时，如果指定，以秒为单位
        * rollback-for: 指定一个异常，当产生该异常时，事务回滚，产生其他异常，事务不回滚，没有默认值，表示任何异常都会回滚
        * no-rollback-for：指定一个异常，当产生该异常时，事务不回滚，产生其他异常，事务回滚，没有默认值，表示任何异常都会回滚

2. 使用实例</code></pre><p><img src=/2020/09/09/spring/tran_xml.png alt=基于xml的声明式事务></p><h3 id=基于注解的事务配置><a href=#基于注解的事务配置 class=headerlink title=基于注解的事务配置></a>基于注解的事务配置</h3><pre><code>1. 步骤
    1. 配置事务管理器（DataSourceTransactionManager）
    2. 开启spring对注解事务的支持（tx:annotation-driven）
    3. 使用注解@transactional对需要事务的地方进行定义
        xml中的事务属性，均可以在@Transactional的属性中配置

    如果查询和增删改的方法数量差不多，需要对增删改的方法单独配置事务支持

2. 实例</code></pre><p><img src=/2020/09/09/spring/tran_anno.png alt=基于注解的声明式事务></p><h3 id=使用纯注解的事务配置><a href=#使用纯注解的事务配置 class=headerlink title=使用纯注解的事务配置></a>使用纯注解的事务配置</h3><p><img src=/2020/09/09/spring/tx_without_xml.png alt=纯注解的声明式事务></p></div><div><div style="text-align:center;color: #ccc;font-size:14px;">------ 本文结束<i class="fa fa-paw"></i>感谢您的阅读 ------</div></div><footer class=post-footer><div class=post-tags><a href="/tags/Spring/" rel=tag><i class="fa fa-tag"></i> Spring</a></div><div class=post-widgets><div id=needsharebutton-postbottom><span class=btn><i class="fa fa-share-alt" aria-hidden=true></i></span></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href="/2020/06/18/mysql57/" rel=next title="MYSQL 5.7.29"><i class="fa fa-chevron-left"></i> MYSQL 5.7.29</a></div><span class=post-nav-divider></span><div class="post-nav-prev post-nav-item"><a href="/2020/09/10/reflection/" rel=prev title="Java Reflection">Java Reflection <i class="fa fa-chevron-right"></i></a></div></div><div><p id=div-border-left-red><b>本文基于<a target=_blank title="Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0</a>国际许可协议发布</b><br><span><b>本文地址:</b><a href="/2020/09/09/spring/" title=Spring>http://print3306.github.io/2020/09/09/spring/</a><br><b>转载请注明出处, 谢谢！</b></span></p></div></footer></div></article><div class=post-spread></div></div></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>文章目录</li><li class=sidebar-nav-overview data-target=site-overview-wrap>站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class=site-overview><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/images/avatar1.jpg alt=浊酒一杯><p class=site-author-name itemprop=name>浊酒一杯</p><p class="site-description motion-element" itemprop=description>砥砺前行</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/archives><span class=site-state-item-count>29</span> <span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/index.html><span class=site-state-item-count>14</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/index.html><span class=site-state-item-count>21</span> <span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=mailto:3230372879qq.com target=_blank title=E-Mail><i class="fa fa-fw fa-globe"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#概述><span class=nav-number>1.</span> <span class=nav-text>概述</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-什么是spring：><span class=nav-number>1.1.</span> <span class=nav-text>1. 什么是spring：</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#2-spring的核心：><span class=nav-number>1.2.</span> <span class=nav-text>2. spring的核心：</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#3-发展历程和优势><span class=nav-number>1.3.</span> <span class=nav-text>3.发展历程和优势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#程序的耦合和解耦><span class=nav-number>2.</span> <span class=nav-text>程序的耦合和解耦</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#耦合><span class=nav-number>2.0.1.</span> <span class=nav-text>耦合</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#解耦><span class=nav-number>2.0.2.</span> <span class=nav-text>解耦</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class=nav-link href=#IoC（Inversion-of-Control）><span class=nav-number>3.</span> <span class=nav-text>IoC（Inversion of Control）</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#基于XML的IoC配置><span class=nav-number>3.1.</span> <span class=nav-text>基于XML的IoC配置</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#初步使用><span class=nav-number>3.1.1.</span> <span class=nav-text>初步使用</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#BeanFactory和ApplicationContext><span class=nav-number>3.1.2.</span> <span class=nav-text>BeanFactory和ApplicationContext</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#spring对bean对象的管理细节><span class=nav-number>3.1.3.</span> <span class=nav-text>spring对bean对象的管理细节</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#1-创建bean的三种方式><span class=nav-number>3.1.3.1.</span> <span class=nav-text>1. 创建bean的三种方式</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#2-bean对象的作用范围><span class=nav-number>3.1.3.2.</span> <span class=nav-text>2. bean对象的作用范围</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#3-bean对象的生命周期><span class=nav-number>3.1.3.3.</span> <span class=nav-text>3. bean对象的生命周期</span></a></li></ol></li><li class="nav-item nav-level-4"><a class=nav-link href=#依赖注入（dependency-injection-DI）><span class=nav-number>3.1.4.</span> <span class=nav-text>依赖注入（dependency injection:DI）</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#1-通过默认构造函数注入><span class=nav-number>3.1.4.1.</span> <span class=nav-text>1. 通过默认构造函数注入</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#2-使用set进行依赖注入><span class=nav-number>3.1.4.2.</span> <span class=nav-text>2. 使用set进行依赖注入</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#3-使用注解进行依赖注入><span class=nav-number>3.1.4.3.</span> <span class=nav-text>3. 使用注解进行依赖注入</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#4-注入复杂数据类型><span class=nav-number>3.1.4.4.</span> <span class=nav-text>4. 注入复杂数据类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#基于注解的IoC配置><span class=nav-number>3.2.</span> <span class=nav-text>基于注解的IoC配置</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-用于创建bean对象的注解><span class=nav-number>3.2.1.</span> <span class=nav-text>1. 用于创建bean对象的注解</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-用于数据注入的注解><span class=nav-number>3.2.2.</span> <span class=nav-text>2. 用于数据注入的注解</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#3-用于改变作用范围的注解><span class=nav-number>3.2.3.</span> <span class=nav-text>3. 用于改变作用范围的注解</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#4-用于改变生命周期的注解><span class=nav-number>3.2.4.</span> <span class=nav-text>4. 用于改变生命周期的注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#使用IoC的一个简单案例><span class=nav-number>3.3.</span> <span class=nav-text>使用IoC的一个简单案例</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#问题><span class=nav-number>3.3.1.</span> <span class=nav-text>问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#spring的AOP><span class=nav-number>4.</span> <span class=nav-text>spring的AOP</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#完善account的案例><span class=nav-number>4.1.</span> <span class=nav-text>完善account的案例</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#进行账户之间的转账><span class=nav-number>4.1.1.</span> <span class=nav-text>进行账户之间的转账</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#动态代理><span class=nav-number>4.2.</span> <span class=nav-text>动态代理</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#基于接口的动态代理><span class=nav-number>4.2.1.</span> <span class=nav-text>基于接口的动态代理</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#基于子类的动态代理><span class=nav-number>4.2.2.</span> <span class=nav-text>基于子类的动态代理</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#动态代理在案例中的使用><span class=nav-number>4.2.3.</span> <span class=nav-text>动态代理在案例中的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#AOP的概念><span class=nav-number>4.3.</span> <span class=nav-text>AOP的概念</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#基于XML的AOP配置><span class=nav-number>4.4.</span> <span class=nav-text>基于XML的AOP配置</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#基于注解的AOP配置><span class=nav-number>4.5.</span> <span class=nav-text>基于注解的AOP配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#JdbcTemlate><span class=nav-number>5.</span> <span class=nav-text>JdbcTemlate</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#spring中的JdbcTemplate><span class=nav-number>5.1.</span> <span class=nav-text>spring中的JdbcTemplate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#事务控制><span class=nav-number>6.</span> <span class=nav-text>事务控制</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#spring的事务><span class=nav-number>6.1.</span> <span class=nav-text>spring的事务</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#基于xml的事务控制><span class=nav-number>6.2.</span> <span class=nav-text>基于xml的事务控制</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#基于注解的事务配置><span class=nav-number>6.3.</span> <span class=nav-text>基于注解的事务配置</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#使用纯注解的事务配置><span class=nav-number>6.4.</span> <span class=nav-text>使用纯注解的事务配置</span></a></li></ol></li></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright>&copy; <span itemprop=copyrightYear>2020</span> <span class=with-love><i class="fa fa-user"></i></span> <span class=author itemprop=copyrightHolder>浊酒一杯</span> <span class=post-meta-divider>|</span> <span class=post-meta-item-icon><i class="fa fa-area-chart"></i></span> <span class=post-meta-item-text>Site words total count&#58;</span> <span title="Site words total count">59k</span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i> <span id=scrollpercent><span>0</span>%</span></div><div id=needsharebutton-float><span class=btn><i class="fa fa-share-alt" aria-hidden=true></i></span></div></div><script type=text/javascript>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script><script type=text/javascript src="/lib/jquery/index.js?v=2.1.3"></script><script type=text/javascript src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type=text/javascript src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type=text/javascript src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type=text/javascript src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type=text/javascript src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type=text/javascript src="/js/src/utils.js?v=5.1.4"></script><script type=text/javascript src="/js/src/motion.js?v=5.1.4"></script><script type=text/javascript src="/js/src/affix.js?v=5.1.4"></script><script type=text/javascript src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type=text/javascript src="/js/src/scrollspy.js?v=5.1.4"></script><script type=text/javascript src="/js/src/post-details.js?v=5.1.4"></script><script type=text/javascript src="/js/src/bootstrap.js?v=5.1.4"></script><script type=text/javascript>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><link rel=stylesheet href=/lib/needsharebutton/needsharebutton.css><script src=/lib/needsharebutton/needsharebutton.js></script><script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "vertical";
      
          flOptions.position = "topRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script><script type=text/javascript src=/js/src/clicklove.js></script><script type=text/javascript>
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script><script type=text/javascript color=192,192,192 opacity=0.6 zindex=-1 count=150 src=//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js>
  </script><style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style><script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script><script src=/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>
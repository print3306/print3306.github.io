<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>序/README</title>
    <url>/2020/10/12/readme/</url>
    <content><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><h3 id="个人经历"><a href="#个人经历" class="headerlink" title="个人经历"></a>个人经历</h3><pre><code>大学四年，碌碌无为，回首大学四年的学习生涯，一无是处。
人生最美好的四年，没有找到自己的人生方向，随风摇摆，没有方向
在大学的最后一段时间，找到了的自己的人生方向，可以算是人生目标
知道了不是每个人都有各自的使命与责任，方向最重要，认清自己

提升自己，找到一份工作，孝顺父母，相信自己，可以活得更好
2020/10/12 20:53:03 </code></pre><h3 id="学习历程"><a href="#学习历程" class="headerlink" title="学习历程"></a>学习历程</h3><pre><code>1. 2020-9-1 2020-10-12，学习java的框架使用</code></pre>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-SE</title>
    <url>/2020/12/07/Java-SE/</url>
    <content><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>Java SE的基础知识，复习Java基础知识的整理笔记。</p>
<p>基于Java JDK 1.8</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 返回值类型 方法名（参数列表）&#123;</span><br><span class="line">    方法体；</span><br><span class="line">    返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul>
<li>修饰符：用来限定方法的类型、适用范围，包括public，protected，private..</li>
<li>返回值类型：方法执行结束后，返回的结果，可以返回值任意类型，如果没有返回值，使用void来标识；返回值类型需要和方法的返回值类型相对应</li>
<li>方法名：需要见名知义，一般使用“驼峰命名法”，首字母小写，后面的每个单词的首字母大写</li>
<li>形参列表：形参都是<strong>局部变量</strong>，方法执行结束之后释放内存</li>
<li>返回值：使用关键字<strong>return XX</strong>，返回结果，如果只有一个<strong>return</strong>，则表示结束方法的执行</li>
</ul>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><ul>
<li>静态方法，可以使用<strong>ClassName.Mathod()</strong>，类名.方法名来进行调用</li>
<li>非静态方法，实例化的类对象来调用方法</li>
<li>如果方法存在返回值，可以接收*[也可以不接收，这样做没有意义]*，使用方法的返回值类型变量来接收，接收变量的类型需要包含方法的返回值类型</li>
<li>如果方法没有返回值，不能接收返回值，接收会编译报错</li>
</ul>
<h3 id="return、break和continue"><a href="#return、break和continue" class="headerlink" title="return、break和continue"></a>return、break和continue</h3><ul>
<li><p>return：中断<strong>当前方法</strong>的执行</p>
</li>
<li><p>break：中断循环代码的执行，跳出<strong>当前层循环</strong></p>
</li>
<li><p>continue：中断<strong>当前次循环</strong></p>
</li>
</ul>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><ul>
<li>方法区：类加载器加载的class文件，存储在方法区内，代码片段</li>
<li>栈：在方法调用时，在栈空间分配空间。方法调用需要入栈，保存方法的局部变量。后进先出</li>
<li>堆：创建对象实例的时候，在堆中分配空间，通过new创建的对象都存储在堆内存之上</li>
</ul>
<p>栈的活动最为频繁，方法的压栈和出栈，主要存储局部变量，main方法的变量也存储在栈中；</p>
<p>堆，在对象创建的时候，才会进行分配空间，new出来的对象放置在方法区</p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><p>​    在java运行过程中，解释器在执行方法时，会首先根据方法名进行匹配方法，如果方法名相同，会根据方法的参数类型匹配。如果在同一个类中，两个方法的功能相似，可以利用方法重载来简化代码。两个方法不在同一个类中，不叫重载。</p>
<p>​    在<strong>一个类中，如果两个方法的名称相同，参数不同</strong>，这种形式叫做方法重载（Overload）。</p>
<p>参数不同：</p>
<ul>
<li>参数的个数不同</li>
<li>参数的类型不同</li>
<li>参数的顺序不同</li>
</ul>
<h4 id="方法重载和返回值类型"><a href="#方法重载和返回值类型" class="headerlink" title="方法重载和返回值类型"></a>方法重载和返回值类型</h4><p>如果两个的方法只有返回值类型不同，编译器认为这两个方法不叫重载。</p>
<p>方法重载和方法的返回值类型无关，修饰符列表无关，参数名称无关。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>方法自己调用自己，<strong>递归必须要有结束条件</strong>，如果递归太深，栈内存空间不足，会导致栈溢出异常。</p>
<p>能使用if和while的问题，尽量使用判断和循环来解决</p>
<p>如果真的遇到递归：</p>
<ul>
<li>首先检查递归结束条件，条件不对，必须修改递归条件，将其修改正确</li>
<li>递归条件不对，可以手动调整JVM栈内存的初始化大小，直到可以满足递归空间</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h3><p>面向过程：注重实现功能的步骤，面向过程中没有对象的概念，只有实现功能的步骤和因果关系。一般来说，由于步骤之间存在因果关系，一但其中一部分出现问题，整个系统都可能出现问题。代码和代码之间的耦合性高，拓展性较差</p>
<p>面向对象：将数据和对数据的操作封装在一起，将所有的事物都看作“对象”</p>
<h3 id="OOA、OOD和OOP"><a href="#OOA、OOD和OOP" class="headerlink" title="OOA、OOD和OOP"></a>OOA、OOD和OOP</h3><ul>
<li>OOA：面向对象分析</li>
<li>OOD：面向对象设计</li>
<li>OOP：面向对象编程</li>
</ul>
<p>面向对象的专业术语</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>类：现实中不是真实存在的，是一个抽象的概念，人的大脑进行总结的结果</p>
<p>对象：真实存在的个体</p>
<ul>
<li><p>类描述所有对象共同特征信息，就像一个模板</p>
</li>
<li><p>对象是通过类创造出来的个体，也叫做<strong>实例</strong></p>
</li>
<li><p>从对象抽取共同特征形成类的过程叫做<strong>抽象</strong>，创建对象的过程叫做<strong>创建、实例化</strong></p>
</li>
</ul>
<p>$类-&gt;[实例化]-&gt;对象（实例）$</p>
<p>$对象-&gt;[抽象]-&gt;类$</p>
<p>类：共同特征包括<strong>属性和方法</strong>，属性也叫做状态，方法也叫做行为 </p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    属性；<span class="comment">// 以变量的形式存在</span></span><br><span class="line">    方法；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性：对应数据，数据需要存放在变量中</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ClassName class1 = new ClassName();</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>

<h4 id="内存变化"><a href="#内存变化" class="headerlink" title="内存变化"></a>内存变化</h4><p><img src="/2020/12/07/Java-SE/JVM_mem.png" alt="创建对象时的内存变化"></p>
<ol>
<li>首先，加载字节码文件，将需要的字节码文件加载到方法区</li>
<li>执行main方法，在栈空间分配空间，如果有对象创建过程，在堆内存分配一部分空间，来创建对象，并将实例变量初始化为默认值</li>
<li>将对象的堆内存地址赋值给变量，即引用</li>
<li>依次执行下面的语句</li>
</ol>
<h4 id="对象和引用"><a href="#对象和引用" class="headerlink" title="对象和引用"></a>对象和引用</h4><ul>
<li>对象：通过new创建，在堆内存中存储</li>
<li>引用：变量，而且指向对象的堆内存空间地址</li>
</ul>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>Java中的参数传递，只有一种，将“值”复制一份，传给变量，这个“值”可以是局部变量也可以是堆内存地址</p>
<ol>
<li><p>局部变量</p>
<p>由于复制一份“值”，这个变量会在栈空间占据两个内存空间，这两个内存空间互不干扰，修改一个不会引起另外的值的变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line">System.out.println(i);</span><br><span class="line">i++;</span><br><span class="line">System.out.println(i);</span><br><span class="line">System.out.println(j);</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>堆内存地址</p>
<p>此时可以将这个变量叫做<strong>引用</strong>，由于这个“值”指向堆内存，将这个变量复制一份，指向的堆内存不变，有多个引用指向同一个对象，其中一个改变，堆内存中的数据就会跟着改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(student.age);</span><br><span class="line"><span class="comment">// 引用也是一个“值”，代表对象的堆内存地址</span></span><br><span class="line">Student student2 = student;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h4><p>​    空指针异常：NullPointerException</p>
<p>​    原因：<strong>空引用访问实例成员变量或者方法</strong>，在调用时，指向的内存被置为null，如果访问的是静态成员变量，不会产生空指针异常，表面上使用的应用访问静态成员变量，实际上还是使用的类名访问</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li>构造器的名称和类名一致，没有返回值类型，使用new创建，在堆内存创建对象，并对实例变量进行初始化</li>
<li>如果类中没有构造器，系统会自动创建一个无参构造器，又叫做缺省构造器；如果类中有构造器，系统不会自动创建缺省构造器</li>
<li>构造器和其他方法一样，可以进行重载，最好手动创建一个无参构造器，对构造器进行重载，防止创建对象时不传参数，方法报错(子类继承父类，构造器中可能会调用父类的无参构造器；使用反射机制，创建实例对象的时候，默认采用无参构造函数创建对象)</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>保证数据的安全性</li>
<li>屏蔽内部实现原理，开放部分接口，方便使用</li>
<li>降低程序耦合性，提高程序的复用性</li>
<li>有了封装机制，才有继承；有了继承，才有多态，面向对象的基础就是封装</li>
</ol>
<h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><p>访问控制权限+set/get方法</p>
<p>访问控制权限：private，私有化成员变量，类外部无法访问成员变量</p>
<p>set/get方法：set可以对成员变量进行写操作，get可以对成员变量进行读操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    Student()&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>static可以修饰成员变量和方法，标志方法为静态方法，也叫做类方法；成员变量叫做静态成员变量，也叫做类变量。可以直接使用<strong>类名.XXX</strong>调用，</p>
<ul>
<li>静态成员变量，在进行类加载时，在方法区分配内存空间，并完成初始化，可以使用<strong>类名.XXX</strong>进行访问</li>
<li>静态成员变量只会加载一次，无论对象创建多少次</li>
<li>静态方法不能调用实例成员变量，因为在调用的时候，类实例对象可能还没有被创建</li>
</ul>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    java语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>静态代码块在类加载时执行，只执行一次，如果包含多个静态代码块，自上而下依次执行，在main方法执行之前执行；</p>
<p>静态代码块可以看作SUN公司提供的一个特殊时机：<strong><em>类加载时机</em></strong>，可以让程序在类加载时执行一些特殊操作：</p>
<ul>
<li>日志记录</li>
<li>初始化赋值</li>
</ul>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>静态代码块和静态成员变量，都是在类加载时进行初始化，只能依靠定义顺序来保证初始化顺序，否则会出现非法前向引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    id = <span class="number">121</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例代码块"><a href="#实例代码块" class="headerlink" title="实例代码块"></a>实例代码块</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    java语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>实例代码块在<strong>构造方法执行之前执行</strong>，在每次创建对象的时候都会执行一次</p>
<p>SUN公司提供的一个特殊的时机，叫做<strong><em>对象创建时机</em></strong>，可以执行一些共同的操作：</p>
<ul>
<li>需要每次都执行的语句</li>
</ul>
<h3 id="代码执行顺序"><a href="#代码执行顺序" class="headerlink" title="代码执行顺序"></a>代码执行顺序</h3><ul>
<li><a href="https://print3306.github.io/2020/12/05/Initialization/">代码执行顺序</a> </li>
</ul>
<ol>
<li>在类加载时，进行静态成员变量和静态成员变量的初始化</li>
<li>在main方法执行之后，如果有创建对象的语句，首先执行实例变量初始化，实例代码块执行，然后才是构造方法执行</li>
<li>如果继承了父类，首先执行父类的实例变量，实例代码块，构造方法，其次才执行子类的构造方法</li>
</ol>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p><a href="#super关键字">super关键字</a></p>
<ul>
<li>this是一个关键字，全部小写，<strong>表示一个引用，指向当前对象在堆内存中的地址</strong></li>
<li>this可以用在实例方法中，也可以用在构造方法中</li>
<li>this用在实例方法中，表示当前对象，<strong>引用</strong></li>
<li>this不能用在静态方法中，因为this表示当前对象，静态方法执行的时候，当前对象可能还未创建</li>
<li>this大部分情况下可以省略，但是在<strong>区分成员变量和局部变量时</strong>，不能省略</li>
<li>this用在构造方法中，表示<strong>调用当前类中的其他构造方法</strong>，<strong>this()</strong>，必须写在构造方法的第一行。所以，构造方法最多可以调用一个本类中的其他构造方法</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>被继承的类叫<strong>父类、超类、基类</strong>，继承别的类叫<strong>子类、派生类、扩展类</strong></li>
<li>Java不允许多继承，只允许单继承；如果想要继承多个类，只能使用间接继承</li>
<li>如果一个类没有显式的继承别的类，默认继承<strong>Object类</strong></li>
<li>Java规定，子类继承父类，除了构造方法不能继承之外，剩下的都可以继承。（私有成员变量不能直接访问）</li>
<li>一旦出现继承，父子类之间的耦合度紧密</li>
</ul>
<h3 id="方法覆盖（Override）"><a href="#方法覆盖（Override）" class="headerlink" title="方法覆盖（Override）"></a>方法覆盖（Override）</h3><p>方法覆盖又叫方法重写，表示子类重写父类中的方法</p>
<p>当父类的方法不满足子类的业务需求的时候，可以进行方法重写</p>
<h4 id="构成方法重写"><a href="#构成方法重写" class="headerlink" title="构成方法重写"></a>构成方法重写</h4><ul>
<li>具有继承关系的父子类</li>
<li>具有相同的方法名，参数列表，返回值类型相同<u>{基本数据类型，引用数据类型}</u></li>
<li>子类方法的访问权限不能小于父类方法的访问权限，public  &gt;  protected  &gt;  default</li>
<li>子类方法抛出异常的种类不能超过父类方法抛出的异常</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>Object类是所有类的父类，其中<strong>toString</strong>方法一般来说需要重写</li>
<li>对于<strong>System.out.println(Object obj)</strong>方法来说，如果参数是一个引用，首先会调用<strong>String.valueOf(obj)</strong>，获取toString方法的内容，然后打印输出</li>
</ul>
<h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><h5 id="静态方法能重写吗？"><a href="#静态方法能重写吗？" class="headerlink" title="静态方法能重写吗？"></a>静态方法能重写吗？</h5><p>静态方法实际上是由类名来调用的，方法重写必须和多态机制结合使用才有意义，虽然看起来使用的是子类的对象调用静态方法，但是实际上还是类名调用的，<strong>静态方法重写没有意义</strong></p>
<h5 id="私有方法能重写吗？"><a href="#私有方法能重写吗？" class="headerlink" title="私有方法能重写吗？"></a>私有方法能重写吗？</h5><p>私有方法不能重写</p>
<h5 id="方法的返回值类型相同的含义？"><a href="#方法的返回值类型相同的含义？" class="headerlink" title="方法的返回值类型相同的含义？"></a>方法的返回值类型相同的含义？</h5><ul>
<li>基本数据类型：必须一致</li>
<li>引用数据类型：返回值类型可以一致，也可以变小【使用子类】，但是不能变大</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>父类的引用指向子类的对象</p>
<h4 id="向上转型-向下转型"><a href="#向上转型-向下转型" class="headerlink" title="向上转型 向下转型"></a>向上转型 向下转型</h4><p>向上转型（Upcast）：将子类对象转为父类对象，<strong>父类引用调用子类对象</strong></p>
<p>向下转型（Downcast）：把指向子类对象的父类引用赋给子类引用叫向下转型，要强制转换，</p>
<p>子类引用不能直接指向父类型对象，ClassCastException</p>
<p>向上转型和向下转型的前提是<strong>两个类具有继承关系</strong>，如果不存在继承关系，就谈不上向上、向下转型</p>
<h4 id="多态具体含义"><a href="#多态具体含义" class="headerlink" title="多态具体含义"></a>多态具体含义</h4><p>多态：多种形态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"说话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"说中国话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        People p = <span class="keyword">new</span> Chinese();</span><br><span class="line">        p.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>何为多态：</p>
<p>​    编译阶段：在编译时，判断p类型为People，会在People.class文件查找speak方法，如果存在，编译通过，会进行静态绑定。（编译阶段称为静态绑定）</p>
<p>​    运行阶段：在运行时，p指向Chinese对象在堆内存中的地址，实际上调用Chinese的speak的方法，这种叫做运行时绑定。（运行阶段称为动态绑定）</p>
<p>这种，在编译阶段和运行阶段指向的对象种类不同，叫做多态。</p>
<h4 id="类型转换异常-ClassCastExpection"><a href="#类型转换异常-ClassCastExpection" class="headerlink" title="类型转换异常(ClassCastExpection)"></a>类型转换异常(ClassCastExpection)</h4><p>在向下转换时，可能会出现这个异常，可以使用<strong>instanceof</strong>进行判断</p>
<h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><ul>
<li><p>是一个关键字</p>
</li>
<li><p>在运行时，<strong>动态判断一个引用是否为一个对象类型的实例</strong></p>
</li>
<li><p><strong>x instanceof X</strong>，x是否为X类型的一个实例，返回值为true|false，true:是一个实例，可以向下转型；false:不是一个类型，不能进行向下类型转换</p>
</li>
<li><p>在向下类型转换的时候，必须使用instanceof进行判断，防止出现异常</p>
</li>
</ul>
<h5 id="什么时候必须向下转型"><a href="#什么时候必须向下转型" class="headerlink" title="什么时候必须向下转型"></a>什么时候必须向下转型</h5><p>在父类引用调用子类特有的方法的时候，必须进行向下转型，此时需要使用<strong>instanceof</strong>判断类型</p>
<h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ul>
<li>降低程序的耦合，提高程序的可扩展性</li>
</ul>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p><a href="#this关键字">this关键字</a></p>
<ul>
<li>super是一个关键字，<strong>指向当前对象的父对象特征，不是引用也不是对象</strong></li>
<li>super可以出现在实例方法中，使用<strong>super.</strong>来调用，也可以出现在构造方法中，使用<strong>super()</strong>调用父类的构造方法</li>
<li>super不能出现在静态方法中</li>
<li>super在子类的构造方法中，只能出现在第一行，如果子类构造器没有显式的指明<strong>this()，super()</strong>，系统默认在第一行会使用<strong>super()</strong>，调用父类的无参构造方法，手动书写无参构造器可以防止编译报错</li>
<li>super在<strong>子类和父类有相同的变量名和方法名，并且调用父类的变量和方法时</strong>，不能省略</li>
<li>super肯定会执行，而且在子类的构造方法执行之前执行</li>
</ul>
<p><img src="/2020/12/07/Java-SE/super.png" alt="super的原理"></p>
<p><em>注意</em>：</p>
<p>​    super并不指向堆内存中的地址，不是一个引用，只是指向父类的特征，在创建对象的时候只创建子类对象一个对象。可以通过<strong>super.xXX</strong>来调用父类的方法</p>
<p>​    super不能像this一样单独使用，使用<strong>super.</strong>来调用父类的变量或者方法</p>
<h3 id="this和super"><a href="#this和super" class="headerlink" title="this和super"></a>this和super</h3><table>
<thead>
<tr>
<th></th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>含义</td>
<td>当前对象</td>
<td>当前对象的父类型特征</td>
</tr>
<tr>
<td>使用位置</td>
<td>构造方法、实例方法，不能在实例方法</td>
<td>构造方法、实例方法，不能在实例方法</td>
</tr>
<tr>
<td>使用方式</td>
<td>this、this. 、this()</td>
<td>super. 、super()</td>
</tr>
<tr>
<td>不能省略</td>
<td>成员变量和局部变量同名，访问成员变量</td>
<td>子类和父类具有同名变量或方法，访问父类成员</td>
</tr>
<tr>
<td>使用限制</td>
<td>this()必须出现在构造方法的第一行</td>
<td>super()必须出现在构造方法的第一行</td>
</tr>
</tbody></table>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul>
<li>final修饰的类，无法被继承</li>
<li>final修饰的方法，无法重写</li>
<li>final修饰的变量，<strong>只能被赋值一次</strong></li>
<li>final修饰的引用，一旦指向某个对象，不能再重新指向别的对象，但<strong>该引用指向的对象的内部数据是可以被改变的</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Num num = num1;</span><br><span class="line"><span class="comment">// 这个num指向的对象无法更改</span></span><br><span class="line">num1.no = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 引用内部的数据可以更改</span></span><br></pre></td></tr></table></figure>

<ul>
<li>final修饰的实例变量必须手动初始化，不能采用系统默认赋值</li>
<li>final修饰的实例变量一般和static一起使用，称为常量，存储在方法区，在类加载时赋初始值，不可被改变<code>public statil final double PI = 3.1415926</code></li>
</ul>
<h3 id="抽象类（abstract）"><a href="#抽象类（abstract）" class="headerlink" title="抽象类（abstract）"></a>抽象类（abstract）</h3><h4 id="什么是抽象类？"><a href="#什么是抽象类？" class="headerlink" title="什么是抽象类？"></a>什么是抽象类？</h4><p>类和类之间可能还有共同特征，将这共同特征提取出来，就形成了抽象类。<strong>由于类本身是不存在的，所以抽象类无法创建对象，无法实例化</strong></p>
<h4 id="类型和定义语法？"><a href="#类型和定义语法？" class="headerlink" title="类型和定义语法？"></a>类型和定义语法？</h4><p>类型：抽象类是引用数据类型</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span>&#123;</span><br><span class="line">    类体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>抽象类无法实例化，类本身在现实世界不存在，所以<strong>抽象类就是用来被子类继承的</strong></li>
<li>final和abstrcat不能联合使用，final不能被改变，abstract生来就需要被改变</li>
<li>抽象类的子类可以是抽象类，也可以是非抽象类</li>
<li>抽象类虽然不能被实例化，但是有构造方法，构造方法供子类在创建对象时调用</li>
<li>抽象类不一定有抽象方法，可以有，也可以没有</li>
<li><strong>一个非抽象类，继承抽象类，必须将抽象类中的抽象方法实现</strong></li>
</ul>
<h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h3><h4 id="类型和语法？"><a href="#类型和语法？" class="headerlink" title="类型和语法？"></a>类型和语法？</h4><p>类型：引用数据类型</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] <span class="class"><span class="keyword">interface</span> <span class="title">IName</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>接口支持多继承，一个接口可以继承多个其他的接口</li>
<li>接口是完全抽象的，只包含两部分内容<strong>常量、抽象方法</strong></li>
<li>接口中的所有元素都是public进行修饰的，公开的</li>
<li>接口中的方法都是抽象方法，所以不能有方法体</li>
<li>接口中的常量都是由<code>public static final</code>修饰的，可以省略不写</li>
<li>接口中的方法都是由<code>public abstract</code>修饰的，可以省略不写</li>
<li><strong>一个非抽象的类实现接口，必须实现所有方法</strong></li>
<li>一个类可以实现多个接口</li>
<li>继承和实现同时存在，继承在前，实现在后，<strong>使用接口，可以使用多态</strong></li>
</ul>
<h3 id="package和import机制"><a href="#package和import机制" class="headerlink" title="package和import机制"></a>package和import机制</h3><h4 id="pacakge机制"><a href="#pacakge机制" class="headerlink" title="pacakge机制"></a>pacakge机制</h4><p>将相同功能的代码组织起来，区分不同的代码，有效解决类重名的问题，<strong>因为在使用时需要导入包名，相同的类出现在不同的包中</strong></p>
<ul>
<li>package：声明包语句，只允许出现在代码的第一行（注释除外）</li>
<li>一般来说，包名为<strong>公司域名反写，加项目名，加模块名</strong>，<code>com.baidu.map.util</code></li>
</ul>
<h4 id="import机制"><a href="#import机制" class="headerlink" title="import机制"></a>import机制</h4><p>import机制和package一般配合来使用，将<strong>需要的类导入到当前类</strong>，不在同一个包的时候才导入</p>
<ul>
<li>import：出现在package和第一个class之间，代表导入对象</li>
<li>import java.util.*: 导入java.util包下的所有对象，但是在编译时，Java虚拟机会将 ※转换为在当前类中使用的具体类</li>
<li>java.lang包，java的核心包，自动导入直接类，System、Object、String…不需要导入，直接使用</li>
</ul>
<h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>Java重要的特性是封装，封装需要对成员变量，方法，类和接口进行权限限定，只有满足条件的地方才允许访问，</p>
<p>访问权限控制符分为四种：public, protected, default, private</p>
<h4 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h4><p>public: 接口访问权限，任意位置，都可以使用</p>
<p>protected: 继承访问权限，在子类中可以访问</p>
<p>default: 默认访问权限，在同一个包中才能访问</p>
<p>private: 私有访问权限，只有本类中才能访问</p>
<h4 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h4><table>
<thead>
<tr>
<th>访问权限修饰符</th>
<th>任意位置</th>
<th>子类</th>
<th>同一个包</th>
<th>本类</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>protected</td>
<td></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>default</td>
<td></td>
<td></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>private</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
</tr>
</tbody></table>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><h4 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h4><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回当前类的类名+十六进制哈希值字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h5><p>将当前类对象转为<strong>以文本方式描述</strong>，要求转换完成的字符串，简洁、详实、易阅读，建议所有的对象都重写该方法</p>
<ul>
<li>System.out.println(obj): 该方法内部获取<strong>obj的toString()</strong>，可以不用显式的调用toString方法</li>
<li>String类：内部重写了<strong>toString</strong>方法</li>
</ul>
<h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h4><h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断两个对象是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="设计目的-1"><a href="#设计目的-1" class="headerlink" title="设计目的"></a>设计目的</h5><p>该方法的设计目的是判断两个对象是否相等，一般来说，建议比较<strong>两个引用的内部数据是否相等</strong></p>
<h5 id="和-equals的区别"><a href="#和-equals的区别" class="headerlink" title="== 和 equals的区别"></a>== 和 equals的区别</h5><ol>
<li>== 判断比较的两个变量的地址是否相同；equals 如果没有重写，内部实现就是==</li>
<li>== 使用在判断两个基本数据类型是否相等；equals 判断两个引用是否相等，引用相等根据业务需求由程序员进行判断</li>
</ol>
<p>一般来说，两个基本数据类型比较相等，使用==</p>
<p>​                    两个引用数据类型比较相等，使用equals</p>
<h5 id="String类的equals"><a href="#String类的equals" class="headerlink" title="String类的equals"></a>String类的equals</h5><p>String类由SUN公司编写，内部重写equals方法</p>
<ul>
<li><p>两个String类型的变量比较相等，使用equals方法实际上是比较的内部数据，而不是对象的内存地址</p>
</li>
<li><p>String对象也是引用数据类型，<strong>这也是可以直接使用equals比较字符串相等的原理</strong></p>
</li>
</ul>
<h5 id="重写逻辑"><a href="#重写逻辑" class="headerlink" title="重写逻辑"></a>重写逻辑</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般来说，重写equals方法有共同特点</span></span><br><span class="line"><span class="comment">// 参数是否为空 参数是否为要比较的对象实例 参数和当前对象是否指向同一个内存地址 具体业务要求是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">euqals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 参数是否为空 参数是否为要比较的对象实例</span></span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span> || !(obj <span class="keyword">instanceof</span> ClassName))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 参数和当前对象是否指向同一个内存地址 </span></span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 具体的业务逻辑</span></span><br><span class="line">    CLassName cn = (ClassName)obj;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> 条件表达式;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDEA可以自动生成equals方法，实现重写</p>
<p>在写业务逻辑的时候，需要注意数据类型，如果是基本数据类型，使用==；如果是引用数据类型，使用equals比较是否相等</p>
<h4 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h4><p>返回一个哈希值，相同内存地址的哈希值相同，底层调用C++程序</p>
<h4 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h4><p>在Object类中，只有方法体，没有具体实现，修饰符为protected</p>
<ul>
<li>该方法一般是由垃圾回收器进行调用，释放对象占据的内存空间</li>
<li>finalize是SUN公司提供给程序员的一个特殊时机，<strong>对象销毁时机</strong>，如果想在对象销毁时输出信息，可以在该方法体内部实现</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="含义-3"><a href="#含义-3" class="headerlink" title="含义"></a>含义</h4><p>在一个类的内部定义的另一个类，叫做内部类。类型：</p>
<ul>
<li>静态内部类</li>
<li>实例内部类</li>
<li>局部内部类</li>
</ul>
<p>特点：</p>
<p>​    内部类可以访问外围类的所有属性，包括private修饰的</p>
<h4 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h4><p>不使用static关键修饰的内部类</p>
<ul>
<li>实例内部类包含<strong>对外围类的引用</strong>，创建必须依赖外围类，外围类没有创建，无法创建内部类</li>
<li>在外部类的非静态方法之外的任意位置创建内部类对象，必须显式的指明这个对象的类型：<code>OuterClassName.InnerClassName</code></li>
</ul>
<h4 id="this-new"><a href="#this-new" class="headerlink" title=".this .new"></a>.this .new</h4><ul>
<li>.this: 在内部类中，使用OuterClassName.this表示外围类对象</li>
<li>.new : 使用<strong>外围类实例变量.new InnerClassName()</strong>, 可以创建内部类对象</li>
<li>closure，闭包是一个可调用的对象，记录创建它的作用域。内部类可以访问外围类的状态信息，显然，内部类是一个闭包，可以使用内部类作为回调指针</li>
</ul>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>创建静态内部类（嵌套类）时，不需要创建外部类对象；不能从嵌套类的对象中访问非静态的外围类对象</p>
<ul>
<li>静态内部类又叫做嵌套类，可以包含静态成员变量、静态方法、其他嵌套类</li>
<li>静态内部类<strong>不包含指向外围类的引用</strong></li>
<li>嵌套类可以作为接口中的方法，[接口的定义](# 接口（interface）)</li>
</ul>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>在方法中的内部类叫做局部内部类，匿名内部类是局部内部类的一种，一般来说，匿名内部类只用一次，无法重复使用（匿名内部类可以是接口的实现，没有具体的名称）</p>
<p>匿名内部类特点：</p>
<ul>
<li>没有构造器，但是可以通过实例初始化的方法进行赋值</li>
<li>调用外围类的对象的时候，参数类型需要是final</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li><p>内部类的提出是为了实现<strong>多继承</strong>，内部类的实现与外部类继承或者实现接口无关，可以在外围类继承一个类的同时，内部类在继承另一个类。<strong>内部类可以访问外围类的所有属性</strong>，内部类变相的实现了多继承</p>
</li>
<li><p>在框架上，某些类需要不同的实现，使用内部类可以实现一个接口的多种不同实现方法，在控制框架使用的更多</p>
</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>Java中，数组是一种<strong>引用数据类型</strong>，数组对象存储在<strong>堆内存中</strong>，父类是Object类</li>
<li>数组可以看作一个容器，存储一组数据类型相同的数据，存储数据的类型可以是<strong>基本数据类型</strong>，也可以是<strong>引用数据类型</strong></li>
<li>数组如果存储的是引用数据类型，存储的实际上是<strong>java对象在堆内存的地址</strong>，不是实际创建的对象，在堆内存占据的空间是一样的（4个字节，int）</li>
<li>在Java中，<strong>数组一旦创建，长度不可改变</strong></li>
<li>所有的数组对象都存在length属性，Java自带的固有属性</li>
<li>数组中的元素类型都是一样的，int数组只能存储int类型数据，Person数组只能存储Person类型数据</li>
<li>数组的元素在堆内存中，内存地址连续</li>
</ul>
<h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><p><strong>优点</strong>：</p>
<p>根据下标查询/索引元素的时候效率高，和数组的原理有关：</p>
<ul>
<li>数组元素占据的内存空间是一样的，根据类型可以得出每个元素占据的内存空间的大小</li>
<li>数组在内存空间连续</li>
<li>数组首元素地址就是整个数组在堆内存中的地址</li>
<li>如果知道元素下标，就可以根据数学公式得到数据偏移量，下标为2和下标为20000效率一样</li>
</ul>
<p><strong>缺点</strong>：</p>
<p>由于数据在数组中顺序存储，在随机删除/增加元素的时候效率较低</p>
<p>数组不能存储大容量数据，在内存方面很难找到合适的连续内存空间，来存储数据</p>
<ul>
<li>如果增加元素，需要将该位置之后的元素向后移动位置；删除元素，需要将删除位置之后的数据依次向前移动</li>
<li>如果增删最后一个元素，数组的效率不受影响</li>
</ul>
<h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一维数组定义</span></span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">Person[] p = &#123;<span class="keyword">new</span> Person(),<span class="keyword">new</span> Person()&#125;;</span><br><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">int</span>[] 数组类型，整体是引用数据类型</span><br></pre></td></tr></table></figure>

<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>如果只创建数组对象，没有显式的赋值，系统会赋默认初值</p>
<h6 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h6><p>在创建数组的时候就给数组赋初值，适用于知道数组存储的数据元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h6><p>先定义数组类型和空间大小，针对每个元素赋初值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person[] p = <span class="keyword">new</span> Person[<span class="number">3</span>];</span><br><span class="line">p[<span class="number">0</span>] = <span class="keyword">new</span> Person();</span><br><span class="line">p[<span class="number">1</span>] = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>可以使用循环进行数组遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length;i ++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h5><p>数组一旦创建，数组长度不能改变，length属性无法改变</p>
<p>数组扩容就是创建一个大数组，再将原数组拷贝到新数组中</p>
<h5 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h5><p>数组元素复制一份到新的数组中，System.arraycopy()方法可以进行数组拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] oldArr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">System.arraycopy(oldArr, <span class="number">0</span>, newArr, <span class="number">0</span>, oldArr.length);</span><br><span class="line"><span class="comment">// 具体的参数列表含义可以自己查询</span></span><br></pre></td></tr></table></figure>

<h5 id="String-args参数"><a href="#String-args参数" class="headerlink" title="String[] args参数"></a>String[] args参数</h5><p>主方法中的String[]参数列表，可以由用户传入，系统进行调用</p>
<p>可以在命令行状态下，由用户输入<strong>以空格分隔的字符串</strong>，可以在Dos下进行数据校验</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Dos命令行下</span></span><br><span class="line">java Test01 zxl <span class="number">1234</span></span><br><span class="line"><span class="comment">// java会自动将 zxl 1234以空格分隔，传入args数组</span></span><br><span class="line">args[<span class="number">0</span>] = <span class="string">"zxl"</span>;</span><br><span class="line">args[<span class="number">1</span>] = <span class="string">"1234"</span>;</span><br></pre></td></tr></table></figure>

<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>二维数组是一个特殊的一维数组，特殊在，每个一维数组的元素又是一个一维数组</p>
<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 每个元素的长度可以不一致</span></span><br></pre></td></tr></table></figure>

<h5 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h5><p>可以先遍历每个元素，每个元素就是一个一维数组，然后遍历每个一维数组的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历每个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr[i].length;j++)&#123;</span><br><span class="line">        System.out.println(arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h2><h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><ul>
<li>String类是java JDK内置的类，全名java.lang.String</li>
<li>String类是<strong>引用数据类型</strong>，不是基本数据类型</li>
<li>在java中，只要使用<strong>双引号</strong>括起来的，都是字符串对象，“111”，“2”， 都是字符串对象</li>
<li>Java中，String对象，一旦创建，不可更改（String底层使用 private final char[] value存储数据）,看起来的修改，实际上都是创建了一个新的字符串对象，在常量池中的对象不可更改</li>
<li>字符串对象，在java中，存储在<strong>方法区的常量池中</strong>，字符串对象使用频繁，在常量池中可以提高执行效率</li>
</ul>
<h5 id="String对象存储原理"><a href="#String对象存储原理" class="headerlink" title="String对象存储原理"></a>String对象存储原理</h5><p>在以下java代码中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">"zx"</span>;</span><br><span class="line">    String s2 = <span class="string">"zx"</span> + <span class="string">"123"</span>;</span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在Java中，只要是双引号内部的对象，都是字符串对象，存储在<strong>方法区的常量池</strong>，有多少个双引号包裹的对象，需要创建多少个常量池对象</li>
<li>使用<strong>+</strong>号连接的字符串，原本的字符串对象不会被释放（垃圾回收器只会回收new创建的对象）,会在常量池中开辟新的内存存放数据</li>
<li>所以不推荐大量使用<strong>+</strong>号连接字符串，因为它们会大量的占用方法区的常量池</li>
</ul>
<p>具体的内存结构图：</p>
<p><img src="/2020/12/07/Java-SE/string-mem.png" alt="string对象的内存图"></p>
<h5 id="“-”和new-String-“”"><a href="#“-”和new-String-“”" class="headerlink" title="“ ”和new String(“”)"></a>“ ”和new String(“”)</h5><ul>
<li>“”是创建字符串对象最常用的方式，只要是使用双引号包裹起来的，都指向字符串对象，可以调用字符串String类的方法，<strong>对象在方法区的常量池中</strong></li>
<li>如果两个引用指向同一个字符串对象，可以使用==判断是否为同一个对象，例如</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"zx"</span>;</span><br><span class="line">String s2 = <span class="string">'zx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// == 判断两个变量的内存地址，指向“zx”对象的常量池地址</span></span><br><span class="line">System.out.println(s1 == s2);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>new String(“zxl”)：创建的对象在堆内存中，堆内存包含指向“zxl”对象的引用，而不是直接包含”zxl“字符串</li>
<li>new String(): 两个对象，必须使用equals方法来判断内容是否相同，==无法判断引用是否相同</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"zxl"</span>);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"zxl"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false,堆内存地址不同，比较的不是数据</span></span><br><span class="line"><span class="comment">// String类重写equals方法</span></span><br><span class="line">System.out.println(S3.equals(s4)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="String类的构造方法"><a href="#String类的构造方法" class="headerlink" title="String类的构造方法"></a>String类的构造方法</h5><p>常用的构造方法，具体的构造方法可以查阅JDK API帮助文档</p>
<ol>
<li>”“创建字符串对象，<strong>最常用的创建字符串对象的方式</strong></li>
<li>new String(“zxl”)创建对象</li>
<li>new String(byte[] bytes)创建对象</li>
<li>new String(char[] chars)创建对象</li>
</ol>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><p>​    字符串的方法包括，查找指定位置的字符，比较两个子符串的大小，将指定数据类型的数据转换为字符串对象。。。</p>
<h5 id="System-out-print-方法"><a href="#System-out-print-方法" class="headerlink" title="System.out.print()方法"></a>System.out.print()方法</h5><p>在底层源码中，所有的打印方法都调用了String.valueOf()方法，在String.valueOf()内部调用当前对象的toString()方法（输出的对象需要重写toString方法），所有的打印数据都转化为字符串形式打印在屏幕上</p>
<p><img src="/2020/12/07/Java-SE/print.png" alt="System.out.println(Object obj)原理"></p>
<h4 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h4><p>String类由于底层实现原理，一旦创建，不可改变（private final char[] value）</p>
<p>StringBuffer类可以改变字符串，在大量的字符串连接的时候，可以使用StringBuffer类，使用append()方法，可以尾部追加其他对象，在数组容量不够的时候，可以自动进行数组扩容，用户不需要考虑容量问题</p>
<p>提高StringBuffer类的效率，可以估算需要的容量，安排合适的初始化容量，减少数组扩容次数</p>
<h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><p>StringBulider类可以实现和StringBuffer类相同的功能，但是StringBuffer类方法使用synchronized修饰，线程安全；StringBuilder类的执行速度更快一些</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>对应的包装类型</th>
<th>直接父类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>java.lang.Byte</td>
<td>java.lang.Number</td>
</tr>
<tr>
<td>short</td>
<td>java.lang.Short</td>
<td>java.lang.Number</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer</td>
<td>java.lang.Number</td>
</tr>
<tr>
<td>long</td>
<td>java.lang.Long</td>
<td>java.lang.Number</td>
</tr>
<tr>
<td>float</td>
<td>java.lang.Float</td>
<td>java.lang.Number</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double</td>
<td>java.lang.Number</td>
</tr>
<tr>
<td>boolean</td>
<td>java.lang.Boolean</td>
<td>java.lang.Object</td>
</tr>
<tr>
<td>char</td>
<td>java.lang.Charcater</td>
<td>java.lang.Object</td>
</tr>
</tbody></table>
<h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><ul>
<li>装箱：将<strong>基本数据类型转换为对应的引用数据类型</strong>的行为，叫装箱</li>
<li>拆箱：将<strong>引用数据类型转换为对应的基本数据类型</strong>的行为，叫拆箱</li>
</ul>
<p>自从JDK 1.5之后，提供自动装箱和拆箱机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用数据类型</span></span><br><span class="line">	Integer x = <span class="number">100</span>;</span><br><span class="line">	IntegerTest01.doSome(x);</span><br><span class="line">    <span class="comment">// 引用数据类型转换为基本数据类型，自动拆箱</span></span><br><span class="line">	<span class="keyword">int</span> z = x;</span><br><span class="line">    <span class="comment">// z -&gt; Object 自动装箱</span></span><br><span class="line">	System.out.println(z);</span><br><span class="line">	<span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">	IntegerTest01.doSome(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Integer包装类"><a href="#Integer包装类" class="headerlink" title="Integer包装类"></a>Integer包装类</h4><p>整型常量池：</p>
<p>在Integer类中，由于-128 - 127比较常用，为了程序的执行效率，JVM在类加载的时候，以将创建了对象，放置在<strong>方法区的整型常量池</strong>中，在比较数据相等的时候，可以使用“==”，此时指向的内存地址相同</p>
<h5 id="NumberFormatException异常"><a href="#NumberFormatException异常" class="headerlink" title="NumberFormatException异常"></a>NumberFormatException异常</h5><p>在将一个字符串转换为整数的时候，如果包含不能转的字符，会产生该异常数字格式异常</p>
<h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Date类，表示日期</span></span><br><span class="line"><span class="comment">// java.util.Date;</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">// 系统当前时间</span></span><br><span class="line"></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="keyword">long</span> fastTime);</span><br><span class="line"><span class="comment">// 指定一个毫秒值，从1970.1.1.0 到现在的毫秒数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Date类有两种创建形式，调用无参构造函数，在内部会调用this(System.currentTimeMillis());</li>
<li>System.currentTimeMills()获取当前时间到0时的毫秒数</li>
</ul>
<h4 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h4><p>简单的日期格式化类，可以将日期对象转换为指定格式的字符串，也可以将字符串转换为日期对象</p>
<p><strong>java.text.SimpleDateFormat</strong>默认的符号含义</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>当前年份，可以使用yyyy yy</td>
</tr>
<tr>
<td>M</td>
<td>当前月份，MM</td>
</tr>
<tr>
<td>d</td>
<td>当前天，dd</td>
</tr>
<tr>
<td>H</td>
<td>24小时制，HH</td>
</tr>
<tr>
<td>m</td>
<td>分钟，mm</td>
</tr>
<tr>
<td>s</td>
<td>秒，ss</td>
</tr>
<tr>
<td>S</td>
<td>毫秒，SSS</td>
</tr>
</tbody></table>
<ol>
<li>date -&gt; text</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">// patten 日期的格式</span></span><br><span class="line">String patten = <span class="string">"yyyy-MM-dd HH:mm:ss SSS"</span>;</span><br><span class="line">java.text.SimpleDateFormat sdf = <span class="keyword">new</span> java.text.SimpleDateFormat(patten);</span><br><span class="line"></span><br><span class="line">String text = sdf.format(date);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>text -&gt; date</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String date = <span class="string">"2008/12/08 12/12/12 122"</span>;</span><br><span class="line">java.text.SimpleDateFormat sdf = <span class="keyword">new</span> java.text.SimpleDateFormat(<span class="string">"yyyy/MM/dd HH/mm/ss SSS"</span>);</span><br><span class="line"></span><br><span class="line">Date d = sdf.parse(date);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：</li>
<li>此时，构造方法中的参数，模式需要和要转换的字符串的模式相同，否则会有解析异常</li>
</ul>
<h3 id="数字类"><a href="#数字类" class="headerlink" title="数字类"></a>数字类</h3><h4 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h4><p>在处理银行等财务数据的时候，不能使用double等类型的数据，需要使用专用数据类型</p>
<ul>
<li>BigDecimal是引用数据类型,位于java.math包下</li>
<li>数据精确，可以表示一个任意大小且精度完全准确的浮点数</li>
<li>对数据计算不能使用传统的符号，引用数据类型，可以使用专用的方法</li>
</ul>
<h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><p>产生随机数，如果没有指定seed，默认将当前系统时间作为种子，产生随机数，也可以自己指定种子，会产生相同的随机数序列</p>
<h3 id="enum类型"><a href="#enum类型" class="headerlink" title="enum类型"></a>enum类型</h3><p>枚举数据类型，如果程序运行结果超过两种，但是结果又可以列举出来，可以使用枚举数据类型作为返回值，这样可以保证返回数据的规范性</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常是什么？"><a href="#异常是什么？" class="headerlink" title="异常是什么？"></a>异常是什么？</h3><p>异常，就是程序正常运行过程中出现的问题，导致程序不能正常执行下去的原因</p>
<h3 id="Java异常机制的作用？"><a href="#Java异常机制的作用？" class="headerlink" title="Java异常机制的作用？"></a>Java异常机制的作用？</h3><p>程序员可以在程序中处理异常，保证程序可以正常的运行下去，不会因为外部情况导致程序退出，程序的健壮性得到保证</p>
<h3 id="异常的继承结构"><a href="#异常的继承结构" class="headerlink" title="异常的继承结构"></a>异常的继承结构</h3><ul>
<li>所有的异常的父类都是<strong>Throwable</strong>类</li>
<li>Throwable类有两个子类，<strong>Error</strong>和<strong>Exception</strong>，Error类表示程序员不能处理的错误，一旦遇到，退出java虚拟机；Exception类表示异常，程序员可以进行处理</li>
<li>Error类的子类：IOError，VirtualMachineError</li>
<li>Exception类，可以分为两类，<strong>RuntimeException</strong>和<strong>直接子类</strong></li>
<li>直接子类，在程序中必须进行处理；RuntimeException，运行时异常，可以不用进行处理</li>
</ul>
<h3 id="编译时异常-运行时异常"><a href="#编译时异常-运行时异常" class="headerlink" title="编译时异常 运行时异常"></a>编译时异常 运行时异常</h3><ol>
<li><p>编译时异常</p>
<ul>
<li>凡是Exception类子类（不包括RuntimeException及其子类），都是编译时异常</li>
<li>编译时异常，在编程中大概率出现，系统强制要求程序员进行处理</li>
<li>编译时异常不是在编译期发现的异常，而是在程序运行的时候，new异常类对象，存储在堆内存中，由垃圾回收器进行回收</li>
<li>IOException，SQLException</li>
</ul>
</li>
<li><p>运行时异常</p>
<ul>
<li>凡是RuntimeException类及其子类，都是运行时异常</li>
<li>运行时异常，在编程中小概率出现，可以进行处理，也可以不进行处理</li>
</ul>
</li>
<li><p>发生时机</p>
<p>在程序运行的时候发生，创建异常类对象</p>
</li>
</ol>
<h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><p>Java对于异常的处理有两种方式，将异常进行上抛，谁调用该方法，上抛给谁；自己尝试进行处理</p>
<h4 id="上抛（throws）"><a href="#上抛（throws）" class="headerlink" title="上抛（throws）"></a>上抛（throws）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"这是一个异常"</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将方法中出现的异常进行上抛，将该异常会上抛给调用方法，如果一直没有进行处理，会传递给main方法</li>
<li>如果希望调用者知道异常发生的具体情况，可以对异常进行上抛</li>
</ul>
<h4 id="捕捉（try-catch）"><a href="#捕捉（try-catch）" class="headerlink" title="捕捉（try .. catch）"></a>捕捉（try .. catch）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    test(-<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>java使用的机制<strong>终止机制</strong>，一旦发生异常，程序会进入异常捕获部分，不会再去执行异常之后的语句</li>
<li>catch块，可以包含多个异常捕获块，但是异常范围必须从小到大，异常的匹配是从上到下匹配，一旦发现匹配的异常处理块，不会再继续匹配下去，如果大范围的异常在上面，小范围的异常永远不会有执行的机会</li>
</ul>
<h4 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h4><ul>
<li>如果在能力范围之内，可以进行捕获；需要让调用者知道出现的情况，使用上抛</li>
<li>对于编译时异常，程序员必须显式的对异常进行处理</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li><p>getMessage()</p>
<p>获取异常信息</p>
</li>
<li><p>printStackTrace()</p>
<p>打印栈踪迹，可以将异常出现的情况打印在屏幕上，在进行异常处理的时候，推荐使用printStackTrace,</p>
<p>使用IDE工具，生成的try.catch块，默认使用printStcakTrace</p>
</li>
</ol>
<h3 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h3><ul>
<li>try..catch块后面的语句，<strong>在finally语句块内部的代码，一定会执行</strong></li>
<li>try后面可以直接跟着finally语句，但是try不能单独使用</li>
<li>fianlly语句一般进行资源的释放，防止在出现异常的时候占用的系统资源没有被释放</li>
<li><strong>即使try语句或者catch语句中包含return语句，finally语句也会执行</strong></li>
<li><strong>只有System.exit(0)才能不会finally语句</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><p>自定义类需要继承含义相近的异常类，如果没有，可以选择继承Exception</p>
<ul>
<li>继承异常类</li>
<li>类包含两个构造方法，无参构造，有一个字符串参数的构造</li>
<li>在异常出现的时候，上抛异常<code>throw new MyException(&quot;自定义异常&quot;)；</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getException</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> MyException</span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span>(i == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"自定义异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> ExceptionTest04().getException(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><h4 id="finally语句的执行顺序问题"><a href="#finally语句的执行顺序问题" class="headerlink" title="finally语句的执行顺序问题"></a>finally语句的执行顺序问题</h4><p>java的核心原则：</p>
<ul>
<li>在方法中的代码从上到下依次执行</li>
<li>return语句最后执行（return之后的代码不会执行）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 第一题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(test());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .class文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">byte</span> i = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">byte</span> var1;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       var1 = i;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">int</span> i = i + <span class="number">1</span>;</span><br><span class="line">       System.out.println(<span class="string">"i"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码的执行顺序，try块只有一个return语句，但是检测到finally语句，会先将变量复制一份，继续执行finally中的语句，执行结束之后如果没有return语句或者System.exit(0)，会继续执行return语句，此时返回的还是保存的变量，return语句在前，虽然执行了finally语句，但是不影响最后结果</li>
</ul>
<h4 id="final、finally、finalize"><a href="#final、finally、finalize" class="headerlink" title="final、finally、finalize"></a>final、finally、finalize</h4><ol>
<li>final：java关键字，可以修饰类，方法，变量<ul>
<li>修饰类：不能被继承</li>
<li>修饰方法：不能被重写</li>
<li>修饰变量：不能重复赋值</li>
</ul>
</li>
<li>finally: java关键字，在try之后<ul>
<li>finally语句一定执行，在执行try语句的时候，除非有System.exit(0)，不会退出执行</li>
</ul>
</li>
<li>finalize: java标识符<ul>
<li>finalize()方法，Object类的一个方法，finalize作为方法名，java标识符</li>
<li>finalize()，在对象销毁的时候被调用，销毁对象由JVM的GC负责，程序员不知道何时销毁对象</li>
</ul>
</li>
</ol>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>1、反射机制的作用？</p>
<ul>
<li>可以通过反射机制获取类的字节码对象</li>
<li>让对象实例的创建更加灵活</li>
<li>只执行静态代码块中的代码，获取类的字节码文件会将字节码文件装载到方法区，此时静态代码块执行</li>
</ul>
<p>2、常用的反射类</p>
<ul>
<li><p>java.lang.Class</p>
<p>字节码对象类</p>
</li>
<li><p>java.lang.reflect.Constructor</p>
<p>反射的字节码文件的构造器</p>
</li>
<li><p>java.lang.reflect.Metod</p>
</li>
<li><p>java.lang.reflect.Field</p>
</li>
</ul>
<h3 id="获取字节码对象的三种方式"><a href="#获取字节码对象的三种方式" class="headerlink" title="获取字节码对象的三种方式"></a>获取字节码对象的三种方式</h3><h4 id="通过Class-forName-获取"><a href="#通过Class-forName-获取" class="headerlink" title="通过Class.forName()获取"></a>通过Class.forName()获取</h4><p>Class类可以通过forName方法获取在类的字节码文件 </p>
<p>forName中的参数：类的全限定类名</p>
<p><strong>因为字节码文件只加载一次，所有同一个类型的对象的字节码实例内存地址相同</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="通过-getClass-获取"><a href="#通过-getClass-获取" class="headerlink" title="通过.getClass()获取"></a>通过.getClass()获取</h4><p>Object对象有getClass方法，返回一个实例的字节码对象，需要首先创建对象实例，然后调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line">Class&lt;? extends String&gt; strClass = str.getClass();</span><br><span class="line">System.out.println(strClass);</span><br></pre></td></tr></table></figure>

<h4 id="通过-class属性获取"><a href="#通过-class属性获取" class="headerlink" title="通过.class属性获取"></a>通过.class属性获取</h4><p>所用的java对象都有.class属性，可以通过该属性直接获取字节码对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Integer&gt; integerClass = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Class&lt;ReflectTest01&gt; reflectTest01Class = ReflectTest01<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="通过字节码文件创建实例对象"><a href="#通过字节码文件创建实例对象" class="headerlink" title="通过字节码文件创建实例对象"></a>通过字节码文件创建实例对象</h3><ul>
<li>可以通过字节码文件的newInstance方法创建实例对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">"reflection.User"</span>);</span><br><span class="line"></span><br><span class="line">Object instance = aClass.newInstance();</span><br><span class="line"></span><br><span class="line">System.out.println(instance);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/07/Java-SE/ref.png" alt></p>
<ul>
<li>newInstance()实际上调用了无参构造函数，如果没有无参构造函数，会产生实例化异常</li>
</ul>
<h4 id="通过属性配置文件灵活实例化对象"><a href="#通过属性配置文件灵活实例化对象" class="headerlink" title="通过属性配置文件灵活实例化对象"></a>通过属性配置文件灵活实例化对象</h4><p>Properties对象，可以从文件中读取数据，使用newInstance就可以实例化对象</p>
<h3 id="通用路径获取"><a href="#通用路径获取" class="headerlink" title="通用路径获取"></a>通用路径获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String path = Thread.currentThread().</span><br><span class="line">    getContextClassLoader().getResource(String name).getPath();</span><br><span class="line"><span class="comment">// Thread.currentThread 获取当前线程对象</span></span><br><span class="line"><span class="comment">// getContextClassLoader 获取类加载器</span></span><br><span class="line"><span class="comment">// getResource 获取资源URL</span></span><br><span class="line"><span class="comment">// getPath 获取URL的路径</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取的文件路径必须要位于类路径下，src目录下</li>
</ul>
<h4 id="资源绑定器-ResourceBundle"><a href="#资源绑定器-ResourceBundle" class="headerlink" title="资源绑定器 ResourceBundle"></a>资源绑定器 ResourceBundle</h4><p>java.util.ResourceBundle</p>
<ul>
<li>只能读取属性配置文件，后缀名为<strong>.properties</strong></li>
<li>文件位于类路径下，src目录下</li>
<li>文件不需要带后缀</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResourceBundle bundle = ResourceBundle.getBundle(<span class="string">"config"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过key来获取value</span></span><br><span class="line">String value = bundle.getString(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure>

<h3 id="类加载器-ClassLoader"><a href="#类加载器-ClassLoader" class="headerlink" title="类加载器 ClassLoader"></a>类加载器 ClassLoader</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>ClassLoader加载类的字节码文件，专门负责加载类的命令</p>
<h4 id="三个类加载器"><a href="#三个类加载器" class="headerlink" title="三个类加载器"></a>三个类加载器</h4><ul>
<li>启动类加载器：rt.jar，专门加载源码的核心类库</li>
<li>扩展类加载器：ext/*.jar，专门加载源码的扩展类库</li>
<li>应用类加载器：calsspath下的文件，加载classpath下的类</li>
</ul>
<h4 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h4><p>String str = “abc”;</p>
<ol>
<li>首先通过类加载器加载，加载源码的rt.jar包下的类，最核心的类库</li>
<li>如果启动类加载器没有加载到，会通过扩展类加载器加载</li>
<li>如果扩展类加载器没有加载到，会通过应用类加载器加载，直到找到为止</li>
</ol>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>java类的加载顺序有先后，加载的源码也有先后，如果在启动类加载器中找到，就不会在扩展来加载器中找，在扩展类加载器找到，就不会在应用类加载器中找</p>
<p>用户自定义的类不会再系统的核心类库之前加载，保证加载的核心类库的安全，这种机制，叫做双亲委派机制，启动类加载器：父加载器，扩展类加载器：母加载器</p>
<h3 id="通过反射获取对象的属性"><a href="#通过反射获取对象的属性" class="headerlink" title="通过反射获取对象的属性"></a>通过反射获取对象的属性</h3><p>可以通过java.lang.reflect.Field获取字节码对象的属性相关的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取对象的字节码文件</span></span><br><span class="line">Class class1 = Class.forName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对象的属性列表</span></span><br><span class="line">class1.getFielsd();</span><br><span class="line">class1.getDeclaredFields()</span><br><span class="line">class1.getDeclaredField(String name) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性的相关内容</span></span><br><span class="line">field.getName()</span><br><span class="line">field.getSimpleName()</span><br><span class="line">field.getType()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性的修饰符列表 修饰符可能不只一个</span></span><br><span class="line">field.getModifiers()  <span class="comment">// 获取int值，通过Modifier.toString(int)来获取修饰符列表</span></span><br><span class="line">Modifier.toString(field.getModifiers());</span><br></pre></td></tr></table></figure>

<h4 id="获取-修改属性的值"><a href="#获取-修改属性的值" class="headerlink" title="获取/修改属性的值"></a>获取/修改属性的值</h4><p>修改对象的属性，有三个条件：</p>
<ul>
<li>对象名</li>
<li>属性名 ：可以通过属性名称来区分不同的属性</li>
<li>参数</li>
</ul>
<p>获取对象的属性，两个条件：</p>
<ul>
<li>对象名</li>
<li>属性名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取字节码对象</span></span><br><span class="line">Class studentClass = Class.forName(<span class="string">"reflection.Student"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例对象</span></span><br><span class="line">Object o = studentClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定的属性，属性名称可以区分属性</span></span><br><span class="line">Field nameField = studentClass.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">// 属性赋值</span></span><br><span class="line">nameField.set(o,<span class="string">"zxl"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(nameField.get(o));</span><br></pre></td></tr></table></figure>

<ul>
<li>如果访问私有属性，必须设置该属性是可以访问的，.setAccessible(true);<ul>
<li>使用反射可能会打破java的封装</li>
</ul>
</li>
</ul>
<h3 id="通过反射获取对象的方法"><a href="#通过反射获取对象的方法" class="headerlink" title="通过反射获取对象的方法"></a>通过反射获取对象的方法</h3><p>可以通过java.lang.reflect.Method获取字节码对象的属性相关的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取字节码对象所有的方法</span></span><br><span class="line">getDeclaredMethods();	</span><br><span class="line"><span class="comment">// 获取修饰符列表</span></span><br><span class="line">Modifier.toString(getModfiers())</span><br><span class="line"><span class="comment">// 获取返回值类型</span></span><br><span class="line">getReturnType()</span><br><span class="line"><span class="comment">// 获取方法名</span></span><br><span class="line">getName()</span><br><span class="line"><span class="comment">// 获取参数列表</span></span><br><span class="line">getParameters()</span><br></pre></td></tr></table></figure>

<h4 id="通过反射调用方法"><a href="#通过反射调用方法" class="headerlink" title="通过反射调用方法"></a>通过反射调用方法</h4><p>通过<strong>invoke</strong>进行方法调用</p>
<p>方法调用，四个条件：</p>
<ul>
<li>对象</li>
<li>方法名  </li>
<li>参数列表 必须通过方法名，参数列表来区分不同的方法</li>
<li>返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取字节码对象</span></span><br><span class="line">Class studentClass = Class.forName(<span class="string">"reflection.Student"</span>);</span><br><span class="line"><span class="comment">// 创建实例对象</span></span><br><span class="line">Object o = studentClass.newInstance();</span><br><span class="line"><span class="comment">// 根据方法名获取方法</span></span><br><span class="line">Method nameMethod = studentClass.getDeclaredMethod(<span class="string">"getName"</span>);</span><br><span class="line"></span><br><span class="line">Object invoke = nameMethod.invoke(o);</span><br><span class="line">System.out.println(invoke);</span><br></pre></td></tr></table></figure>

<h3 id="通过反射获取对象的构造器"><a href="#通过反射获取对象的构造器" class="headerlink" title="通过反射获取对象的构造器"></a>通过反射获取对象的构造器</h3><p>可以通过java.lang.reflect.Constructor获取字节码对象的属性相关的内容</p>
<p>构造函数的方法名称相同，参数列表可以区分不同的构造函数</p>
<h4 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a>通过反射创建对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取字节码对象</span></span><br><span class="line">Class studentClass = Class.forName(<span class="string">"reflection.Student"</span>);</span><br><span class="line"><span class="comment">// 创建实例对象,使用无参构造函数实例化对象</span></span><br><span class="line">Object o = studentClass.newInstance();</span><br><span class="line"></span><br><span class="line">Constructor constructor = studentClass.getDeclaredConstructor();</span><br><span class="line">Constructor constructor1 = studentClass.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用无参，也可以使用有参</span></span><br><span class="line">constructor.newInstance();</span><br><span class="line">constructor1.newInstance(<span class="string">"zxl"</span>,<span class="number">11</span>);</span><br></pre></td></tr></table></figure>

<h3 id="通过反射获取父类，实现的接口"><a href="#通过反射获取父类，实现的接口" class="headerlink" title="通过反射获取父类，实现的接口"></a>通过反射获取父类，实现的接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Class <span class="title">getSuperClass</span><span class="params">()</span></span>;</span><br><span class="line">Class[] getInterfaces();</span><br></pre></td></tr></table></figure>

<h2 id="注解-annotation"><a href="#注解-annotation" class="headerlink" title="注解 annotation"></a>注解 annotation</h2><h3 id="含义-4"><a href="#含义-4" class="headerlink" title="含义"></a>含义</h3><p>注解，又叫做注释Annotation，是一种引用数据类型，编译之后生成字节码文件</p>
<p>注解可以出现在类中的任意位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注解的通用定义</span></span><br><span class="line">[修饰符列表] <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    属性值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    String name <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h3><ul>
<li><p>@Override</p>
<ul>
<li>编译期注解，在编译阶段检测被该注解修饰的方法是否为重写方法</li>
<li>该注解作用在方法上，保留再源代码中，一旦编译之后，字节码文件中不会出现这个注解</li>
</ul>
</li>
<li><p>@Deprecated</p>
<ul>
<li><p>运行时注解，可以通过反射机制来判断当前对象上是否包含该注解</p>
</li>
<li><pre><code class="java"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="meta">@Target</span>(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
&lt;!--￼<span class="number">49</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="属性允许的类型"><a href="#属性允许的类型" class="headerlink" title="属性允许的类型"></a>属性允许的类型</h4><p>boolean byte short char int float long  double String Class 枚举</p>
<p>以及上述的数组形式</p>
<h4 id="特殊的属性值"><a href="#特殊的属性值" class="headerlink" title="特殊的属性值"></a>特殊的属性值</h4><ol>
<li>如果属性值的名称是<strong>value</strong>,而且只有一个属性，在调用的时候可以不用写value=</li>
<li>如果属性值的类型为数组，只有一个元素的时候，可以直接 <strong>属性名 = 属性值</strong></li>
</ol>
<h4 id="使用带有属性的注解"><a href="#使用带有属性的注解" class="headerlink" title="使用带有属性的注解"></a>使用带有属性的注解</h4><p>需要<strong>属性名=属性值</strong>，上述的情况除外</p>
<h3 id="通过反射获取注解"><a href="#通过反射获取注解" class="headerlink" title="通过反射获取注解"></a>通过反射获取注解</h3><p>如果是类上的注解，直接获取字节码文件；方法上的注解，需要先通过反射获取方法；属性上的注解先通过反射获取属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否存在该类型的注解</span></span><br><span class="line">isAnnotationPresent(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">// 获取注解</span></span><br><span class="line"><span class="class"><span class="title">getAnnotation</span>(<span class="title">MyAnnotation</span>.<span class="title">class</span>)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java—SE</tag>
      </tags>
  </entry>
  <entry>
    <title>变量初始化</title>
    <url>/2020/12/05/Initialization/</url>
    <content><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>在创建类对象、调用静态成员变量的时候，会对静态成员变量进行加载和初始化，对于非静态成员变量，或者说“实例变量”，会在创建对象的时候，分配内存空间，完成初始化。</p>
<p>一般来说，类成员变量的加载顺序由上到下，依次加载</p>
<ul>
<li>如果类对象中包含父类、静态成员变量、静态代码块、实例成员变量、实例代码块和构造函数等多种成分的时候：</li>
<li><code>静态成员变量、静态代码块 &gt; 实例成员变量、实例代码块 &gt; 构造函数</code>，如果有父类，先执行父类的代码</li>
<li>如果每种类型的成员变量有多个，则按照定义顺序，从上到下依次执行</li>
<li>静态代码块和静态变量都在类加载时进行初始化，只能依靠定义顺序来保证初始化顺序</li>
<li>实例代码块和实例变量在创建对象时初始化，在构造方法执行之前执行，同时有多个实例变量，根据定义顺序执行</li>
</ul>
<h2 id="代码执行顺序"><a href="#代码执行顺序" class="headerlink" title="代码执行顺序"></a>代码执行顺序</h2><h3 id="父类成员变量"><a href="#父类成员变量" class="headerlink" title="父类成员变量"></a>父类成员变量</h3><p>​    如果当前类对象继承了某个基类，在进行初始化的时候，会先初始化基类，静态成员、非静态成员变量，然后是子类的静态成员变量、非静态成员变量。</p>
<p>​    如果使用构造函数创建类对象，会首先调用基类的构造函数，然后在调用子类的构造函数，完成类对象的创建工作。</p>
<h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p>​    静态成员变量，只占据一块存储区域，无论创建多少个对象。如果一个变量是静态变量{基本类型}，而且没有进行初始化，会获得默认初值，如果是一个对象引用，那么初始化为null。</p>
<p><strong>静态成员变量在首次加载class字节码文件时或首次访问该变量的时候</strong>，进行加载和初始化，有且只有一次。</p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>将多个静态代码块组合在一起，形成的子句叫做静态子句，或者叫做静态块</p>
<p>静态块和静态变量一样，仅执行一次，<strong>在首次生成类对象或者首次访问类的静态变量的时候</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例成员变量"><a href="#实例成员变量" class="headerlink" title="实例成员变量"></a>实例成员变量</h3><p>没有使用static修饰符修饰的成员变量，在构造方法执行时进行初始化，可以默认隐藏在构造方法第一行，首先执行</p>
<h3 id="实例代码块"><a href="#实例代码块" class="headerlink" title="实例代码块"></a>实例代码块</h3><p>和非静态成员变量一样，每次创建不同的类对象的时候都会进行一次初始化，<strong>在main方法之后执行，在构造方法执行之前执行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">&#123;</span><br><span class="line">	i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>构造方法最后执行,在父类构造方法执行之后执行子类的构造方法 </li>
<li>构造方法的第一行默认执行<strong>实例变量初始化,实例代码块的执行</strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>由于不同类型的成员变量的初始化顺序不同，可能后面初始化的成员变量会将前面初始化的成员变量的值覆盖</li>
<li>如果继承了父类，则会首先初始化父类，在初始化子类</li>
<li>静态类型初始化，在首次生成类对象的时候，或者在首次调用静态成员变量的时候进行初始化，只有一次</li>
<li>实例类型，只有使用new关键字进行类对象生成的时候，使用构造方法创建对象时，才会进行初始化。<strong>实例变量和实例代码块总是在构造方法执行完毕前执行，可以把实例变量和实例代码块默认在构造方法第一行执行，只有实例变量和实例代码块执行结束之后，才继续执行构造方法内部代码</strong></li>
</ul>
<h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组是引用数据类型，分配空间和进行初始化不是一回事</p>
<h3 id="在定义的同时进行初始化"><a href="#在定义的同时进行初始化" class="headerlink" title="在定义的同时进行初始化"></a>在定义的同时进行初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">Integer[] arr2 = &#123;</span><br><span class="line">	<span class="keyword">new</span> Integer(<span class="number">1</span>),</span><br><span class="line">	<span class="keyword">new</span> Integer(<span class="number">2</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单独进行初始化"><a href="#单独进行初始化" class="headerlink" title="单独进行初始化"></a>单独进行初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">	arr[i] = i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><p>Java提供可变参数，适用于参数类型和个数未知的场合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object... args)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(Object obj:args)</span><br><span class="line">		System.out.Println(obj);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
      </tags>
  </entry>
  <entry>
    <title>collection</title>
    <url>/2020/10/14/collection/</url>
    <content><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>collection：集合，存储数据的容器，在没有指定“泛型”的时候，可以存储<strong>任意数据类型</strong></p>
<p>任意数据类型：指的是任意Object的子类对象引用（如果是基本数据类型，触发自动装箱，存储的还是对象引用）</p>
<p>特点：</p>
<ul>
<li>集合中存储的数据都是java对象的地址，不能存储基本数据类型数据，也不能直接存储java对象</li>
<li>在java中的每个不同的集合，在底层对应不同的数据的存储结构（数据结构），往集合中存储元素，实际上就是向这些数据结构中存储数据，不同的数据结构，数据的存储方式不同</li>
</ul>
<h2 id="集合继承结构"><a href="#集合继承结构" class="headerlink" title="集合继承结构"></a>集合继承结构</h2><h3 id="单值集合"><a href="#单值集合" class="headerlink" title="单值集合"></a>单值集合</h3><p>单值集合，数据不是以键值对方式存储的集合，<strong>根接口为Iterable接口，Collection接口继承Iterable接口，List和Set接口继承Collection接口，List接口有ArrayList，LinkedList，Vector三个常用实现类，Set有HashSet实现类，SortedSet接口的TreeSet实现类</strong></p>
<p><img src="/2020/10/14/collection/collection.png" alt="以Collection"></p>
<h3 id="键值对集合"><a href="#键值对集合" class="headerlink" title="键值对集合"></a>键值对集合</h3><p>键值对集合，数据是以键：值的方式来存储，根接口为Map,Map的常用子类HashMap,Hashtable,SortedMap,</p>
<p>HashMap的子类Properties,SortedMap的子类TreeMap</p>
<p><img src="/2020/10/14/collection/map.png" alt></p>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>size() : 集合元素个数</li>
<li>isEmpty() ； 集合是否为空</li>
<li>add() ： 增加元素</li>
<li>addAll()</li>
<li>remove() ：移除元素</li>
<li>removeAll()</li>
<li>contains()</li>
<li>containsAll()</li>
</ul>
<h3 id="通用遍历"><a href="#通用遍历" class="headerlink" title="通用遍历"></a>通用遍历</h3><p>使用集合中包含的迭代器进行元素遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Itreator iterator = collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    String str = iterator.next();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="contains方法"><a href="#contains方法" class="headerlink" title="contains方法"></a>contains方法</h3><p>集合中是否包含参数中的元素，如果参数为null，会遍历集合中的元素，判断是否存在值为null的元素；如果不为空，会比较内容是否相等</p>
<p>如果是自定义类，需要重写equals方法</p>
<h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><p>删除指定元素，根据实现类的不同，有不同的实现方法</p>
<p>内部和contains类似</p>
<h4 id="PS-remove方法"><a href="#PS-remove方法" class="headerlink" title="PS : remove方法"></a>PS : remove方法</h4><p>在使用迭代器的时候，获取的迭代器相当于集合的快照，如果在迭代过程集合的结构发生变化，而没有重新获取集合的迭代器，在调用<strong>.next（）</strong>方法的时候，会出现异常<strong>java.util.ConcurrentModificationException</strong></p>
<ul>
<li><p>一旦集合的结构发生变化，原来的迭代器就不能使用，此时集合删除元素之后，迭代器无法跟随集合一起发生变化，底层检查两者不一致，产生异常。</p>
</li>
<li><p>如果使用迭代器的remove方法，系统会通知集合将相应的元素删除，保证快照、集合的一致，不会产生上述异常</p>
</li>
</ul>
<p>在使用迭代器遍历集合的元素时，在对集合进行操作时(元素增删操作)，需要再次获取集合的迭代器</p>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><h4 id="ArrayList实现类"><a href="#ArrayList实现类" class="headerlink" title="ArrayList实现类"></a>ArrayList实现类</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>优点：根据索引查询指定位置的元素速度快，随机访问速度快，跟数组的特点有关，知道数组的首地址以及数组元素下表，可以根据数学表达式获取元素</li>
<li>缺点：增删元素速度慢，涉及到数组的扩容以及数组元素的移动问题，<strong>在数组末尾添加元素不会影响到效率</strong></li>
<li>底层的数据结构为数组，Object数组</li>
</ul>
<h5 id="初始容量"><a href="#初始容量" class="headerlink" title="初始容量"></a>初始容量</h5><ul>
<li>如果没有指定ArrayList的容量大小的时候，默认数组的初始化容量为10，在使用add方法添加元素的时候，创建数组，使用默认构造函数的时候，初始数组默认空数组</li>
<li>如果指定初始化容量，在初始化容量为0时，为空数组；容量不为空而且符合要求时，创建一个长度为指定容量的Object数组</li>
</ul>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><ol>
<li>new ArrayList(): 使用默认初始容量，10</li>
<li>new ArrayList(initCapacity): 初始容量initCapacity</li>
<li>new ArrayList(Collection)</li>
</ol>
<h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><p>ArrayList数组扩容，数组容量变为原来容量的1.5倍</p>
<h5 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="LinkedList实现类"><a href="#LinkedList实现类" class="headerlink" title="LinkedList实现类"></a>LinkedList实现类</h4><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>底层数据结构为双向链表，由于链表的数据存储在磁盘上不连续，可以在任意位置增删元素，随机增删效率较高，但是查找元素的时候需要从首节点开始进行遍历，效率较慢</li>
<li>链表的结点包含三个部分，指向前面元素的prev指针，存储的元素element，指向后面元素的last指针；</li>
<li>双向链表开始时只有两个指针，头指针first，尾指针last，在添加元素的时候，首先创建节点，存储数据，然后将创建的节点添加到链表中，需要改变last指针指向的位置</li>
<li>双向链表中，last.next始终为null，first.next指向链表的首元素</li>
</ul>
<h5 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h5><p>双向链表结构</p>
<h5 id="初始容量："><a href="#初始容量：" class="headerlink" title="初始容量："></a>初始容量：</h5><p>对于LinkedList来说，没有初始容量initCapacity概念，开始的时候只有首尾指针，不涉及到具体存储的元素</p>
<h4 id="Vector实现类"><a href="#Vector实现类" class="headerlink" title="Vector实现类"></a>Vector实现类</h4><h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>底层实现使用数组，与ArrayList的实现相同，但是所有的方法都使用synchronized进行修饰，线程安全，执行速度相对于ArrayList比较慢</li>
<li>扩容：容量变为初容量的两倍</li>
</ul>
<h4 id="泛型：Generic"><a href="#泛型：Generic" class="headerlink" title="泛型：Generic"></a>泛型：Generic</h4><p>泛型用来指定集合中存储元素的类型，保证集合元素类型的一致性，在进行访问时，可以直接访问</p>
<ul>
<li>泛型又称为自动类型推断，钻石表达式，在源码中包含泛型机制，就可以为创建的对象进行类型检验（编译期）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 此时list集合只能存储String类型的数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用泛型可以在遍历元素的是否减少“向下转型”，但是同时也失去了集合存储元素的自由度</li>
</ul>
<h2 id="Map-Set"><a href="#Map-Set" class="headerlink" title="Map Set"></a>Map Set</h2><p>Set的所有实现都是通过Map相应的结构变换来的，学习Map，将Map的value固定，key中存储元素，就变成了Set</p>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>Map存储的数据是以键值对的方式进行存储的，K : V形式</li>
<li>Map存储的数据不论是key还是value都是对象的内存地址（引用）</li>
</ul>
<h4 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>; <span class="comment">// Map中存放键值对</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>;	<span class="comment">// 根据键查找元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;	<span class="comment">// Map中存放元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 清除Map中的所有元素</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>;  <span class="comment">// 删除键为key的键值对</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------</span></span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;	<span class="comment">// 获取键的集合</span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;	<span class="comment">// 获取值的集合</span></span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt; &gt; entrySet(); <span class="comment">// 获取键值的set集合</span></span><br></pre></td></tr></table></figure>

<h4 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h4><ol>
<li>先获取所有的键集合，通过键来查找每个对应的值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;K&gt; sets = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (K k : sets)&#123;</span><br><span class="line">    System.out.println(<span class="string">"Key : "</span> + k + <span class="string">"Value : "</span> + map.get(k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>一次获取所有的键值对，分别取出每个键值对对应的键和值</li>
</ol>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.<span class="keyword">Entry</span>&lt;K,V&gt; &gt; entrys = map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.<span class="keyword">Entry</span>&lt;K,V&gt; <span class="keyword">entry</span> : <span class="type">entrys</span>)&#123;</span><br><span class="line">	System.<span class="keyword">out</span>.println(<span class="string">"Key : "</span> + <span class="keyword">entry</span>.getKey() + <span class="string">"value : "</span> + <span class="keyword">entry</span>.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map.Entry是Map中的内部类，使用getKey()获取键，使用getValue()获取值，在大量数据遍历的时候，需要使Map.Entry&lt;K,V&gt;来进行遍历</p>
<h3 id="HashMap实现类"><a href="#HashMap实现类" class="headerlink" title="HashMap实现类"></a>HashMap实现类</h3><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><ul>
<li>HashMap底层是：<strong>数组+单向链表+红黑树</strong>，又叫<strong>哈希表或者散列表</strong></li>
<li>数组：检索效率比较高，但是随机增删效率较低；单向链表：随机增删效率较高，但是检索效率比较高。哈希表综合两个数据结构的优点，通过hash算法将key映射到数组下标，然后再从下标开始检索数据，缩小检索范围，提高效率</li>
<li>无论数据的存取，都需要先根据key，将key的哈希值映射到数组下标中</li>
<li>HashMap的键可以为null，但是由于键的不可重复，只能有一个为null</li>
</ul>
<h4 id="容量以及扩容"><a href="#容量以及扩容" class="headerlink" title="容量以及扩容"></a>容量以及扩容</h4><ul>
<li>HashMap的初始容量为16，默认加载因子为0.75，数组容量达到规定容量的0.75时，进行扩容，变为原容量的2倍</li>
<li>在JDK8之后，如果单向链表上的节点数大于等于8时，结构转化为红黑树；红黑树节点小于6时，在转换为单向链表</li>
</ul>
<h4 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map的键值对，HashMap中被封装在节点中，Node&lt;K,V&gt;</span></span><br><span class="line">Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash;		<span class="comment">// 根据key计算哈希值</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;    <span class="comment">// 指向下一个节点的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashMap中的put、get方法"><a href="#HashMap中的put、get方法" class="headerlink" title="HashMap中的put、get方法"></a>HashMap中的put、get方法</h4><ol>
<li><strong>put方法</strong></li>
</ol>
<ul>
<li>第一步：先将K，V封装为Node对象</li>
<li>第二步：底层会调用k的hashCode方法得出hash值</li>
<li>第三步：根据hash值，通过哈希算法，将hash值转换为数组的下标，下标位置如果没有元素，就把Node添加到这个位置上；如果下标位置上有元素，会拿着k与链表中的每个节点的key进行equals比较，所有的都为false，将Node添加到最后；有一个为true，将该节点的value进行覆盖</li>
</ul>
<ol start="2">
<li><strong>get方法</strong></li>
</ol>
<ul>
<li>第一步：根据k调用hashCode获取hash值</li>
<li>第二步：通过hash值，使用哈希算法获取数组下标，如果下标位置没有元素，返回null；如果下标位置有链表，将k与每个节点的key进行equals，如果都为false，返回true；如果有一个为true，返回该节点的value。</li>
</ul>
<p>​    说明：同一个下标上的所有节点的hash值可能不一样，但是经过hash算法之后可以得到相同的数组下标，和hash算法的实现有关，可能是取余，会造成“哈希碰撞”</p>
<h4 id="为什么哈希表的随机增删和检索效率都比较高？"><a href="#为什么哈希表的随机增删和检索效率都比较高？" class="headerlink" title="为什么哈希表的随机增删和检索效率都比较高？"></a>为什么哈希表的随机增删和检索效率都比较高？</h4><p>​    随机增删在链表上进行；检索也不需要全部扫描</p>
<h5 id="重写hashCode和equals？"><a href="#重写hashCode和equals？" class="headerlink" title="重写hashCode和equals？"></a>重写hashCode和equals？</h5><p>​    HashMap中增加元素和获取元素，都需要获取key的hash值，以及进行元素比较，在自定义类时，需要重写这两个方法</p>
<h4 id="再次理解HashMap的无序不可重复？"><a href="#再次理解HashMap的无序不可重复？" class="headerlink" title="再次理解HashMap的无序不可重复？"></a>再次理解HashMap的无序不可重复？</h4><p>​    无序：增加元素的时候，根据hash码来进行定位，不知道该元素的放置位置，存储顺序和取出顺序可能不一样</p>
<p>​    不可重复：重写了equals方法，一旦重复，会覆盖原来节点上的value</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>​    存放在HashMap集合的Key部分的，以及HashSet上的元素，需要重写hashCode和equals方法</p>
<h3 id="Hashtable实现类"><a href="#Hashtable实现类" class="headerlink" title="Hashtable实现类"></a>Hashtable实现类</h3><h4 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>底层的数据结构哈希表，线程安全，由于保证线程安全（不使用synchronized关键字）已经具有更好的方法，Hashtable使用的较少</li>
<li>Hashtable的键和值都不能为null</li>
<li>初始默认容量11，默认加载因子为0.75，扩容2 * capacity + 1</li>
</ul>
<h4 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h4><ul>
<li>Hashtable的子类，线程安全，键和值只能为String，又称为配置类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties propertits = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// 存储键值对</span></span><br><span class="line">properties.setProperty(<span class="string">"1"</span>,<span class="string">"2"</span>);</span><br><span class="line"><span class="comment">// 根据key获取value</span></span><br><span class="line">properties.getProperty(<span class="string">"1"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="TreeMap实现类"><a href="#TreeMap实现类" class="headerlink" title="TreeMap实现类"></a>TreeMap实现类</h3><h4 id="特点：-4"><a href="#特点：-4" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>TreeMap：可排序集合，存储在TreeMap中的元素按照大小自动排序</li>
<li>TreeSet：将元素存储在TreeMap的key部分</li>
<li>可以传入外部比较器在构造函数中，改变默认排序规则</li>
</ul>
<h4 id="结构：-1"><a href="#结构：-1" class="headerlink" title="结构："></a>结构：</h4><ul>
<li>TreeMap底层实现二叉树，采用左小右大的原则存放。存储的时候会将元素进行比较，这个比较的过程就是排序的过程，比根节点小的作为左子树，根节点大的作为右子树，相同的覆盖原来的元素</li>
<li>TreeMap的迭代器使用的是中序遍历</li>
</ul>
<h4 id="自定义对象的存储"><a href="#自定义对象的存储" class="headerlink" title="自定义对象的存储"></a>自定义对象的存储</h4><p>​    由于数据存储的时候需要对元素进行排序，底层会对key部分的元素进行比较，因此存储的元素必须是可比较的，有两种实现形式。</p>
<pre><code>1. 实现java.lang.Comparable接口，重写compareTo方法</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体的比较规则</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在TreeMap的构造器中传入比较器，实现java.util.Comparator接口，也可以使用匿名内部类实现Comparator接口，重写compare方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时机：</p>
<ul>
<li>比较规则不发生改变，实现Comparable接口</li>
<li>比较规则经常改变，可以实现Comparator接口</li>
</ul>
<h2 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a>集合总结</h2><table>
<thead>
<tr>
<th></th>
<th align="center">初始容量</th>
<th>加载因子</th>
<th>扩    容</th>
<th>数据结构</th>
<th>遍历方式</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td align="center">10</td>
<td>1</td>
<td>15</td>
<td>数组</td>
<td>1.迭代器 2.循环遍历</td>
</tr>
<tr>
<td>LinkedList</td>
<td align="center">/</td>
<td>/</td>
<td>/</td>
<td>双向链表</td>
<td>1.迭代器 2.循环遍历</td>
</tr>
<tr>
<td>Vector</td>
<td align="center">10</td>
<td>1</td>
<td>20</td>
<td>数组，线程安全</td>
<td>1.迭代器 2.循环遍历</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>初始容量</th>
<th>加载因子</th>
<th>扩容</th>
<th>数据结构</th>
<th>key是否null</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>16</td>
<td>0.75</td>
<td>2 * capacity</td>
<td>哈希表</td>
<td>是</td>
</tr>
<tr>
<td>Hashtable</td>
<td>11</td>
<td>0.75</td>
<td>2*capacity + 1</td>
<td>哈希表</td>
<td>否</td>
</tr>
</tbody></table>
<p>对于自定义类，建议重写hashCode和equals方法，如果数据存储在TreeMap中，需要实现比较器，让对象可以比较，确定大小</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java-SE</tag>
      </tags>
  </entry>
  <entry>
    <title>HuTool</title>
    <url>/2020/11/25/hutool/</url>
    <content><![CDATA[<p><a href="https://www.hutool.cn/" target="_blank" rel="noopener">HuTool</a><br><img src="/2020/11/25/hutool/ht_1.png" alt></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HuTool是一个小而全的java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，涵盖了java开发的方方面面。</p>
<p><strong>名称</strong></p>
<p>HuTool=&gt; 难得糊涂,不需要了解底层开发原理，直接使用</p>
<p><strong>改变编码方式</strong></p>
<p>不需要搜索需要解决的问题，直接引入<code>hutool</code>对应的解决方案就可以，可以保证代码的一致性</p>
<p><strong>组件</strong></p>
<p>一个java基础工具类，对文件、流、加密解密、转码、正则、线程、xml进行封装，并且提供对应的组件</p>
<h2 id="使用HuTool"><a href="#使用HuTool" class="headerlink" title="使用HuTool"></a>使用HuTool</h2><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Convert类型转换"><a href="#Convert类型转换" class="headerlink" title="Convert类型转换"></a>Convert类型转换</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在java开发中，需要面对很多类型转换方面的问题，一般的解决方法是先将其转换为字符串类型，然后调用<code>parseXX()</code>方法，还需要增加<code>try.catch</code>捕获异常，Convert类可以解决这个问题。</p>
<h3 id="Convert"><a href="#Convert" class="headerlink" title="Convert"></a>Convert</h3><p>COnvert是一个类型转换工具类，封装了对于java常见类型的转换，可以用来简化类型转换。Convert类大大部分方法是<code>toXXX()</code>,参数类型是Object,可以将任意类型的参数转换为指定类型。同时支持第二个<code>defaultValue</code>在转换失败时返回默认值。</p>
<h3 id="Convert类的使用"><a href="#Convert类的使用" class="headerlink" title="Convert类的使用"></a>Convert类的使用</h3><p>Convert类可以转换为不同的</p>
<h4 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Convert.toStr(Object)</span><br><span class="line"><span class="comment">// 整型数据转换为字符串</span></span><br><span class="line">String str = Convert.toStr(a);</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="comment">// 数组转换为字符串</span></span><br><span class="line"><span class="keyword">long</span>[] b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">String toStr = Convert.toStr(b);</span><br><span class="line">System.out.println(toStr);</span><br><span class="line"><span class="comment">// toStr = "[1, 2, 3, 4]"</span></span><br></pre></td></tr></table></figure>

<h4 id="转换为日期对象"><a href="#转换为日期对象" class="headerlink" title="转换为日期对象"></a>转换为日期对象</h4><p>Convert类转换，可以转换不同格式的数据，不需要指定格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统转换</span></span><br><span class="line">String date = <span class="string">"2020-11-25"</span>;</span><br><span class="line">Date parse = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).parse(date);</span><br><span class="line">System.out.println(parse);</span><br><span class="line"><span class="comment">// Convert转换</span></span><br><span class="line">System.out.println(Convert.toDate(date));</span><br><span class="line">String date1 = <span class="string">"2020/11/25"</span>;</span><br><span class="line">System.out.println(Convert.toDate(date1));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>HuTool</tag>
      </tags>
  </entry>
  <entry>
    <title>Lombok</title>
    <url>/2020/11/25/lombok/</url>
    <content><![CDATA[<p><a href="https://projectlombok.org/" target="_blank" rel="noopener">lombok官网</a><br><img src="/2020/11/25/lombok/1.png" alt></p>
<h2 id="IDEA安装Lombok"><a href="#IDEA安装Lombok" class="headerlink" title="IDEA安装Lombok"></a>IDEA安装Lombok</h2><pre><code>Files -&gt; Setting
Plugins -&gt; 搜索Lombok</code></pre><h2 id="lombok概述"><a href="#lombok概述" class="headerlink" title="lombok概述"></a>lombok概述</h2><p>lombok是一个java库，可以自动插入编译器和构建工具中，lombok提供了一组有用的注释（注解），来消除代码中大量的样板代码（Setter,Getter），可以替换数百行代码。</p>
<p>lombok是指一种快速开发工具，提供了一组java开发注解，通过注解来快速生成Java对象中的方法。（get,set,equals,hashcode）</p>
<h2 id="lombok的使用"><a href="#lombok的使用" class="headerlink" title="lombok的使用"></a>lombok的使用</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>引入maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用lombok注解</p>
</li>
</ol>
<p>在java对象前面增加@Data等相关注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="comment">// @Data注解</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lombok原理"><a href="#lombok原理" class="headerlink" title="lombok原理"></a>lombok原理</h3><p>lombok在编译期生效，在jvm将java源文件进行语法分析的时候，根据lombok注解修改语法树，生成包含set,get方法的字节码文件。<br>在引入坐标的时候，有scope属性，因为和lombok的原理有关，只需要在编译期将对应的注解解析到语法树，生成的字节码文件已经包含具体的代码，不需要在将其部署到实际生产环境上。</p>
<h3 id="lombok注解"><a href="#lombok注解" class="headerlink" title="lombok注解"></a>lombok注解</h3><h4 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h4><pre><code>使用在类上
用来生成set,get,equals,hashcode</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Getter-Setter"><a href="#Getter-Setter" class="headerlink" title="@Getter @Setter"></a>@Getter @Setter</h4><pre><code>用在类上
生成对应的get和set方法</code></pre><h4 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h4><pre><code>用在类上
只生成toString方法</code></pre><h4 id="AllArgsConstructor-NoArgsConstructor"><a href="#AllArgsConstructor-NoArgsConstructor" class="headerlink" title="@AllArgsConstructor @NoArgsConstructor"></a>@AllArgsConstructor @NoArgsConstructor</h4><pre><code>用在类上
生成全部的有参构造方法，一般配合无参构造方法 @NoArgsConstructor</code></pre><h4 id="Accessors"><a href="#Accessors" class="headerlink" title="@Accessors"></a>@Accessors</h4><pre><code>用在类上
用来给类中的set方法开启链式调用，chain属性：true,开启</code></pre><p><img src="/2020/11/25/lombok/2.png" alt></p>
<h4 id="slf4j"><a href="#slf4j" class="headerlink" title="@slf4j"></a>@slf4j</h4><pre><code>用在类上
用来快速给类定义一个日志变量</code></pre>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu</title>
    <url>/2020/10/24/ubuntu/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>这篇博客主要记录在使用Vmware安装的Unbuntu系统下遇到的错误以及解决问题的方式</code></pre><h2 id="虚拟机打开黑屏（1）"><a href="#虚拟机打开黑屏（1）" class="headerlink" title="虚拟机打开黑屏（1）"></a>虚拟机打开黑屏（1）</h2><pre><code>1. 解决方式
    由于在日志里面有句话，虚拟打印设备无法使用，在编辑中启用虚拟设备，可以打开虚拟机

2. 链接</code></pre><ul>
<li><a href="https://blog.csdn.net/qq_37074001/article/details/102645024" target="_blank" rel="noopener">虚拟机黑屏解决方法</a></li>
</ul>
<h2 id="虚拟机打开黑屏（2）"><a href="#虚拟机打开黑屏（2）" class="headerlink" title="虚拟机打开黑屏（2）"></a>虚拟机打开黑屏（2）</h2><pre><code>在每次重新打开电脑的时候，可以正常进入Unbuntu系统，但是一旦关闭后，无法再次进入系统，一值黑屏

本系统VMware: 15, Uubuntu: 18.04
解决方法：
    1. 在进入Unbuntu的时候，按F2进入启动项，按键盘&apos;E&apos;,进行编辑

    2. 在屏幕里的待编辑文字中找到【splash】 ，正常在中下部

    3. 在【splash】后加入一个空格，再键入【nomodeset】

    4. 按下Ctrl+X，退出编辑，重启系统，此时可以正常系统

    5. 进入Unbuntu系统后，打开终端，编辑文件</code></pre><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo gedit /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>

<pre><code>6. 随后在打开的文档中，找到所有的【splash】，并在其后加入一个空格，再键入【nomodeset】

7. 保存文件，以后就可以正常使用Ubuntu了</code></pre><h2 id="Unbuntu安装FTP"><a href="#Unbuntu安装FTP" class="headerlink" title="Unbuntu安装FTP"></a>Unbuntu安装FTP</h2><h3 id="E-无法定位软件包-vsftpd"><a href="#E-无法定位软件包-vsftpd" class="headerlink" title="E: 无法定位软件包 vsftpd"></a>E: 无法定位软件包 vsftpd</h3><pre><code>1. 问题描述
    在使用`sudo apt-get install vsftpd`安装ftp系统的时候，出现该问题</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/24/ubuntu/1_error.png" alt="E: 无法定位软件包 vsftpd"></p>
<pre><code>2. 解决方法</code></pre><p>更新软件源，<code>sudo apt-get update</code>        </p>
<h2 id="无法解析域名"><a href="#无法解析域名" class="headerlink" title="无法解析域名"></a>无法解析域名</h2><pre><code>1. 问题描述
    在使用`sudo apt-get update`,出现域名无法解析的问题，应该是域名服务器出现了问题，实际上是虚拟操作系统的网络出了问题，重新配置网络之后，可以进行更新</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/24/ubuntu/2_error.png" alt="无法解析域名"></p>
<pre><code>2. 解决方法
    1. 查看DNS的配置文件
        重新配置网络DNS</code></pre><pre><code class="linux">cat /etc/resolv.conf</code></pre>
<blockquote>
</blockquote>
<p><img src="/2020/10/24/ubuntu/2_1.png" alt></p>
<ul>
<li><a href="https://www.jb51.net/article/158414.htm" target="_blank" rel="noopener">Linux网络配置</a></li>
</ul>
<h2 id="ifconig无法使用"><a href="#ifconig无法使用" class="headerlink" title="ifconig无法使用"></a>ifconig无法使用</h2><pre><code>* sudo apt install net-tools
* sudo apt update: 升级apt</code></pre><ul>
<li><a href="https://blog.csdn.net/i_spirit/article/details/109182493" target="_blank" rel="noopener">command “ifconfig” not found</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Unbuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ssm_errors</title>
    <url>/2020/10/16/ssm-error/</url>
    <content><![CDATA[<h3 id="dao接口不匹配"><a href="#dao接口不匹配" class="headerlink" title="dao接口不匹配"></a>dao接口不匹配</h3><p><code>BindingException: Invalid bound statement (not found): com.maven.dao.ItemsDao.findAll</code></p>
<pre><code>1. 问题
    dao的接口与映射配置文件的绑定失败

2. 解决思路
    1. 检查dao的方法名与mapper.xml的方法id是否一致
    2. 检查mapper.xml的namaspace是否为dao接口的全限定类名
    3. 检查mapper.xml的resultMapper,parameterType是否正确
    4. 检查是否出现拼写错误
    5. 检查mapper.xml的路径是否出现错误
    6. 检查dao的类名和mapper.xml的名称是否一致，不一致，也有可能导致错误</code></pre><p><em>接口名和映射配置文件名称应该一致，在ssm框架中</em></p>
<pre><code>3. 对applicationContext.xml进行改变
    * 在sqlSessionFactoryBean的prperty属性
    * 找到mapperLocations的标签内部
    * 增加list标签
    * 增加value标签，将mapper.xml配置文件全部加入</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/16/ssm-error/error_1_1.png" alt></p>
<pre><code>4. 检查target文件夹下是否有.xml文件
    没有文件</code></pre><p><code>&lt;build&gt;
&lt;resources&gt;
&lt;resource&gt;
&lt;directory&gt;src/main/java&lt;/directory&gt;
&lt;includes&gt;
&lt;include&gt;**/*.xml&lt;/include&gt;
&lt;/includes&gt;
&lt;filtering&gt;true&lt;/filtering&gt;
&lt;/resource&gt;
&lt;/resources&gt;
&lt;/build&gt;</code></p>
<pre><code>5. 解决</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/16/ssm-error/error_1.png" alt></p>
<pre><code>6. 总结
    1. 如果在applicationContext.xml文件中没有指定具体的配置文件位置，应该回到对应的资源目录下的对应路径下寻找和dao名称相同的.xml文件，将.xml的文件名指定为dao的接口名称就可以进行绑定
    2. 如果在核心配置文件中指定了配置文件的位置，不需要dao的接口名称和mapper配置文件的名称相匹配，也可以扫描的具体的配置文件，完成代理对象的创建
    3. 如果.xml文件不是存放在资源路径下，需要对其进行设置，在pom.xml文件中进行设置</code></pre>]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2020/10/15/mysql/</url>
    <content><![CDATA[<pre><code>* 针对数据库查询的延伸学习
* 强化数据库操作
* 学习更好的使用MySQL数据库，提高效率</code></pre><ul>
<li><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">mysql官网下载</a></li>
<li><a href="https://print3306.github.io/2020/06/18/mysql57/">Windows版下载安装</a></li>
<li><a href="https://jingyan.baidu.com/article/48b558e382811d3f39c09a77.html" target="_blank" rel="noopener">Linux版安装</a></li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="Index说明"><a href="#Index说明" class="headerlink" title="Index说明"></a>Index说明</h3><pre><code>1. 索引的含义
    索引（Index）是帮助MySQL高效获取数据（查询）的一种数据结构。
    在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向（或引用）数据，这样就可以在这些数据结构上使用高级查找算法，提高查询效率，这种数据结构就是索引。

2. 特点
    * 用来提高查询效率的指向数据的数据结构
    * 满足特定查找算法
    * 可以使用高级查找算法进行数据查询

3. 索引的使用
    1. 没有索引
        查询数据需要全表扫描，最差的情况扫描n次，效率极低

    2. 使用索引
        根据查找数据的特点，建立数据结构，可以使用顺序表，二叉树等，来查询数值型数据</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/index.png" alt></p>
<h3 id="Index的优势和劣势"><a href="#Index的优势和劣势" class="headerlink" title="Index的优势和劣势"></a>Index的优势和劣势</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><pre><code>1. 类似于书籍的目录索引，提高数据的检索效率，降低数据库的IO成本
2. 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</code></pre><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><pre><code>1. 索引本身需要开销，索引本身也是一张表，该表保存了主键和索引字段，并指向实体类的记录（一般保存在磁盘文件）
2. 索引降低了数据更新表的速度（Update，Delete,Insert）,在数据更新之后，索引表也需要进行维护，需要调整因为更新带来的键值变化后的索引信息</code></pre><h3 id="Index的结构"><a href="#Index的结构" class="headerlink" title="Index的结构"></a>Index的结构</h3><pre><code>索引是在MySQL的存储引擎层中实现的，不是在服务器层实现的，所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持索引。</code></pre><h4 id="主流的索引（4种）"><a href="#主流的索引（4种）" class="headerlink" title="主流的索引（4种）"></a>主流的索引（4种）</h4><pre><code>1. BTree (B+树) : 最常见的索引类型，大部分的索引引擎都支持BTree类型的索引
2. Hash ：只有Memory引擎支持，使用场景简单
3. R-tree(空间索引) ：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型
4. Full-text(全文索引) ：全文索引也是MyISAM引擎的一个特殊索引类型，
主要用于全文索引，InnoBD引擎从MySQL5.6版本开始支持Full-text索引</code></pre><blockquote>
<p><strong>MyISAM,InnoDB,Memory三种存储引擎对于各种索引类型的支持</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">索引</th>
<th align="center">InnoDB引擎</th>
<th align="center">Memery引擎</th>
<th align="center">MyISAM引擎</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BTree</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">Hash</td>
<td align="center">不支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">R-tree</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">Full-text</td>
<td align="center">5.6以后支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<pre><code>我们平常所说的索引一般都是指B+树，多路搜索树，其中聚集索引，复合索引，前缀索引，
唯一索引默认使用的都是B+树，统称为索引    </code></pre><h4 id="BTree结构"><a href="#BTree结构" class="headerlink" title="BTree结构"></a>BTree结构</h4><pre><code>默认InnoDB存储引擎所支持的索引结构主要就是：BTree

1. BTree的特点
    BTree又叫做多路平衡搜索树，一颗m叉的BTree特性如下:
        * 树的每个节点的最多包含m个孩子
        * 除根结点与叶子节点之外，每个节点至少有[ceil(m / 2)]个孩子:ceil向上取整
        * 若根节点不是叶子节点，至少有两个孩子
        * 所有的叶子节点都在同一层
        * 每个非叶子节点有n个key与n+1个指针组成，其中[ceil(m / 2) - 1] &lt;= n &lt;= m-1

2. BTree实例
    以一个5叉的b树为例，可以由公式推导出，key的取值，ceil(5 / 2 - 1) = 2 &lt;= n 
    &lt;= 5-1 = 4,所以每个非叶子节点的key的取值为[2,4],
    当n&gt;4时，中间节点分裂到父结点，两边节点分裂

1. 以插入CNGA HEKQ MFWL TZDP RXYS字符串为例</code></pre><ul>
<li>插入前四个字母:CNGA</li>
</ul>
<p><img src="/2020/10/15/mysql/BTree_5_1.png" alt="CNGA">    </p>
<ul>
<li>插入H， n &gt; 4</li>
</ul>
<p><img src="/2020/10/15/mysql/BTree_5_2.png" alt="CNGAH"></p>
<ul>
<li>插入E,K,Q，此时没有节点的key到达4，整体结构不变</li>
</ul>
<p><img src="/2020/10/15/mysql/BTree_5_3_2.png" alt="CNGAHEKQ"></p>
<ul>
<li>插入M,M分裂到父结点</li>
</ul>
<p><img src="/2020/10/15/mysql/BTree_5_4.png" alt="CNGAHEKQM"></p>
<ul>
<li>插入F,W,L,T,结构不变</li>
</ul>
<p><img src="/2020/10/15/mysql/BTree_5_5.png" alt="CNGAHEKQMFWLT"></p>
<ul>
<li>插入Z,T变为父结点</li>
</ul>
<p><img src="/2020/10/15/mysql/BTree_5_6.png" alt="CNGAHEKQMFWLTZ"></p>
<ul>
<li>插入D,D变为父结点</li>
</ul>
<p><img src="/2020/10/15/mysql/BTree_5_7.png" alt="CNGAHEKQMFWLTZD"></p>
<ul>
<li>插入P，R，X，Y结构不变</li>
</ul>
<p><img src="/2020/10/15/mysql/BTree_5_8.png" alt="CNGAHEKQMFWLTZDPRXY"></p>
<ul>
<li>插入S,需要分隔两次父结点</li>
</ul>
<p><img src="/2020/10/15/mysql/BTree_5_9.png" alt="CNGAHEKQMFWLTZDPRXYS"></p>
<h4 id="B-Tree的结构"><a href="#B-Tree的结构" class="headerlink" title="B+Tree的结构"></a>B+Tree的结构</h4><pre><code>B+Tree是BTree的变种，B+Tree和BTree的区别：
    * n叉B+Tree最多有n个key，而BTree最多有n-1个key
    * B+Tree的叶子节点保存所有的key信息，根据key的大小排序
    * 所有非叶子节点都可以看做key的索引部分

1. 由于B+Tree的所有key信息保存在叶子节点中,查询任何数据都需要经过root到叶子节点，B+Tree的查询效率更加稳定
2. 为了减少磁盘I/O操作，磁盘并不是每次需要才去读取，而是会进行预读取。在预读取的过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。
3. 数据库系统将索引的一个节点的大小，使得一次I/O就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能被预先载入

使用B+Tree的好处，可以充分利用操作系统的文件系统，减少磁盘IO操作</code></pre><h4 id="MySQL中的BTree"><a href="#MySQL中的BTree" class="headerlink" title="MySQL中的BTree"></a>MySQL中的BTree</h4><pre><code>MySQL中的BTree实际上指的是B+Tree，但是在B+Tree树的基础上进行了优化，增加了一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高了区间访问的性能。

1. 为什么改进的B+Tree能提高区间访问的能力？
    由于在叶子节点上增加了指向相邻节点的链表指针，数据区间查询的时候，可以通过指针查找到所有数据，不需要通过root节点向下进行查找</code></pre><h3 id="Index的分类"><a href="#Index的分类" class="headerlink" title="Index的分类"></a>Index的分类</h3><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><pre><code>1. 单值索引：索引只包含单个列，一个表可以包括多个单值索引
2. 唯一索引：索引列的值必须唯一，但允许有空值（包括多个空值）
3. 复合索引：一个索引包含多个列</code></pre><h4 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h4><pre><code>索引可以在创建表的时候创建，也可以随时增加新的索引。</code></pre><h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><pre><code>1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>|fulltext|spatial] <span class="keyword">index</span> index_name</span><br><span class="line">[<span class="keyword">using</span> index_type]</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">table</span>(index_col_name...);</span><br><span class="line">index_col_name : column_name[(length)][desc|asc]</span><br><span class="line">案例：在名称上建立索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_city_name <span class="keyword">on</span> city(city_name);</span><br></pre></td></tr></table></figure>

<h5 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h5><pre><code>1. 语法</code></pre><p><code>show index from city;</code></p>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/index_show.png" alt></p>
<pre><code>没有指定建立索引的类型，InnoDB引擎默认使用BTree索引类型</code></pre><h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><pre><code>1. 语法</code></pre><p><code>drop index idx_city_name on city;</code></p>
<h5 id="ALTER命令"><a href="#ALTER命令" class="headerlink" title="ALTER命令"></a>ALTER命令</h5><pre><code>1. 使用
    可以在使用ALter修改表结构的时候，修改索引</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> primary <span class="keyword">key</span>(column_list); </span><br><span class="line">添加主键，索引值唯一，不能为null,自动添加索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> <span class="keyword">unique</span> index_name(column_list);</span><br><span class="line">添加唯一索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> <span class="keyword">index</span> index_name(column_list);</span><br><span class="line">添加普通索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> fulltext index_name(column_list);</span><br><span class="line">添加全文索引</span><br></pre></td></tr></table></figure>

<h3 id="Index设计原则"><a href="#Index设计原则" class="headerlink" title="Index设计原则"></a>Index设计原则</h3><pre><code>1. 设计原则
    * 查询频次高，而且数据量比较大的表
    * 查询条件，索引字段的选择，最佳候选列应该从where子句中出现的条件选择
    * 使用唯一索引，区分度高，使用索引的效率越高
    * 索引的数量不是越多越好，在更新的时候，需要维护索引
    * 尽量使用短索引，索引创建完成之后，需要保存在磁盘文件中，使用短索引可以提升磁盘IO
    的效率，给定大小的存储块中可以存储更多的索引值
    * 利用最左前缀，N个列组合而成的组合索引，相当于创建了N个索引，如果查询时where使用
    了组合索引的某个前缀，这个查询条件可以利用组合索引来提高效率</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">创建复合索引</span><br><span class="line">	<span class="keyword">create</span> <span class="keyword">index</span> idx_name_email_status <span class="keyword">on</span> city(<span class="keyword">name</span>,email,<span class="keyword">status</span>);</span><br><span class="line">就相当于：</span><br><span class="line">	对name 创建索引</span><br><span class="line">	对name email 创建索引</span><br><span class="line">	对name email status 创建索引</span><br></pre></td></tr></table></figure>

<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="视图概述"><a href="#视图概述" class="headerlink" title="视图概述"></a>视图概述</h3><pre><code>1. 什么是视图？
    视图（View）是一种虚拟存在的表，视图并不真实的存在于数据库中，行和列的数据来自于
定义视图的语句动态生成。通俗的讲，视图就是一条select语句执行后返回的结果集，所以创建
视图的时候，主要工作就在于创建这一条SQL语句。

2. 使用视图的优势
    * 简单：使用视图的用户不需要关注表的关联条件，筛选条件，是过滤好的值
    * 安全：使用视图的用户看到的值是允许访问的部分，将表的权限锁定在某一行某一列
    * 数据独立：一旦视图的结构确定，用户无法感知到实体表的变化情况，屏蔽了表的变化</code></pre><h3 id="创建或修改视图"><a href="#创建或修改视图" class="headerlink" title="创建或修改视图"></a>创建或修改视图</h3><pre><code>1. 创建视图的语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> <span class="keyword">replace</span>] [algorithm = &#123;undefined,<span class="keyword">merge</span>,temptable&#125;]</span><br><span class="line"><span class="keyword">view</span> view_name</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line">[<span class="keyword">with</span> [<span class="keyword">cascade</span> | <span class="keyword">local</span>] <span class="keyword">check</span> <span class="keyword">option</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/view_create.png" alt></p>
<pre><code>2. 更新视图
    可以按照使用实体表的方法使用视图，在更新视图的时候，实际上是更新的实体表</code></pre><p><code>update view_city_country set city_name=&#39;gg&#39; where country_name=&#39;中国&#39;</code>    </p>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/view_update.png" alt></p>
<pre><code>是否可以更新视图还取决于，
    [with [cascade | local] check option]

    * local: 只要满足本视图的条件就可以更新
    * cascade: 必须满足针对该视图的所有条件才能进行更新（默认值）

虽然可以更新视图，但是不建议更新，需要更新，可以直接更新实体表    

3. 修改视图</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> [algorithm = &#123;undefined,<span class="keyword">merge</span>,temptable&#125;]</span><br><span class="line"><span class="keyword">view</span> view_name</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line">[<span class="keyword">with</span> [<span class="keyword">cascade</span> | <span class="keyword">local</span>] <span class="keyword">check</span> <span class="keyword">option</span>]</span><br></pre></td></tr></table></figure>

<h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><pre><code>1. 查看视图</code></pre><p>在MySQL中，视图也是表的一种，可以使用<code>show tables;</code>进行查看</p>
<pre><code>2. 查看创建视图的语句</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> view_city_country;</span><br></pre></td></tr></table></figure>

<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> [<span class="keyword">if</span> <span class="keyword">exists</span>] view_name [,view_name] ... [restrict | <span class="keyword">cascade</span>];</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> view_city_country;</span><br></pre></td></tr></table></figure>

<h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><h3 id="存储过程和函数概述"><a href="#存储过程和函数概述" class="headerlink" title="存储过程和函数概述"></a>存储过程和函数概述</h3><pre><code> 存储过程和函数是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程和函数可
以简化开发人员的工作，减少数据在数据库和应用之间的传输，有利于提高数据处理的效率

存储过程和函数的区别：函数必须要有返回值，存储过程没有返回值
    函数：有返回值的过程
    过程：没有返回值的函数</code></pre><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><pre><code>1. 语法
    SQL语句默认的分隔符为分号，使用存储过程需要改变默认分隔符
    DELIMITER:声明分割符，默认为分号</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $;	声明$为分隔符</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> procedure_name([params])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">-- sql语句</span></span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure>
<pre><code>2. 案例</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER ^</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pro_test4()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> country;</span><br><span class="line"><span class="keyword">END</span>^</span><br></pre></td></tr></table></figure>

<h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><pre><code>语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> procedure_name() ;</span><br></pre></td></tr></table></figure>

<h3 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h3><pre><code>1. 使用数据库查询语句</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">form</span> mysql.proc <span class="keyword">where</span> db = <span class="string">'db_name'</span>;</span><br><span class="line">db_name : 查询的数据库的名称</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/pro_1.png" alt></p>
<pre><code>2. 查询存储过程的状态</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查询存储过程，以格式化的方式进行展示</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> <span class="keyword">status</span>\G;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/pro_2.png" alt></p>
<pre><code>3. 查询某个存储过程的定义</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> test.pro\G;</span><br></pre></td></tr></table></figure>

<h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> pro_name;</span><br></pre></td></tr></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>declare: 声明</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> var_name[,...] <span class="keyword">type</span> [<span class="keyword">default</span> <span class="keyword">value</span>];</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">sum</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">sum</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<ul>
<li>set : 赋值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> var_name = <span class="keyword">exp</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>select .. into …</p>
<p>  将查询的结果赋值给变量</p>
</li>
<li><p>ps:</p>
<ol>
<li>使用@修饰的变量，叫做会话变量，连接关闭，变量失效，类似于全局变量</li>
<li>使用@@修饰的变量，叫做系统变量</li>
<li>在存储过程中的变量，不需要修饰符进行修饰，普通变量；在外部使用的变量，一般使用@修饰，全局变量</li>
</ol>
</li>
</ul>
<h4 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h4><pre><code>1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 条件判断语句</span><br><span class="line">if serach_condition then statement_list</span><br><span class="line">[,elseif search_condition then statement_list]</span><br><span class="line">[else statement_list]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br></pre></td></tr></table></figure>

<pre><code>2. 使用案例</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/pro_3.png" alt="案例if"></p>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><pre><code>1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> proc_name(<span class="keyword">in</span>/<span class="keyword">out</span>/inout 参数名 参数类型)</span><br><span class="line"><span class="keyword">in</span> ： 该参数作为输入参数，在调用的时候传入，默认</span><br><span class="line"><span class="keyword">out</span> : 输出参数，该参数可以作为返回值</span><br><span class="line">inout : 可以作为输入参数，也可以作为输出参数</span><br></pre></td></tr></table></figure>

<h4 id="case语法"><a href="#case语法" class="headerlink" title="case语法"></a>case语法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 方式一 : 表达式满足某种条件</span><br><span class="line">case</span><br><span class="line">	when exp1 then state1;</span><br><span class="line">	when exp2 then state2;</span><br><span class="line">	else staten;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line">// 方式二 ：情况匹配</span><br><span class="line">case exp</span><br><span class="line">	when wnen_1 then state1;</span><br><span class="line">	when when_2 then state2;</span><br><span class="line">	else staten;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure>

<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><pre><code>1. 语法
    先判断，条件成立，循环开始执行，最少执行了0次</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">while search_condition <span class="keyword">do</span></span><br><span class="line">	statement_list</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br></pre></td></tr></table></figure>

<pre><code>2. 案例</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_while2(n <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">num</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">	while num&lt;=n do</span><br><span class="line">		<span class="keyword">set</span> total = total + <span class="keyword">num</span>;</span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">num</span> = <span class="keyword">num</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">	<span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure>

<h5 id="repeat循环"><a href="#repeat循环" class="headerlink" title="repeat循环"></a>repeat循环</h5><pre><code>1. 语法
    满足条件，退出循环, 条件之后不需要增加分号</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 执行循环体，直到条件满足，退出循环</span><br><span class="line">repeat </span><br><span class="line">	statement_list</span><br><span class="line">until search_condition</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span>$</span><br></pre></td></tr></table></figure>

<pre><code>2. 案例</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_repeat(n <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	repeat</span><br><span class="line">		<span class="keyword">set</span> total = total + n;</span><br><span class="line">		<span class="keyword">set</span> n = n - <span class="number">1</span>;</span><br><span class="line">	until n = 0</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line">	<span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure>

<h5 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h5><pre><code>1. 语法
    一般退出语句需要使用leave语句来进行实现，如果不退出，直接死循环</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">start_label loop</span><br><span class="line">	statement_condition</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span> [start_label];</span><br></pre></td></tr></table></figure>

<h4 id="leave语句"><a href="#leave语句" class="headerlink" title="leave语句"></a>leave语句</h4><pre><code>在loop语句执行的时候，可以使用leave进行退出循环</code></pre><h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><pre><code>游标是用来存储查询结果集的数据类型，在存储过程和函数中使用游标对结果集进行循环的处理，游标的使用包括游标的声明，open，fetch, close

1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 声明游标，游标的位置在查询结果集的第一行数据</span><br><span class="line"><span class="keyword">declare</span> cursor_name <span class="keyword">cursor</span> <span class="keyword">for</span> select_statement;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// open : 打开游标</span><br><span class="line">open cursor_name;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// fetch : 游标推进一次</span><br><span class="line">fetch cursor_name into var_name[,var_name];</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// colse</span><br><span class="line">close cuesor_name;</span><br></pre></td></tr></table></figure>

<pre><code>2. 使用循环退出
    * MySQL提供了句柄机制，一旦触发句柄，可以改变变量的值，在循环中判断变量的值，可以完成循环
    * 使用句柄，可以方便的控制结果集的输出，只需要在声明游标的时候同时声明handler</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> cursor_name <span class="keyword">cursor</span> <span class="keyword">for</span> select_statement;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">exit</span> <span class="keyword">handler</span> <span class="keyword">for</span> <span class="keyword">not</span> <span class="keyword">found</span> <span class="keyword">set</span> <span class="keyword">var</span> = var_value;</span><br><span class="line">// 句柄的定义和游标的定义在一起</span><br></pre></td></tr></table></figure>

<pre><code>3. 游标使用案例</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro10()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">-- 声明变量</span></span><br><span class="line">	<span class="keyword">declare</span> flag <span class="built_in">int</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="keyword">declare</span> cid <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line">	<span class="comment">-- 声明游标和句柄</span></span><br><span class="line">    <span class="keyword">declare</span> city_result <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> city;</span><br><span class="line">    <span class="keyword">declare</span> continue <span class="keyword">handler</span> <span class="keyword">for</span> <span class="keyword">not</span> <span class="keyword">found</span> <span class="keyword">set</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">-- 打开游标</span></span><br><span class="line">    open city_result;</span><br><span class="line">	<span class="comment">-- 推进游标</span></span><br><span class="line">    fetch city_result into id,name,cid;</span><br><span class="line">	<span class="comment">-- 循环推进游标</span></span><br><span class="line">    while(not flag) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'id='</span>,<span class="keyword">id</span>,<span class="string">'name='</span>,<span class="keyword">name</span>,<span class="string">'cid='</span>,cid);</span><br><span class="line">        fetch city_result into id,name,cid;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">	<span class="comment">-- 关闭游标</span></span><br><span class="line">    close city_result;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/cursor_1.png" alt="游标"></p>
<pre><code>4. 说明
    * 游标最好配合句柄一起使用，这样就不需要在单独查询数据条数，进行循环语句的判断
    * 可以根据不同的循环条件，对游标的具体推进做出调整</code></pre><h4 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h4><pre><code>有返回值的存储过程（存储过程也可以返回值，out参数类型）

1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> function_name([params])</span><br><span class="line"><span class="keyword">returns</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<pre><code>2. 案例
    定义函数，满足某种条件的记录数：</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delemiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fn1(countryid <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">num</span> <span class="built_in">int</span>;</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> <span class="keyword">num</span> <span class="keyword">from</span> city <span class="keyword">where</span> country_id = countryid;</span><br><span class="line">	return num;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure>

<pre><code>3. 调用函数
    * 使用select来调用函数
    * 函数相当于一个表达式，使用select来调用函数</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/fun_1.png" alt></p>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><pre><code>触发器（trigger）是与表有关的数据库对象，指在insert/update/delete之前或之后，触发并执行触发器中定义的SQL语句集合，
 * 确保数据的完整性
 * 记录日志， 在进行操作之前，生成记录，保存在日志文件中
 * 数据校验，使用触发器在操作之前进行数据校验，保证数据安全

1. 使用别名OLD和NEW来引用触发器中发生变化的记录内容，现在MySQL数据库，触发器只支持行级触发，不支持语句级触发。
2. OLD和NEW的使用</code></pre><table>
<thead>
<tr>
<th align="center">触发器类型</th>
<th align="center">NEW和OLD的使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">insert型</td>
<td align="center">NEW表示将要或已经插入的数据</td>
</tr>
<tr>
<td align="center">update型</td>
<td align="center">NEW表示将要修改或者修改后的数据，OLD表示修改之前的数据</td>
</tr>
<tr>
<td align="center">delete型</td>
<td align="center">OLD表示将要或者已经删除的数据</td>
</tr>
</tbody></table>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><pre><code>1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name </span><br><span class="line"><span class="keyword">before</span>|<span class="keyword">after</span> <span class="keyword">insert</span>|<span class="keyword">update</span>|<span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> table_name</span><br><span class="line">[<span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span>] <span class="comment">-- 行级触发器</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">-- SQL</span></span><br><span class="line"><span class="keyword">end</span>;```  </span><br><span class="line"></span><br><span class="line">	2. 案例</span><br><span class="line">		在插入数据进入city之后，将名称存入country表</span><br><span class="line">​```sql</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_insert_city</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> city</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> country <span class="keyword">values</span>(<span class="literal">null</span>,new.city_name);</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure>

<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><pre><code>1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看触发器</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">triggers</span>\G;</span><br><span class="line"><span class="comment">-- 删除触发器</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> [schema_name.]trigger_name; </span><br><span class="line"><span class="comment">-- 默认删除当前数据库的指定触发器</span></span><br></pre></td></tr></table></figure>

<h2 id="MySQL的体系结构"><a href="#MySQL的体系结构" class="headerlink" title="MySQL的体系结构"></a>MySQL的体系结构</h2><h3 id="MySQL的体系结构-1"><a href="#MySQL的体系结构-1" class="headerlink" title="MySQL的体系结构"></a>MySQL的体系结构</h3><pre><code>1. 组成部分
    整个MySQL Server有以下几个部分组成：
    1. 连接层：接受客户端的连接请求，用户认证
        包括安全认证，权限检测
        * Connection Pool
    2. 服务层：各种服务组件，完成核心功能
        * Manegement Server: 管理组件，包括备份，恢复。。
        * SQL interface：SQL语句接口，可以定义DML,DDL,Procedure
        * Parser: 解析器，解析SQL语句
        * Optimizer：优化器，
        * Caches：缓存
    3. 存储引擎：
        InnoDB,Memery,Merge...
        选择合适的存储引擎存储数据
    4. 文件系统层
        最终的文件需要存储在磁盘内部，包括数据信息和各种日志信息

2. 各个层次的作用
    1. 连接层
        * 包含本地sock通信和大多数基于客户端/服务器模式工具实现的类似TCP/IP的通信。
        * 主要完成类似于连接处理，授权认证，相关的安全方案。
        * 在连接层引入了连接池的概念，为通过认证安全的连接提供线程，可以实现基于SSL的安全链接，服务器也会为安全链接的用户验证权限。

    2. 服务层
        * 主要完成数据库的核心功能，SQL接口，缓存，SQL的分析和优化，内置函数的执行。
        * 所有的跨存储引擎的功能也是在这一层实现，比如过程和函数，在服务层，服务器会解析查询并创建相应的内部解析树，并对其完成特定的优化,比如确定表的查询顺序，是否利用索引等，最后生成相应的执行操作。
        * 如果是select语句，还会查询缓存。

    3. 存储引擎层
        * 真正负责MySQL数据的存储和查询，服务器通过API和存储引擎进行通信
        * 不同的存储引擎具有不同的功能

    4. 文件系统层
        * 将数据存储在文件系统之上，和文件系统进行交互

MySQL最多的特点：
    插件式的存储引擎结构，如果存储引擎的性能达不到要求,可以更改存储引擎类型</code></pre><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>存储引擎就是存储数据，建立索引，更新查询数据等技术的实现。</li>
<li>存储引擎是基于表的，而不是基于库的，存储引擎也称为表类型,可以在表的建立时指定存储引擎</li>
<li>其他数据库oracle，SQL Server只支持一种存储引擎，MySQL支持可拔插的存储引擎架构，可以根据需要选择存储引擎</li>
<li>MySQL支持的存储引擎包括：InnoDB,MyISAM,Memoey,CSV,NDB,Merge等，InnoDB，BDB支持事务安全，其中InnoDB是默认的存储引擎（5.5版本之后）</li>
</ul>
<p>可以使用<code>show engines</code>来展示存储引擎,也可以使用<code>show variables like &#39;%storage_engines&#39;</code>来查看存储引擎</p>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/engines_1.png" alt></p>
<h4 id="各种存储引擎特性"><a href="#各种存储引擎特性" class="headerlink" title="各种存储引擎特性"></a>各种存储引擎特性</h4><pre><code>常用的存储引擎：InnoDB MyISAM</code></pre><table>
<thead>
<tr>
<th align="center">特点</th>
<th align="center">InnoDB</th>
<th align="center">MyISAM</th>
<th align="center">Memory</th>
<th align="center">Merge</th>
<th align="center">NDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储限制</td>
<td align="center">64TB</td>
<td align="center">有</td>
<td align="center">有</td>
<td align="center">没有</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">事务安全</td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">锁机制</td>
<td align="center">行锁（高并发）</td>
<td align="center">表锁</td>
<td align="center">表锁</td>
<td align="center">表锁</td>
<td align="center">行锁</td>
</tr>
<tr>
<td align="center">B树索引</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">哈希索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">5.6以后</td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">集群索引</td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">数据索引</td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">索引缓存</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">空间使用</td>
<td align="center">高</td>
<td align="center">低</td>
<td align="center"></td>
<td align="center">低</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">内存使用</td>
<td align="center">高</td>
<td align="center">低</td>
<td align="center">中</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">批量插入</td>
<td align="center">低</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">外键</td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h5 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h5><pre><code>InnoDB存储引擎是MySQL的默认存储引擎，具有提交，回滚，恢复事务能力，相对于MyISAM存储引擎，InnoDB的写的处理效率较低，而且会占用更多的存储空间来存储索引和数据。</code></pre><p><strong>支持事务安全</strong></p>
<pre><code>默认每个查询是一次事务，会自动提交事务
使用start transaction,开启事务，在数据查询之后，使用commit可以提交事务</code></pre><p><strong>支持外键</strong></p>
<pre><code>InnoDB存储引擎是唯一支持外键的存储引擎，在创建子表时，可以指定在删除，更新主表对子表的操作如下，restrict,cascade,set null,no action
* restrict和no action：限制子表有关联记录时，父表不能更新
* cascade: 在更新父表的时候，更新对应子表中的记录
* set null: 在更新父表的时候，子表的对应字段设置为空</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`city_innodb`</span>(</span><br><span class="line">	<span class="string">`city_id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	<span class="string">`city_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	<span class="string">`country_id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(<span class="string">`city_id`</span>),</span><br><span class="line">	<span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(country_id) <span class="keyword">REFERENCES</span> country_innodb(country_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line">on <span class="keyword">update</span> restrict: 在更新时，存在关联，不能进行更新</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span>: 在删除时，级联删除</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/innodb.png" alt="InnoDB"></p>
<pre><code>PS:    如果在导入多个表的时候需要忽略导入表的顺序</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 关闭外键约束</span></span><br><span class="line"><span class="keyword">set</span> foreign_key_check = <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 开启外键约束</span></span><br><span class="line"><span class="keyword">set</span> foreign_key_check = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>存储方式</strong></p>
<pre><code>在linux操作系统下，mysql只要存储两个文件,多表空间存储
1. .frm文件：存储表的结构信息（定义 ）
2. .idb文件：存储表的索引信息和数据</code></pre><h5 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h5><pre><code>MyISAM不支持事务和外键，访问速度块，对事务的完整性没有要求的select,insert为主的数据可以使用MyISAM存储引擎</code></pre><p><strong>不支持事务</strong></p>
<pre><code>一旦查询语句执行，数据会马上提交到数据库</code></pre><p><strong>文件存储方式</strong></p>
<pre><code>每个MyISAM存储引擎会分成3个文件名称和表的名称相同，拓展名不同：
1. .frm: 存储表的定义
2. .myd: 存储表的数据
3. .myi: 存储表的索引</code></pre><h5 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h5><pre><code>1. Memory存储引擎将表的数据存放在内存中，默认大小16MB。
2. 每个表对应一个磁盘文件，格式是.frm,该文件只存放表的结构，数据文件全都存放在内存中，这样有利于数据的快速处理，提高表的效率。
3. Memory类型的表的数据访问速度快，因为数据存放在内存中，可以默认使用Hash索引，但是服务一旦关闭表中的数据就会丢失。</code></pre><h5 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h5><pre><code>类似于视图，虚拟表，只包含结构，不包含数据
1. Merge是一组MyISAM的组合，这些MyISAM表结构必须完全相同，Merge本身并没有存储数据
2. 对Merge类型的表可以进行查询，删除，更新等，这些操作实际上是对内部的MyISAM进行操作
3. 对于Merge类型表的插入操作，是通过子句insert_method子句定义插入的表，
    * 使用first,last使插入的数据作用在第一个或者最后一个表上
    * 不定义或者定义为no,表示不能对Merge表进行插入操作
4. drop操作，只是删除了Merge本身的定义，对实际表没有影响

1. Merge类型的使用</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表1</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_1(</span><br><span class="line">	order_id <span class="built_in">INT</span>,</span><br><span class="line">	order_money <span class="keyword">DOUBLE</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	order_address <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(order_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=MYISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"><span class="comment">-- 表2</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_2(</span><br><span class="line">	order_id <span class="built_in">INT</span>,</span><br><span class="line">	order_money <span class="keyword">DOUBLE</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	order_address <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(order_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=MYISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"><span class="comment">-- merge表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_all(</span><br><span class="line">	order_id <span class="built_in">INT</span>,</span><br><span class="line">	order_money <span class="keyword">DOUBLE</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	order_address <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(order_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">MERGE</span> <span class="keyword">UNION</span> = (order_1,order_2) INSERT_METHOD = <span class="keyword">LAST</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_1 <span class="keyword">VALUES</span>(<span class="number">10</span>,<span class="number">100.0</span>,<span class="string">'上海'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_1 <span class="keyword">VALUES</span>(<span class="number">20</span>,<span class="number">300.0</span>,<span class="string">'北京'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_2 <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">100.0</span>,<span class="string">'云南'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_2 <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">100.0</span>,<span class="string">'合肥'</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/merge_1.png" alt></p>
<pre><code>2. 注意
    union: 表示合并的是哪些表
    insert_method: 插入数据的方式，这里使用last，向order_2插入数据
    合并表的主键有可能会出现相同的情况</code></pre><h4 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h4><pre><code>在选择存储引擎时，可以根据需要进行选择单个存储引擎，也可以选择多个存储引擎同时使用：</code></pre><ul>
<li>InnoDB: 对数据的安全性要求比较高，数据容错率低，在并发环境下要求数据的一致性，数据除了查询之外还有更新和删除的时候，应该选择InnoDB存储引擎。比如计费系统，财务系统</li>
<li>MyISAM: 不支持事务控制，如果对数据的操作以查询和插入为主，对并发的要求不高的情况下，可以使用</li>
<li>Memory: 所有的数据都保存在内存中，对数据的操作速度快，在小容量，对访问速度要求比较高的情况下，可以使用Memory引擎。更新不太频繁的小表中</li>
<li>Merge: 将一组MyISAM表组合起来，作为一个引用来使用，可以突破单个MyISAM引擎表的大小限制，将不同的表存在多个磁盘，可以改善访问效率。数据存储仓库比较合适 </li>
</ul>
<h3 id="优化SQL步骤"><a href="#优化SQL步骤" class="headerlink" title="优化SQL步骤"></a>优化SQL步骤</h3><pre><code>在初期开发过程中，数据量比较小，一般来说只需要实现功能即可，但是随着用户数据的增多，
SQL语句的执行速度越来越慢,此时，需要对一些有问题的SQL语句进行优化。</code></pre><h4 id="插入大量的数据"><a href="#插入大量的数据" class="headerlink" title="插入大量的数据"></a>插入大量的数据</h4><pre><code>* 不同的存储引擎具有不同的功能，如果在MySQL数据库中建立大量的数据，可以在使用Memory创建表，然后将内存中的数据插入想要的表
* 可以使用存储过程，也可以建立多个独立的数据表，使用Merge进行合并</code></pre><ul>
<li><a href="https://blog.csdn.net/weixin_44901453/article/details/96453405" target="_blank" rel="noopener">1</a></li>
<li><a href="https://www.cnblogs.com/hill1126/p/11334523.html" target="_blank" rel="noopener">2</a></li>
</ul>
<ol>
<li><p>修改默认的存储空间</p>
<pre><code>MySQL默认的内存空间为16M，可以手动修改内存大小</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置内存大小为1GB</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_heap_table_size = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查看当前的设置的大小</span></span><br><span class="line"><span class="keyword">select</span> @@max_heap_table_size;</span><br><span class="line"><span class="comment">-- 在重新连接数据库服务端的时候，生效</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>建立memory表<br> 只需要具体的存储引擎为Memory，属性的域和想要插入的域一致</p>
</li>
<li><p>建立具体应用的表<br> 存储引擎可以为InnoDB,MyISAM</p>
</li>
<li><p>建立生成数据并插入的存储过程</p>
</li>
<li><p>将建立的表数据插入具体应用的表,清空在内存中的数据</p>
</li>
</ol>
</li>
</ol>
<p><code>TRUNCATE TABLE tablename</code></p>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/sql_5.png" alt></p>
<h4 id="查看SQL执行频率"><a href="#查看SQL执行频率" class="headerlink" title="查看SQL执行频率"></a>查看SQL执行频率</h4><p>MySQL客户端连接成功之后，可以使用<code>show global|session status</code>查看服务器的状态信息，<code>show global|session status</code>可以根据参数<code>session</code>查看当前会话（当前连接）的统计结果，或者<code>golbal</code>整个数据库（自从上次启动之后）的统计结果</p>
<pre><code>1. 当前session的统计结果</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这里通配符使用 - ，一共7个，长度固定，更好观察结果</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Com______'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/sql_1.png" alt="当前连接的状态"></p>
<pre><code>2. 查看InnoDB存储引擎的统计结果</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'InnoDB_rows_%'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/sql_2.png" alt="InnoDB的状态"></p>
<pre><code>3. 查看自从上次重启之后的统计结果</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Com_______'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/sql_3.png" alt="当前服务器的状态"></p>
<h4 id="定位低效率SQL语句"><a href="#定位低效率SQL语句" class="headerlink" title="定位低效率SQL语句"></a>定位低效率SQL语句</h4><ul>
<li>慢查询日志进行定位：可以通过慢查询日志来定位哪些执行效率比较慢的SQL语句，使用<code>--log-slow-queries[=file_name]</code>选项启动的时侯，mysqld写一个包含执行时间超过<code>long-query-time</code>秒的SQL语句，可以分析日志，定位到慢查询语句</li>
<li>show processlist: 慢查询日志在查询结束之后才能发现执行效率低的SQL语句，可以使用命名令来查看当前SQL语句在进行的线程，包括线程的状态，是否锁表等信息，可以实时的查看SQL的执行情况</li>
</ul>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/sql_4.png" alt="当前服务器的状态"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id列：用户登录MySQL之后，分配的connection_id,可以调用函数connection_id进行查看</span><br><span class="line">user列：显示当前用户，如果不是root用户，只能显示当前权限内的sql</span><br><span class="line">host列：显示这个SQL是从哪个IP的哪个端口发出的，跟踪出现问题的用户</span><br><span class="line">db列：当前进程正在连接哪个数据库</span><br><span class="line">command列：当前连接正在执行的命令，sleep,query,connect</span><br><span class="line">state列：当前连接的状态，语句执行过程中的一个状态</span><br><span class="line">time列：已经进行的时间</span><br><span class="line">info列：正在执行的SQL语句</span><br></pre></td></tr></table></figure>

<h4 id="explain分析计划执行"><a href="#explain分析计划执行" class="headerlink" title="explain分析计划执行"></a>explain分析计划执行</h4><pre><code>通过定位慢查询语句可以知道哪些SQL语句的执行效率比较低，可以使用explain或者desc命令分析MySQL如何
执行select语句，包括在执行过程中表如何连接以及连接顺序

查询SQL语句的执行计划：</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- explain desc都可以获取SQL的执行顺序</span></span><br><span class="line"><span class="keyword">explain</span> | <span class="keyword">desc</span> <span class="keyword">select</span> * <span class="keyword">from</span> vote_record <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">500</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/explain_1.png" alt="explian执行计划"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 属性的含义</span></span><br><span class="line">id: 查询的序列号，一组数字，表示查询过程中<span class="keyword">select</span>子句或者操作表的顺序</span><br><span class="line">select_type: 执行操作的类型，simple primary...</span><br><span class="line"><span class="keyword">table</span>: 输出结果集的表</span><br><span class="line"><span class="keyword">type</span>: 表的连接类型，性能由好到差<span class="keyword">system</span>,const,eq_ref,<span class="keyword">ref</span>,ref_of_null,index_merge ,index_subquert,<span class="keyword">range</span>,<span class="keyword">index</span> ,<span class="keyword">all</span></span><br><span class="line">possible_keys: 可能使用的索引</span><br><span class="line"><span class="keyword">key</span>: 实际使用的索引</span><br><span class="line"><span class="keyword">rows</span>: 扫描行的数量</span><br><span class="line">extra: 执行情况的说明和描述</span><br></pre></td></tr></table></figure>

<h5 id="explain-id"><a href="#explain-id" class="headerlink" title="explain: id"></a>explain: id</h5><pre><code>id: 表示表的加载顺序,可以通过查看id来发现语句执行的顺序

1. id相同，表示从上到下顺序加载</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询用户对应的角色信息</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">as</span> u,t_role <span class="keyword">as</span> r,user_role <span class="keyword">as</span> ur <span class="keyword">where</span> u.id = ur.user_id <span class="keyword">and</span> ur.role_id = r.id;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/explain_2.png" alt="explain_id"></p>
<pre><code>2. id不同，id的值越大，优先级越高</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询指定用户名的角色,嵌套查询</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> role_code <span class="keyword">from</span> t_role <span class="keyword">where</span> <span class="keyword">id</span> = (<span class="keyword">select</span> role_id <span class="keyword">from</span> user_role <span class="keyword">where</span> user_id = (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> username = <span class="string">'zxl'</span>));</span><br><span class="line">1. 先查询t_user 2.再查询user_role 3.最后查询t_user</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/explain_3.png" alt="explain_id"></p>
<pre><code>3. id有相同的，也有不同的</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询用户id为2的对应的角色信息</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_role r,(<span class="keyword">select</span> * <span class="keyword">from</span> user_role <span class="keyword">where</span> user_id = <span class="string">'2'</span>) a <span class="keyword">where</span> a.role_id = r.id;</span><br></pre></td></tr></table></figure>

<h5 id="explain-select-type"><a href="#explain-select-type" class="headerlink" title="explain: select_type"></a>explain: select_type</h5><pre><code>select_type: 执行语句的类型
    derived衍生类型没有表现出来</code></pre><table>
<thead>
<tr>
<th align="center">取值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">simple</td>
<td align="center">简单的查询，不包含子查询和Union</td>
</tr>
<tr>
<td align="center">primary</td>
<td align="center">包含复杂子查询语句，最外层的查询语句为该标识</td>
</tr>
<tr>
<td align="center">subquery</td>
<td align="center">在select或者where子句包含子查询</td>
</tr>
<tr>
<td align="center">derived</td>
<td align="center">在from列表包含的子查询，标记为衍生，MySQL递归执行，生成临时表</td>
</tr>
<tr>
<td align="center">union</td>
<td align="center">若第二个select子句包含在union之后，标记为union;union子句包含在from子句内，外层select标记derived</td>
</tr>
<tr>
<td align="center">union result</td>
<td align="center">从union表获取的结果</td>
</tr>
<tr>
<td align="center">效率</td>
<td align="center">从上往下逐渐降低</td>
</tr>
</tbody></table>
<h5 id="explain-table"><a href="#explain-table" class="headerlink" title="explain: table"></a>explain: table</h5><pre><code>查询的数据是基于哪张表的</code></pre><h5 id="explain-type"><a href="#explain-type" class="headerlink" title="explain: type"></a>explain: type</h5><pre><code>显示的是访问类型，重要的参考指标</code></pre><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">null</td>
<td align="center">MySQL不访问任何的表，索引，直接返回结果，系统函数</td>
</tr>
<tr>
<td align="center">system</td>
<td align="center">表只有一行记录，const的特例，一般不会出现</td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">常量，通过索引一次就找到了，在使用主键或者唯一索引进行查询的时候,只有一条数据匹配。将主键索引放置到where子句，MySQL就能将查询转换为一个常量，const将主键或唯一索引于常量值进行比较</td>
</tr>
<tr>
<td align="center">eq_ref</td>
<td align="center">使用唯一索引，使用主键的关联索引，关联查询的数据只有一条</td>
</tr>
<tr>
<td align="center">ref</td>
<td align="center">非唯一性索引，返回匹配的结果集，本质也是索引查询</td>
</tr>
<tr>
<td align="center">range</td>
<td align="center">只检索给定返回的行，使用一个索引来返回数据，where后有between,in</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">扫描整个索引树，效率比All要高</td>
</tr>
<tr>
<td align="center">all</td>
<td align="center">扫描所有数据，整个数据文件，效率最低</td>
</tr>
</tbody></table>
<pre><code>效率排序</code></pre><figure class="highlight"><table><tr><td class="code"><pre><span class="line">null system const eq_ref fulltext ref_or_null index_merge unique_subquery</span><br><span class="line">index_sunquery range index all</span><br><span class="line">注意：</span><br><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</span><br></pre></td></tr></table></figure>

<pre><code>在进行SQL优化的时候，至少保证达到range级别，最好到达ref</code></pre><h5 id="explain-key"><a href="#explain-key" class="headerlink" title="explain: key"></a>explain: key</h5><ul>
<li>possible_key: 可能使用到的索引</li>
<li>key：实际上使用的索引</li>
<li>key_len: 索引的长度，长度越低，效率越高</li>
</ul>
<h5 id="explain-rows"><a href="#explain-rows" class="headerlink" title="explain: rows"></a>explain: rows</h5><pre><code>扫描行的数量    </code></pre><h5 id="explain-extra"><a href="#explain-extra" class="headerlink" title="explain: extra"></a>explain: extra</h5><pre><code>额外的执行计划</code></pre><table>
<thead>
<tr>
<th align="center">extra</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">using filesort</td>
<td align="center">MySQL会对数据进行外部的索引排序，不是按照数据库中的索引进行读取，称为“文件排序”，效率低</td>
</tr>
<tr>
<td align="center">using temporary</td>
<td align="center">使用临时表保存中间结果,MySQL在查询中间结果时使用临时表，order by group by</td>
</tr>
<tr>
<td align="center">using index</td>
<td align="center">相应的select操作使用了索引，效率可以</td>
</tr>
</tbody></table>
<h4 id="show-profile分析SQL"><a href="#show-profile分析SQL" class="headerlink" title="show profile分析SQL"></a>show profile分析SQL</h4><p>MySQL自从5.0.7之后增加了<code>show profiles</code>和<code>show profile</code>语句的支持。<code>show profiles</code>能够在SQL优化的同时帮助我们了解时间耗费在哪。</p>
<p>通过<code>have_ptofiling</code>参数，可以看出MySQL是否支持profile:</p>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/profile_1.png" alt="查看profile是否支持"></p>
<p>profile默认关闭，可以通过<code>select @@profiling</code>查看是否开启：</p>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/profile_2.png" alt="开启profile"></p>
<pre><code>1. profile的使用</code></pre><p><code>show profiles</code>:查看所有的查询语句耗的时间</p>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/profile_3.png" alt="开启profile"></p>
<p><code>show profile for query query_id</code>:查看对应的查询语句具体的操作步骤花费的时间，也可以查看CPU等信息的情况</p>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/profile_4.png" alt="开启profile"></p>
<pre><code>sending data: 表示MySQL线程开始访问数据行并把结果返回给客户端，不仅仅是访问数据
由于访问数据行需要大量的磁盘IO操作，花费的时间一般来说最长</code></pre><h4 id="trace分析优化器执行计划"><a href="#trace分析优化器执行计划" class="headerlink" title="trace分析优化器执行计划"></a>trace分析优化器执行计划</h4><pre><code>MySQL5.6可以使用trace工具查看优化器的执行次序</code></pre><h5 id="trace设置"><a href="#trace设置" class="headerlink" title="trace设置"></a>trace设置</h5><p>打开trace,设置trace的格式为json,设置最大使用内存，避免解析过程中因为内存无法显示完全</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开启trace, 设置格式为json</span></span><br><span class="line"><span class="keyword">set</span> optimizer_trace = <span class="string">'enabled=on'</span>,end_markers_in_json=<span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size=<span class="number">1000000</span>;</span><br></pre></td></tr></table></figure>

<h5 id="trace跟踪优化器的执行"><a href="#trace跟踪优化器的执行" class="headerlink" title="trace跟踪优化器的执行"></a>trace跟踪优化器的执行</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.optimizer_trace\G;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/15/mysql/trace.png" alt></p>
<h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><h4 id="验证索引提升查询效率"><a href="#验证索引提升查询效率" class="headerlink" title="验证索引提升查询效率"></a>验证索引提升查询效率</h4><p>使用索引和不使用索引查询的效率有较大的差距，可以通过查询一个大量的表进行数据查询实验进行验证<br>在自己的数据库上，使用了100W条数据进行实验</p>
<h4 id="索引的使用-1"><a href="#索引的使用-1" class="headerlink" title="索引的使用"></a>索引的使用</h4><p>big_datas数据库中的vote_record一共100W条数据</p>
<h5 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h5><p><strong>1）全值匹配</strong></p>
<pre><code>* 对索引中的所有列都指定具体值，在这种情况下，索引生效，查询效率高
* 可以实验explain分析工具进行分析</code></pre><p><strong>2）最左前缀法则</strong></p>
<pre><code>* 如果索引了多列，要遵守最左前缀法则，查询从最左前列开始，而且不能跳过索引中的列
* 检查查询条件是否包含索引列，与查询条件顺序无关</code></pre><p><strong>3）范围查询右侧的索引失效</strong></p>
<pre><code>* 多个索引列，满足最左前缀匹配，同时一旦遇到范围查询，在其之后的查询条件，不再使用索引进行查询</code></pre><p><strong>4）索引列上进行运算索引失效</strong></p>
<pre><code>* 一旦在索引列进行运算，索引失效
* B+Tree索引key保存的是具体的数据，一旦运算，索引成本太大</code></pre><p><strong>5）字符串不加单引号索引失效</strong></p>
<pre><code>* 在查询字符串的时候，索引没有被使用，索引失效
* 在MySQL内部，查询优化器会对字符串进行隐式类型转换，在底层，对索引列进行了运算</code></pre><p><strong>6）尽量使用覆盖索引，不使用select※</strong></p>
<pre><code>* 索引覆盖：索引列完全包含查询列
* 只访问索引的查询，减少select *的使用</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在使用explian分析时，extra中的信息</span></span><br><span class="line">using index : 使用了索引覆盖</span><br><span class="line">using where : 在查找使用索引的情况下，需要回表查询所需的数据</span><br><span class="line">using index condition : 在查找使用索引的情况下，需要回表查询所需的数据</span><br><span class="line">using where,using index ：在查找使用索引，所需的属性列全部包含在索引表中，不需要回表查询</span><br></pre></td></tr></table></figure>

<p><strong>7）用or分隔的索引</strong></p>
<pre><code>* 如果前面的查询条件使用索引，但是or后面的条件没有使用索引，那么整个查询没有使用索引
* 如果使用and，将会使用索引</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- vote_id上有索引，但是在create_time上没有索引</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> vote_id,<span class="keyword">group_id</span>,create_time <span class="keyword">from</span> vote_record <span class="keyword">where</span> vote_id=<span class="string">'594'</span> <span class="keyword">or</span> create_time=<span class="string">'2020-11-07 13:08:53'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/15/mysql/index_1.png" alt="OR"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- vote_id上有索引，但是在create_time上没有索引</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> vote_id,<span class="keyword">group_id</span>,create_time <span class="keyword">from</span> vote_record <span class="keyword">where</span> vote_id=<span class="string">'594'</span> <span class="keyword">and</span> create_time=<span class="string">'2020-11-07 13:08:53'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/15/mysql/index_2.png" alt="AND"></p>
<p><strong>8) like模糊查询以%开头的查询，索引失效</strong></p>
<pre><code>* 一旦模糊匹配，%开头，索引失效；加在后面，索引还是生效的
* 使用索引覆盖，可以解决模糊匹配索引失效的问题</code></pre><p><img src="/2020/10/15/mysql/index_4.png" alt="模糊匹配"></p>
<p><strong>9）如果MySQL觉得全表扫描的速度更快，不使用索引</strong></p>
<pre><code>* 和数据库中的数据有关系，MySQL会评估，如果全表扫描更快，不会使用索引</code></pre><p><strong>10) null和not null</strong></p>
<pre><code>* MySQL可以感知数据的Null的数量，自动评估全表扫描和索引的效率</code></pre><p><strong>11）in和not in</strong></p>
<pre><code>* 可能不同的查询条件会产生不同的结果，主键索引案例如下</code></pre><p><img src="/2020/10/15/mysql/index_5.png" alt></p>
<p><strong>12) 单列索引和复合索引</strong></p>
<pre><code>* 尽量使用复合索引，少使用单列索引
* 创建复合索引，最左前缀相当于创建多个索引
* 如果使用多个单列索引，MySQL只会选择一个最优索引（辨识度最高的索引），不会全部使用</code></pre><h4 id="使用索引的查看"><a href="#使用索引的查看" class="headerlink" title="使用索引的查看"></a>使用索引的查看</h4><p>通过指令查看索引的使用情况:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前会话的索引使用</span></span><br><span class="line"><span class="keyword">show</span> statue <span class="keyword">like</span> <span class="string">'handler_read%'</span></span><br><span class="line"><span class="comment">-- 查看当前连接的索引使用</span></span><br><span class="line"><span class="keyword">show</span> golbal statue <span class="keyword">like</span> <span class="string">'handler_read%'</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/15/mysql/index_6.png" alt></p>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><h4 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h4><pre><code>在数据库新建的时候，需要插入大量的数据，对于InnoDB存储引擎，有以下三个方面进行优化：</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 插入数据，需要指定分割符和换行符</span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span> <span class="string">'文件目录'</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">'tabel_name'</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> 分割符 <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> 换行符；</span><br></pre></td></tr></table></figure>

<p><strong>1）主键顺序插入</strong></p>
<pre><code>* InnoDB类型的表是按照主键的顺序保存的，所以将需要导入的数据按照主键的顺序排序，可以有效的提高插入数据的效率
* 如果InnoDB没有主键，系统会自动默认创建内部列作为主键</code></pre><p><strong>2）关闭唯一性校验</strong></p>
<pre><code>* 在导入数据的时候，使用`set unique_check=0，关闭唯一性校验，在数据插入完成之后，将其置为1
* 可以提高效率</code></pre><p><strong>3) 手动提交事务</strong></p>
<pre><code>* 在导入数据之前，将事务提交置为0，也可以提高数据插入效率</code></pre><h4 id="优化insert语句"><a href="#优化insert语句" class="headerlink" title="优化insert语句"></a>优化insert语句</h4><ul>
<li>如果需要同时对一个表插入多条语句，尽量使用多个值表的insert语句，可以减少和数据库之间的连接次数，减少连接，关闭的消耗，效率更高</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 可以改为</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>改为手动提交</p>
</li>
<li><p>插入数据按照主键顺序插入 </p>
</li>
</ul>
<h4 id="优化order-by语句"><a href="#优化order-by语句" class="headerlink" title="优化order by语句"></a>优化order by语句</h4><p><strong>两种排序</strong></p>
<pre><code>1. filesort
    通过对返回的数据集进行排序，使用文件系统进行的排序叫做filesort
    * 所有不是通过索引直接返回排序结果的排序都叫做filesort
2. using index
    通过索引顺序扫描直接返回有序数据的排序叫做using index,不需要额外排序，效率高</code></pre><p><strong>多字段排序</strong></p>
<pre><code>1. 最好全部升序或者全部降序排序
2. 排序的顺序需要和索引的顺序保持一致</code></pre><p><strong>filesort的优化</strong></p>
<pre><code>1. 两次扫描算法
2. 一次扫描算法：一次性取出所有满足条件的所有字段，在排序区排序后直接输出结果集，排序时内存开销大，效率更高

可以通过设置最大排序空间来提高排序效率</code></pre><h4 id="优化group-by语句"><a href="#优化group-by语句" class="headerlink" title="优化group by语句"></a>优化group by语句</h4><pre><code>相对于order by子句，group by只是多了排序之后的分组操作，在group by子句中，可以使用
索引来提高效率

1. 如果像消除group by子句后的排序对于结果的消耗，可以执行order by null禁止排序
2. 使用索引提高效率</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 分组之后，不执行排序，可以提高分组排序的效率</span></span><br><span class="line"><span class="keyword">select</span> age,<span class="keyword">count</span>(*) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">order</span> <span class="keyword">by</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="优化嵌套查询"><a href="#优化嵌套查询" class="headerlink" title="优化嵌套查询"></a>优化嵌套查询</h4><pre><code>尽量少使用子查询，多使用连接查询join连接</code></pre><h4 id="优化or条件"><a href="#优化or条件" class="headerlink" title="优化or条件"></a>优化or条件</h4><pre><code>1. 如果使用or来进行条件的关联，如果相使用索引，每个查询条件都必须使用索引，否则索引不生效
2. 对于复合索引使用or,必须两边同时满足最左前缀匹配
3. 可以使用union来替换or，进行条件的组合</code></pre><h4 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询 ???"></a>优化分页查询 ???</h4><pre><code>limit进行分页查询，在输出结果之前，需要对查询的数据进行排序，然后才使用limit子句，其余的数据丢弃

1. 在索引上完成排序分页操作，然后返回主表进行关联查询操作</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> vote_record v,(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> vote_record <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">20000</span>,<span class="number">10</span>) t <span class="keyword">where</span> t.id = v.id;</span><br></pre></td></tr></table></figure>

<pre><code>2. 对于主键自增的表，可以先进行where子句获取取值范围，再使用limit</code></pre><h4 id="使用SQL提示"><a href="#使用SQL提示" class="headerlink" title="使用SQL提示"></a>使用SQL提示</h4><pre><code>SQL提示，在SQL语句中加入一些人为的提示来进行优化操作</code></pre><h5 id="use-index"><a href="#use-index" class="headerlink" title="use index"></a>use index</h5><pre><code>在查询语句的后面，可能选择的索引有多个，可以增加use index,人为指定可用索引，MySQL不会在比较索引，而是直接使用用户指定的索引</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">use</span> <span class="keyword">index</span>(idx_name);</span><br></pre></td></tr></table></figure>

<h5 id="ignore-index"><a href="#ignore-index" class="headerlink" title="ignore index"></a>ignore index</h5><pre><code>指定忽略的索引</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">ignore</span> <span class="keyword">index</span>(idx_name);</span><br></pre></td></tr></table></figure>

<h5 id="force-index"><a href="#force-index" class="headerlink" title="force index"></a>force index</h5><pre><code>强制使用某个索引，此时有索引，但是全表扫描的效率更高，此时不使用索引</code></pre><h5 id="use-和-force的区别"><a href="#use-和-force的区别" class="headerlink" title="use 和 force的区别"></a>use 和 force的区别</h5><pre><code>use是推荐MySQL使用索引，可能包含多个索引候选项
force在索引效率低的时候，强制MySQL使用索引</code></pre><h2 id="从应用层上进行优化"><a href="#从应用层上进行优化" class="headerlink" title="从应用层上进行优化"></a>从应用层上进行优化</h2><h3 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h3><p>在数据库访问的上层应用，进行优化，减少对数据库服务器的访问压力</p>
<h4 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h4><p>如果每次连接数据库服务器的时候都是创建连接，访问，关闭连接，比较耗费资源，可以使用数据库连接池，来减少连接消耗</p>
<h4 id="减少对MySQL的访问"><a href="#减少对MySQL的访问" class="headerlink" title="减少对MySQL的访问"></a>减少对MySQL的访问</h4><h5 id="避免对数据的重复检索"><a href="#避免对数据的重复检索" class="headerlink" title="避免对数据的重复检索"></a>避免对数据的重复检索</h5><p>在一次获取到所需要的数据时，不要进行多次的查询，可以减少对数据库的无用连接</p>
<pre><code>1. 如果有可以合并访问的字段，可以合并访问，不用进行多次查询
2. 减少类似的重复访问，可以提高数据库的效率</code></pre><h5 id="增加cache层"><a href="#增加cache层" class="headerlink" title="增加cache层"></a>增加cache层</h5><p>在应用中，可以使用缓存来减少对数据库的访问压力<br>    1. 可以将部分数据放置到文本文件中，比如使用MyBatis的一级/二级缓存，以及redis的缓存数据库</p>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>利用某种均衡算法，将固定的负载量分布到不同的服务器上，以此来降低单台服务器的负载，达到优化的目的</p>
<p><strong>利用MySQL的复制分流查询</strong></p>
<p>通过MySQL的<code>主从复制</code>，实现<code>读写分离</code>，使增删改操作走主节点，查询走从节点，来降低单台服务器的压力<br>    1. 将主节点的内容复制到从节点上<br>    2. 对数据的更新在主节点上进行，然后有主节点对从节点的数据进行更新<br>    3. 从节点来进行数据的查询，降低单台服务器的压力</p>
<p><strong>采用分布式数据库架构</strong></p>
<h2 id="MySQL中查询缓存优化"><a href="#MySQL中查询缓存优化" class="headerlink" title="MySQL中查询缓存优化"></a>MySQL中查询缓存优化</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>开启MySQL的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从查询缓存中读取结果，当数据被修改，之前的查询缓存就会失效，所以修改比较频繁的表不适合做查询缓存</p>
<h3 id="数据库操作流程"><a href="#数据库操作流程" class="headerlink" title="数据库操作流程"></a>数据库操作流程</h3><h3 id="查询缓存配置"><a href="#查询缓存配置" class="headerlink" title="查询缓存配置"></a>查询缓存配置</h3><ol>
<li><p>查看当前MySQL是否支持查询缓存</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'have_quert_cache'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/15/mysql/qc_1.png" alt="查看是否支持查询缓存"></p>
</li>
<li><p>查看当前MySQL是否开启查询缓存</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'query_cache_type;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/15/mysql/qc_2.png" alt="查看是否开启查询缓存"></p>
</li>
<li><p>查看当前MySQL查询缓存大小</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'query_cache_size'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/15/mysql/qc_3.png" alt="查看查询缓存大小"></p>
</li>
<li><p>查看查询缓存的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/15/mysql/qc_4.png" alt></p>
</li>
</ol>
<h4 id="开启查询缓存"><a href="#开启查询缓存" class="headerlink" title="开启查询缓存"></a>开启查询缓存</h4><p><code>query_cache_type</code>表示查询缓存的状态，默认是关闭的，可以设置查询缓存，打开<code>/etc/my.cnf</code>,添加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">query_cache_type=1</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/15/mysql/cache.png" alt></p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">OFF 或 0</td>
<td align="center">查询缓存功能关闭</td>
</tr>
<tr>
<td align="left">ON 或 1</td>
<td align="center">查询缓存功能开启，select的结果符合缓存条件则会缓存，否则，不会进行缓存；显示的指定SQL_NO_cache,不会进行缓存</td>
</tr>
<tr>
<td align="left">DEMAND 或 2</td>
<td align="center">查询缓存的功能按需进行，显式的指定SQL_CACHE的select才会缓存</td>
</tr>
</tbody></table>
<p>使用查询缓存和不使用查询缓存的时间差异:<br><img src="/2020/10/15/mysql/cache_2.png" alt></p>
<h4 id="查询缓存select选项"><a href="#查询缓存select选项" class="headerlink" title="查询缓存select选项"></a>查询缓存select选项</h4><p>可以在select语句中指定两个查询缓存相关的选项：</p>
<pre><code>* SQL_CACHE: 如果开启缓存，那么缓存执行结果
* SQL_NO_CACHE: 服务器不使用查询缓存，也不检查查询缓存的结果，忽略查询缓存</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select关于查询缓存的使用</span></span><br><span class="line"><span class="keyword">select</span> sql_no_cache <span class="keyword">count</span>(*) <span class="keyword">from</span> vote_record;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sql_cache</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> vote_record;</span><br></pre></td></tr></table></figure>

<h4 id="查询缓存失效的情况"><a href="#查询缓存失效的情况" class="headerlink" title="查询缓存失效的情况"></a>查询缓存失效的情况</h4><ol>
<li><p>SQL语句不一致的时候，想要命中缓存，查询语句必须一样</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 两次查询语句之间的语句不完全一致</span></span><br><span class="line">SQL1: <span class="keyword">select</span> <span class="keyword">sql_cache</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> vote_record;</span><br><span class="line">SQL2: <span class="keyword">Select</span> <span class="keyword">sql_cache</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> vote_record;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当查询语句中使用一些不确定的函数时，不会缓存</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不确定的函数，时间，用户，数据库，id，随机值</span></span><br><span class="line"><span class="comment">-- now(),current_date(),rand(),user(),uuid()</span></span><br><span class="line">SQL1: <span class="keyword">select</span> <span class="keyword">now</span>();</span><br><span class="line">SQL2: <span class="keyword">select</span> <span class="keyword">user</span>();</span><br><span class="line">SQL3: <span class="keyword">select</span> <span class="keyword">database</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>不使用任何的表查询语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'adadas'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询系统数据库时，mysql,information_schema,performance_schema，不使用缓存</p>
</li>
<li><p>在存储函数，过程，触发器内部的SQL语句不使用缓存</p>
</li>
<li><p>如果表更改，使用该表的所有高速缓存查询全部失效</p>
</li>
</ol>
<h2 id="MySQL内存管理及优化"><a href="#MySQL内存管理及优化" class="headerlink" title="MySQL内存管理及优化"></a>MySQL内存管理及优化</h2><h3 id="内存优化原则"><a href="#内存优化原则" class="headerlink" title="内存优化原则"></a>内存优化原则</h3><pre><code>1. 将尽量多的内存分配给MySQL做缓存，但是需要给操作系统和其他的软件预留足够的空间
2. 如果使用的存储引擎是MyISAM,需要预留更多的内存来给操作系统做IO缓存，MyISAM存储引擎的数据文件读取依赖操作系统的IO缓存
3. 排序区，连接区等缓存是直接分配给每个连接会话的，需要根据最大连接数按需分配，如果分配的空间过大，会直接导致物理内存耗尽</code></pre><h3 id="MyISAM内存优化"><a href="#MyISAM内存优化" class="headerlink" title="MyISAM内存优化"></a>MyISAM内存优化</h3><pre><code>* MyISAM存储引擎使用key_buffer缓存索引块，加速MyISAM索引块的读写速度。
* 对于MyISAM存储引擎的数据块，没有特别的缓存机制，需要依赖于操作系统的IO缓存</code></pre><p><strong>key_buffer_size</strong></p>
<p>索引缓存区的大小，直接影响MyISAM的存取效率，可以在<code>/etc/my.cnf</code>进行修改：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">key_buffer_size = 16M</span><br></pre></td></tr></table></figure>

<p><strong>read_buffer_size</strong></p>
<p>如果需要经常进行顺序扫描MyISAM表，可以增大读缓存大小，该缓存空间由每个会话独享，如果分配的太大，在高并发时，消耗大量的物理内存</p>
<p><strong>read_rnd_buffer_size</strong></p>
<p>对于需要做排序的MyISAM表，order by增加read_rnd_buffer_size可以改善性能，该缓存空间由每个会话独享，如果分配的太大，在高并发时，消耗大量的物理内存</p>
<h3 id="InnoDB内存优化"><a href="#InnoDB内存优化" class="headerlink" title="InnoDB内存优化"></a>InnoDB内存优化</h3><pre><code>* InnoDB使用一个内存区作为IO缓存池
* 该缓存池既缓存索引块，又缓存数据块</code></pre><p><strong>innodb_buffer_pool_size</strong></p>
<p>该变量决定InnoDB的缓存池的大小，值越大，缓存命中率越高，InnoDB需要的磁盘IO越少</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">innodb_buffer_pool_size=128M</span><br></pre></td></tr></table></figure>

<p><strong>innodb_log_buffer_size</strong></p>
<p>该变量决定InnoDB重做日志文件缓存的大小，对于可能产生大量更新记录的事务，增加大小，可以减少不必要的磁盘操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">innodb_log_buffer_size = 10M</span><br></pre></td></tr></table></figure>

<h2 id="MySQL并发参数优化"><a href="#MySQL并发参数优化" class="headerlink" title="MySQL并发参数优化"></a>MySQL并发参数优化</h2><h3 id="max-connections"><a href="#max-connections" class="headerlink" title="max_connections"></a>max_connections</h3><ol>
<li>max_connections控制允许连接到MySQL服务器端的最大连接数，默认151，如果已经达到最大连接数，再来的连接会处于等待状态。</li>
<li>可以通过变量connection_errors_max不为0，并且持续增长，可以说明有连接请求因为服务器达到最大连接数而失败</li>
<li>max_connections不能随便增大，需要考虑服务器的性能来进行提升</li>
</ol>
<h3 id="back-log"><a href="#back-log" class="headerlink" title="back_log"></a>back_log</h3><ol>
<li>back_log: 控制MySQL监听TCP端口时设置的积压请求栈大小，默认80，如果MySQL到达最大连接数，新来的连接请求会存放在积压请求栈中，等待其他的连接释放资源</li>
<li>如果积压请求数超过back_log,不会授予新的连接请求连接资源</li>
<li>如果数据库需要在较短的时间内处理大量的连接请求，可以考虑增加back_log</li>
</ol>
<h3 id="table-open-cahce"><a href="#table-open-cahce" class="headerlink" title="table_open_cahce"></a>table_open_cahce</h3><ol>
<li>该参数控制所有SQL语句执行线程可以打开表缓存的数量，而执行SQL语句时，每个执行语句至少打开一张表，默认2000</li>
<li>该值需要根据最大连接数max_connections以及每次执行关联查询涉及到的表进行设置</li>
</ol>
<h3 id="thread-cache-size"><a href="#thread-cache-size" class="headerlink" title="thread_cache_size"></a>thread_cache_size</h3><ol>
<li>为了加速连接数据库的速度，MySQL服务器缓存了一定的连接线程备用，连接线程池</li>
<li>可以控制连接线程的数量，默认8</li>
</ol>
<h3 id="innodb-lock-wait-timeout"><a href="#innodb-lock-wait-timeout" class="headerlink" title="innodb_lock_wait_timeout"></a>innodb_lock_wait_timeout</h3><ol>
<li>设置InnoDB事务等待行锁的时间，默认50ms</li>
<li>对于需要快速反应的业务系统，时间可以设置的较小，避免事务长时间挂起；对于时间要求比较低的批处理程序，可以将等待行锁增大，能避免发生大批量的回滚操作</li>
</ol>
<p><img src="/2020/10/15/mysql/memory_default.png" alt></p>
<h2 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h2><h3 id="锁的概述"><a href="#锁的概述" class="headerlink" title="锁的概述"></a>锁的概述</h3><pre><code>1. 锁，是计算机系统协调多个进行或者线程并发访问某一资源的机制，避免资源的争抢。
2. 在数据库中，除了传统资源的并发访问之外，数据表也是被许多用户共享的资源。
3. 保证数据并发访问的一致性，有效性，锁机制也是MySQL中比较重要的机制。</code></pre><h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><p><strong>操作粒度</strong></p>
<pre><code>1. 表锁：操作时，会锁定整张表
2. 行锁：操作时，只会锁定修改的那行数据</code></pre><p><strong>对数据操作的类型</strong></p>
<pre><code>1. 读锁(共享锁)：针对同一份数据，多个读操作可以同时进行不会相互影响
2. 写锁(排它锁)：当前操作没有完成之前，不允许其他的锁进行操作</code></pre><h3 id="MySQL锁-1"><a href="#MySQL锁-1" class="headerlink" title="MySQL锁"></a>MySQL锁</h3><pre><code>对于MySQL来说，不同的存储引擎具有不同的锁机制：
1. InnoDB默认支持行级锁
2. MyISAM默认支持表级锁</code></pre><p><strong>MySQL锁的特性</strong></p>
<table>
<thead>
<tr>
<th align="left">锁类型</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">表级锁</td>
<td align="left">偏向MyISAM存储引擎，开销小，加锁快；不会出现死锁；锁定的粒度大，并发低</td>
</tr>
<tr>
<td align="left">行级锁</td>
<td align="left">偏向InnoDB存储引擎，开销大，加锁慢；  会出现死锁；锁定的粒度小，并发高</td>
</tr>
<tr>
<td align="left">页面锁</td>
<td align="left">性能介于行级锁和表级锁之间</td>
</tr>
</tbody></table>
<pre><code>不同的锁类型具有不同的性质，需要根据情况具体选择</code></pre><h3 id="MyISAM锁"><a href="#MyISAM锁" class="headerlink" title="MyISAM锁"></a>MyISAM锁</h3><pre><code>MyISAM默认支持表锁，也只支持表锁</code></pre><h4 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h4><p>MyISAM在执行查询语句select之前，会自动给涉及到的表加读锁，在执行更新语句update之前，会自动给涉及到的表加写锁，这个过程不需要用户干预</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">加读锁：<span class="keyword">lock</span> <span class="keyword">table</span> table_name <span class="keyword">read</span>;</span><br><span class="line">加写锁：<span class="keyword">lock</span> <span class="keyword">table</span> table_name write;</span><br><span class="line">释放锁：<span class="keyword">unlock</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>

<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><pre><code>1. 读锁会阻塞写，不会阻塞读
2. 写锁会阻塞读，又会阻塞写

MyISAM存储引擎的写锁优先，拿到写锁之后，其他线程处于阻塞状态，如果存在大量的更新，查询难以执行，长时间的阻塞</code></pre><h4 id="查看锁的争用情况"><a href="#查看锁的争用情况" class="headerlink" title="查看锁的争用情况"></a>查看锁的争用情况</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 展示哪张表正在锁定</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 展示表锁的状态</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'table_%'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h3><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><pre><code>1. InnoDB存储引擎默认使用的是行锁，开销大，加锁慢
2. 会出现死锁
3. 锁定的粒度小，发生锁冲突的概率比较低，并发度高</code></pre><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p><strong>事务以及ACID属性</strong></p>
<pre><code>事务：一组SQL语句组成的逻辑处理单元，要么同时完成，要么同时失败</code></pre><table>
<thead>
<tr>
<th align="center">ACID属性</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">原子性(Atomicity)</td>
<td align="center">事务是一个原子操作，要么全部完成，要么全部失败</td>
</tr>
<tr>
<td align="center">一致性(Consistent)</td>
<td align="center">事务开始和结束时，数据保持一致</td>
</tr>
<tr>
<td align="center">隔离性 (Ioslation)</td>
<td align="center">数据库系统提供一定的隔离机制，事务不受外部并发操作影响独立运行</td>
</tr>
<tr>
<td align="center">持久性 (Durable)</td>
<td align="center">事务完成后，对数据的修改是永久的</td>
</tr>
</tbody></table>
<p><strong>并发事务带来的问题</strong></p>
<table>
<thead>
<tr>
<th align="center">问题</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">丢失更新（lost update）</td>
<td align="center">当两个或多个事务选择同一行，最初事务的修改，会被后面的事务修改覆盖</td>
</tr>
<tr>
<td align="center">脏读</td>
<td align="center">当一个事务正在访问数据，并且正在修改数据，但是修改还没有提交到数据库，另外的事务也访问了这个数据，然后使用这个数据</td>
</tr>
<tr>
<td align="center">不可重复读</td>
<td align="center">一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，两个数据不一致，数据值不一样</td>
</tr>
<tr>
<td align="center">幻读</td>
<td align="center">一个事务按照相同的查询条件从新读取以前访问的数据，发现其他事务插入了新的满足条件的记录，记录数不一样</td>
</tr>
</tbody></table>
<pre><code>不可重复读：主要强调的是修改
幻读: 主要强调的事务之间存在另外的事务进行数据插入，和删除</code></pre><p><strong>事务的隔离级别</strong></p>
<p>为了解决事务并发出现的问题，数据库提供了一定的事务隔离级别，事务隔离级别越高，并发的副作用越小，但是代价越大</p>
<p>事务的隔离级别：Read Uncommitted,Read Committed,Repeatabled Read,Serializable，四个隔离级别可以解决：更新丢失，脏读，不可重复读，幻读</p>
<p>数据库默认的隔离级别：Repeatabled Read，可重复读</p>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">丢失更新</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Read Uncommitted</td>
<td align="left">解决</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Read Committed</td>
<td align="left"></td>
<td align="center">解决</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Repeatabled Read</td>
<td align="left"></td>
<td align="center"></td>
<td align="center">解决</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Serializable</td>
<td align="left"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">解决</td>
</tr>
<tr>
<td align="left">解决的问题向下集成</td>
<td align="left"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>1. 查看数据库的隔离级别</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看事务的隔离级别</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'tx_isolation'</span>;</span><br></pre></td></tr></table></figure>

<h4 id="无索引行锁升级为表锁"><a href="#无索引行锁升级为表锁" class="headerlink" title="无索引行锁升级为表锁"></a>无索引行锁升级为表锁</h4><p>InnoDB的行锁作用于索引项，如果不通过索引条件进行查询，那么InnoDB将对表结构加锁，实际效果和表锁一致</p>
<pre><code>如果索引失效，那么行锁升级为表锁</code></pre><h4 id="InnoDB的间隙锁"><a href="#InnoDB的间隙锁" class="headerlink" title="InnoDB的间隙锁"></a>InnoDB的间隙锁</h4><p>当使用范围条件，而不是相对条件检索数据，并请求共享锁或排他锁，InnoDB会自动的给满足条件的已有数据加锁</p>
<p>对于键值在范围内，但是数据库中不存在的记录叫做间隙(GAP),InnoDB也会给这些间隙加速，这种锁机制就是<strong>间隙锁</strong></p>
<pre><code>如果处于间隙锁状态，在插入满足条件的数据时，会发生阻塞
可以缩小范围查询的条件，较少间隙的产生</code></pre><h4 id="InnoDB查看锁的状态"><a href="#InnoDB查看锁的状态" class="headerlink" title="InnoDB查看锁的状态"></a>InnoDB查看锁的状态</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'InnoDB_row_lock%'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/15/mysql/innodb_lock.png" alt></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>InnoDB存储引擎实现行级锁定，，虽然在锁定的过程中的开销比较大，但是在整体的并发处理上性能更加优越。</p>
<p>优化建议：</p>
<ul>
<li>尽可能让所有的检索都能通过索引来完成，避免行级锁升级为表级锁</li>
<li>合理涉及索引，尽量缩小锁的范围</li>
<li>尽量减少查询条件和范围，避免间隙锁</li>
<li>控制事务大小，减少锁定资源量和时间</li>
</ul>
<h2 id="常用MySQL技巧"><a href="#常用MySQL技巧" class="headerlink" title="常用MySQL技巧"></a>常用MySQL技巧</h2><h3 id="SQL语句的执行顺序"><a href="#SQL语句的执行顺序" class="headerlink" title="SQL语句的执行顺序"></a>SQL语句的执行顺序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sql语句的编写顺序</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span></span><br><span class="line">	&lt;<span class="keyword">select</span> <span class="keyword">list</span>&gt;</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">	&lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">	&lt;right_table&gt; <span class="keyword">on</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">	&lt;where_condition&gt;</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">	&lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">	&lt;having_condition&gt;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">	&lt;oeder_by_condition&gt;</span><br><span class="line"><span class="keyword">limit</span></span><br><span class="line">	&lt;limit_params&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sql的执行顺序</span></span><br><span class="line">from </span><br><span class="line">	&lt;left_table&gt;</span><br><span class="line">on </span><br><span class="line">	&lt;join_condition&gt;</span><br><span class="line">where </span><br><span class="line">	&lt;where_condition&gt;</span><br><span class="line">group by</span><br><span class="line">	&lt;group_by_list&gt;</span><br><span class="line">having</span><br><span class="line">	&lt;having_condition&gt;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span></span><br><span class="line">	&lt;<span class="keyword">select</span> <span class="keyword">list</span>&gt;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">	&lt;oeder_by_condition&gt;</span><br><span class="line"><span class="keyword">limit</span></span><br><span class="line">	&lt;limit_params&gt;</span><br></pre></td></tr></table></figure>

<h3 id="SQL语句的正则表达式"><a href="#SQL语句的正则表达式" class="headerlink" title="SQL语句的正则表达式"></a>SQL语句的正则表达式</h3><p>正则表达式(regular expression)：用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用正则表达式进行模糊匹配</span></span><br><span class="line"><span class="comment">-- 查询名称以 d开头的记录</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> city <span class="keyword">where</span> city_name regexp <span class="string">'^d'</span>;</span><br></pre></td></tr></table></figure>
<p>常用的正则表达式的符号以及含义：</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">在字符串开始处匹配</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">在字符串末尾处匹配</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意一个字符，包括换行符</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">匹配方括号内部的任意一个字符</td>
</tr>
<tr>
<td align="left">[^…]</td>
<td align="left">匹配除了方括号内部的字符</td>
</tr>
<tr>
<td align="left">a*</td>
<td align="left">匹配零个或多个a(包括空串)</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">匹配一个或多个a(不包括空串)</td>
</tr>
<tr>
<td align="left">a?</td>
<td align="left">匹配零个或一个a</td>
</tr>
<tr>
<td align="left">a1 a2</td>
<td align="left">匹配a1或a2</td>
</tr>
<tr>
<td align="left">a(m)</td>
<td align="left">匹配m个a</td>
</tr>
<tr>
<td align="left">a(m,)</td>
<td align="left">至少匹配m个a</td>
</tr>
<tr>
<td align="left">a(m,n)</td>
<td align="left">匹配m到n个a</td>
</tr>
<tr>
<td align="left">a(,n)</td>
<td align="left">匹配0到n个a</td>
</tr>
</tbody></table>
<h3 id="MySQL常用函数"><a href="#MySQL常用函数" class="headerlink" title="MySQL常用函数"></a>MySQL常用函数</h3><h4 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h4><table>
<thead>
<tr>
<th align="left">函数名称</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">abs</td>
<td align="left">绝对值</td>
</tr>
<tr>
<td align="left">aqrt</td>
<td align="left">二次方根</td>
</tr>
<tr>
<td align="left">mod</td>
<td align="left">求余数</td>
</tr>
<tr>
<td align="left">ceil</td>
<td align="left">向上取整</td>
</tr>
<tr>
<td align="left">floor</td>
<td align="left">向下取整</td>
</tr>
<tr>
<td align="left">rand</td>
<td align="left">0-1的随机数</td>
</tr>
<tr>
<td align="left">round</td>
<td align="left">对参数四舍五入</td>
</tr>
<tr>
<td align="left">sign</td>
<td align="left">符号</td>
</tr>
<tr>
<td align="left">pow</td>
<td align="left">平方</td>
</tr>
<tr>
<td align="left">三角函数</td>
<td align="left">sin tan cos acos..</td>
</tr>
</tbody></table>
<h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><table>
<thead>
<tr>
<th align="left">函数名称</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">length</td>
<td align="left">字符串长度</td>
</tr>
<tr>
<td align="left">contat</td>
<td align="left">字符串拼接</td>
</tr>
<tr>
<td align="left">lower</td>
<td align="left">字符串转为小写</td>
</tr>
<tr>
<td align="left">upper</td>
<td align="left">字符串转为大写</td>
</tr>
<tr>
<td align="left">left</td>
<td align="left">从左侧截取字符串，返回若干个字符</td>
</tr>
<tr>
<td align="left">right</td>
<td align="left">从右侧截取字符串，返回若干个字符</td>
</tr>
<tr>
<td align="left">trim</td>
<td align="left">删除字符串左右两边的空格</td>
</tr>
<tr>
<td align="left">reverse</td>
<td align="left">转置字符串</td>
</tr>
<tr>
<td align="left">sunstring</td>
<td align="left">侧截取字符串,从哪开始的m个字符串，序列从1开始</td>
</tr>
</tbody></table>
<h4 id="日期函数和聚合函数"><a href="#日期函数和聚合函数" class="headerlink" title="日期函数和聚合函数"></a>日期函数和聚合函数</h4><pre><code>日期函数：
    返回日期，current_time,current_date,now...</code></pre><table>
<thead>
<tr>
<th align="left">聚合函数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">max</td>
<td align="left">最大值</td>
</tr>
<tr>
<td align="left">min</td>
<td align="left">最小值</td>
</tr>
<tr>
<td align="left">count</td>
<td align="left">数量</td>
</tr>
<tr>
<td align="left">sum</td>
<td align="left">总数</td>
</tr>
<tr>
<td align="left">avg</td>
<td align="left">平均数</td>
</tr>
</tbody></table>
<h2 id="MySQL工具"><a href="#MySQL工具" class="headerlink" title="MySQL工具"></a>MySQL工具</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>这里的mysql不是指mysql服务，而是连接数据库的客户端工具</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql [options] [database]</span><br><span class="line">mysql -h 主机ip -P 端口号 -u 数据库用户名 -p 登录密码</span><br><span class="line"><span class="comment">-- 1. 登录本机</span></span><br><span class="line">mysql -uroot -proot</span><br><span class="line"><span class="comment">-- 2. 远程连接</span></span><br><span class="line">mysql -h 192.168.148.129 -P 3306 -u root -p</span><br></pre></td></tr></table></figure>

<h4 id="连接选项"><a href="#连接选项" class="headerlink" title="连接选项"></a>连接选项</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">参数：</span><br><span class="line">	-u,<span class="comment">--user=name 				指定用户名</span></span><br><span class="line">	-p,<span class="comment">--password[=name]		指定密码</span></span><br><span class="line">	-h,<span class="comment">--host=name				指定主机</span></span><br><span class="line">	-P,<span class="comment">--port=#					指定端口号</span></span><br><span class="line">参数的赋值可以使用=,也可以使用空格和之间后面加上</span><br></pre></td></tr></table></figure>

<h4 id="执行选项"><a href="#执行选项" class="headerlink" title="执行选项"></a>执行选项</h4><p>-e,–execute=name        执行语句并退出<br>一般在脚本语句上使用</p>
<h3 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a>mysqlbinlog</h3><p>用于服务器生成的二进制日志以二进制格式保存，如果想要查看日志文件，需要使用mysqlbinlog查看</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法</span></span><br><span class="line">mysqlbinlog [options] log_file1,log_file2</span><br><span class="line"><span class="comment">-- 选项</span></span><br><span class="line">	-d,<span class="comment">--database=name   		指定数据库的名称，只列出指定的数据库相关操作</span></span><br><span class="line">	-o,<span class="comment">--offset=#				忽略日志的前N行数据</span></span><br><span class="line">	-r,<span class="comment">--result-file=name		将文本日志输出到指定文件</span></span><br><span class="line">	-s,<span class="comment">--short-form				显示简单格式</span></span><br><span class="line">	<span class="comment">--start-datetime=date1	--end-datetime=date2 :日期间隔的所有日志</span></span><br><span class="line">	<span class="comment">--start-position=pos1 --end-position=pos2		指定位置间隔内的所有日志</span></span><br></pre></td></tr></table></figure>

<h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>mysqldump用来备份数据库或者在不同的数据库之间进行数据迁移。备份的内容包括创建表，以及插入表的SQL语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 备份指定数据库的指定表</span></span><br><span class="line">mysqldump [options] da_name [tables];</span><br><span class="line"><span class="comment">-- 备份所有的表</span></span><br><span class="line">mysqldump [options] <span class="comment">--all-databases/-A;</span></span><br></pre></td></tr></table></figure>

<h4 id="连接选项-1"><a href="#连接选项-1" class="headerlink" title="连接选项"></a>连接选项</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">-u,<span class="comment">--username=name			用户名</span></span><br><span class="line">-p,<span class="comment">--password=name			密码</span></span><br><span class="line">-h,<span class="comment">--host=name 				主机</span></span><br><span class="line">-P,<span class="comment">--port					端口号</span></span><br></pre></td></tr></table></figure>

<h4 id="输出内容选项"><a href="#输出内容选项" class="headerlink" title="输出内容选项"></a>输出内容选项</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 参数：</span></span><br><span class="line">	<span class="comment">--add-drop-database		在每个数据库创建语句之前加上drop database语句</span></span><br><span class="line">	<span class="comment">--add-drop-table		在每个数据表创建语句之前加上drop table语句，默认开启</span></span><br><span class="line">	-n,<span class="comment">--no-create-db		不包含创建数据库的语句</span></span><br><span class="line">	-t,<span class="comment">--no-create-info		不包含数据表的语句</span></span><br><span class="line">	-d,<span class="comment">--no-data			不包含数据</span></span><br><span class="line">	-T,<span class="comment">--tab=name			自动生成两个文件，指定目录，一个.sql文件，创建表结构的语句</span></span><br><span class="line">											一个.txt文件，数据文件</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 备份test数据库的city表到city.sql文件</span></span><br><span class="line">mysqldump -uroot -proot test city &gt; city.sql</span><br><span class="line"><span class="comment">-- 查看文件</span></span><br><span class="line">ll</span><br><span class="line">cat city.sql</span><br></pre></td></tr></table></figure>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>在备份数据文件之前，会使用<code>lock table city write</code>禁止数据库数据更新</p>
<h3 id="mysqlimport"><a href="#mysqlimport" class="headerlink" title="mysqlimport"></a>mysqlimport</h3><p>客户端数据导入的工具，用来导入mysqldump -T输出的文本文件,即.txt文件<br>语法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlimport [options] db_name textfile1 [textfile2]</span><br><span class="line">含义：将文件导入到数据库db_name中</span><br><span class="line">options:</span><br><span class="line">	连接选项，-u -p -h -P</span><br></pre></td></tr></table></figure>

<p>导入sql文件,使用mysql下的source命令</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; source /root/city.sql</span><br></pre></td></tr></table></figure>

<h3 id="mysqlshow"><a href="#mysqlshow" class="headerlink" title="mysqlshow"></a>mysqlshow</h3><p>MySQL客户端对象查找工具，快速查找到有哪些数据库，数据库中的表，表中的记录数<br>语法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlshow [options] [db_name [table_name [col_name]]]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--count 			显示数据库的统计信息，数据库，表均可以不指定</span></span><br><span class="line">-i					显示指定的数据库或者表的状态信息</span><br></pre></td></tr></table></figure>

<h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><p>数据库中的日志保存数据库工作过程中的细节，帮助数据库管理员来追踪数据库曾经发生过的问题。MySQL数据库中保存四种日志，错误日志，二进制日志，查询日志和慢查询日志</p>
<h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>MySQL数据库的错误信息记录，在数据库服务器启动和停止时，以及在数据库的运行期间的发生的任何严重错误时的相关信息。在数据库出现故障无法使用的时候，可以首先查看数据库错误日志。</p>
<p>数据库错误日志默认开启，默认存放路径<code>/var/log/mysql/error.log</code></p>
<p>查看错误日志的位置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'log_error%'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/15/mysql/err_1.png" alt="错误日志"><br><img src="/2020/10/15/mysql/err_2.png" alt="错误日志"></p>
<h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>二进制日志,binlog记录了所有的数据库DDL语句，DML语句，但是不包含数据库查询语句。对于数据恢复具有重要意义，MySQL的主从复制，就是基于binlog日志实现的。</p>
<p>二进制日志，默认没有开启，需要在mysql的配置文件中配置，并配置二进制日志的格式。<br>配置文件存放的位置：<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code></p>
<p>配置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 配置二进制日志</span></span><br><span class="line">log_bin=mysqlbin</span><br><span class="line"><span class="comment">-- 配置日志格式：以SQL语句的格式存储日志</span></span><br><span class="line">binlog_format=STAMEMENT</span><br></pre></td></tr></table></figure>

<h4 id="二进制日志格式"><a href="#二进制日志格式" class="headerlink" title="二进制日志格式"></a>二进制日志格式</h4><p><strong>STATEMENT</strong><br>在日志文件中保存的是SQL语句，每一条数据进行修改的SQL语句都会记录在日志文件中，通过MySQL提供的mysqlbinlog工具，可以查看每条语句的文本。MySQL主从复制的时候，从库（slove）会解析日志，并重新执行一次。<br>mysqlbinlog filename：查看日志文件</p>
<p><strong>ROW</strong><br>在日志文件中保存的是每一行的记录变更，而不是记录的SQL语句，每一行数据变更都会记录在日志文件中。<br>mysqlbinlog -vv filename</p>
<p><strong>MIXED</strong><br>MySQL默认的日志文件格式，结合了STATEMENT和ROW的优点，默认采用STATEMENT,SQL语句，特殊情况下使用ROW。</p>
<h4 id="日志的删除"><a href="#日志的删除" class="headerlink" title="日志的删除"></a>日志的删除</h4><p>防止占用大量的磁盘空间，定期清除日志文件</p>
<p><strong>方式一</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reset</span> <span class="keyword">master</span></span><br></pre></td></tr></table></figure>

<p>清除日志文件，日志编号从000001开始从新进行日志记录</p>
<p><strong>方式二</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">purge</span> <span class="keyword">master</span> <span class="keyword">logs</span> <span class="keyword">to</span> <span class="string">'mysqlbin.******'</span>;</span><br><span class="line"><span class="comment">-- 删除******之前的所有日志文件</span></span><br></pre></td></tr></table></figure>

<p><strong>方式三</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">purge</span> <span class="keyword">master</span> <span class="keyword">logs</span> <span class="keyword">before</span> <span class="string">'yyyy-mm-dd hh24:mi:ss'</span>;</span><br><span class="line"><span class="comment">-- 删除指定日期之前的所有日志文件</span></span><br></pre></td></tr></table></figure>

<p><strong>方式四</strong></p>
<p>设置参数<code>--expies_logs_days=#</code>,设置日志的过期时间，到了指定的日期，会自动删除日志</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 日志文件三天到期</span></span><br><span class="line">log_bin=mysqlbin</span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment">--expire_logs_days=3</span></span><br></pre></td></tr></table></figure>

<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志记录客户端的所有操作语句，而二进制日志不包含查询语句<br>默认情况下，查询日志是开启的，<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>进行设置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'general_log%'</span>;</span><br><span class="line"><span class="comment">-- 配置查询日志</span></span><br><span class="line">general_log_file        = /var/log/mysql/mysql.log</span><br><span class="line">general_log             = 1</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/15/mysql/general_log.png" alt> </p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录所有执行时间超过<code>long_query_time</code>设置值并且扫描行数不小于<code>min_examined_row_limit</code>的所有的SQL语句,<br>管理语句和不使用索引的SQL语句不会记录在慢查询日志中</p>
<p>管理语句：ALTER TABLE ,CREATE INDEX ,DROP INDEX,</p>
<h4 id="文件位置和格式"><a href="#文件位置和格式" class="headerlink" title="文件位置和格式"></a>文件位置和格式</h4><p>慢查询日志配置默认是关闭的，需要配置<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开启慢查询日志</span></span><br><span class="line">slow_query_log = 1		开启慢查询日志</span><br><span class="line"><span class="comment">-- 日志文件的位置</span></span><br><span class="line">slow_query_log_file	= /var/log/mysql/mysql-slow.log</span><br><span class="line"><span class="comment">-- 慢查询默认时间,</span></span><br><span class="line">long_query_time = 10</span><br></pre></td></tr></table></figure>

<h2 id="MySQL复制"><a href="#MySQL复制" class="headerlink" title="MySQL复制"></a>MySQL复制</h2><h3 id="复制概述"><a href="#复制概述" class="headerlink" title="复制概述"></a>复制概述</h3><p>复制是指将主数据库的DDL和DML操作通过二进制日志的方式传到从数据库中，然后在这些从数据库中重新执行这些日志，从而使得从库和主数据库的数据保持同步。<br>MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为别的从库的主库，进行链式复制。   </p>
<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><p>主从复制基于binlog来进行复制的</p>
<pre><code>1. Master主库在事务提交的时候，会把数据变更作为时间Events记录在二进制日志binlog中
2. 主库推送二进制文件binlog中的日志事件到从库的中继日志relay log中
3. 从库重做中继日志的事件，将变化反映在自己的数据库中</code></pre><h3 id="复制优势"><a href="#复制优势" class="headerlink" title="复制优势"></a>复制优势</h3><pre><code>1. 主库出现问题，可以快速切换到从库进行处理
2. 主从复制，读写分离，主库执行更新，从库执行查询，降低数据库压力
3. 可以在从库中执行备份，避免备份过程影响主库的服务</code></pre><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><p><strong>主节点配置</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- mysql 服务ID, 整个集群中唯一</span></span><br><span class="line">server-id = 1</span><br><span class="line"><span class="comment">-- binlog日志存储路径</span></span><br><span class="line">log-bin = /var/lib/mysql/mysqlbin</span><br><span class="line"><span class="comment">-- 错误日志 默认开启</span></span><br><span class="line"><span class="comment">-- log-err</span></span><br><span class="line"><span class="comment">-- 是否只读 0 表示读写 1 表示只读</span></span><br><span class="line">read-only = 0</span><br><span class="line"><span class="comment">-- 忽略的数据，不需要进行同步的数据库</span></span><br><span class="line">binlog-ignore-db = mysql</span><br><span class="line"><span class="comment">-- 指定同步的数据库</span></span><br><span class="line"><span class="comment">-- binlog-do-db = test</span></span><br></pre></td></tr></table></figure>

<p><strong>配置服务</strong></p>
<p>执行完主库的配置后，重启mysql服务<code>service mysql restart</code></p>
<p><strong>创建同步数据账户，进行授权</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建账户mytest 在所有的数据库所有的表上 密码root </span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'mytest'</span>@<span class="string">'192.168.148.128'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'root'</span>;</span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>

<h4 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h4><p><strong>配置文件</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- mysql 服务ID, 整个集群中唯一</span></span><br><span class="line">server-id = 2</span><br><span class="line"><span class="comment">-- binlog日志存储路径</span></span><br><span class="line">log-bin = /var/lib/mysql/mysqlbin</span><br></pre></td></tr></table></figure>

<p><strong>配置服务</strong></p>
<p>执行完主库的配置后，重启mysql服务<code>service mysql restart</code></p>
<p><strong>配置同步主库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 指定当前从库对应的主库的IP地址，用户名，密码，从哪个日志文件的哪个位置开始</span></span><br><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">'192.168.148.129'</span>,master_name=<span class="string">'mytest'</span>,master_password=<span class="string">'root'</span>,master_log_file=<span class="string">'日志文件'</span>,master_log_pos=<span class="string">'同步开始位置'</span>；</span><br></pre></td></tr></table></figure>

<p><strong>开启同步</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开始同步</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br><span class="line"><span class="comment">-- 查看从库状态</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>\G;</span><br></pre></td></tr></table></figure>

<p><strong>停止同步</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>

<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="delete-drop-truncate"><a href="#delete-drop-truncate" class="headerlink" title="delete,drop,truncate"></a>delete,drop,truncate</h3><p>一、delete</p>
<p>1、<code>delete</code>是DML，执行delete操作时，每次从表中删除一行，并且同时将该行的的删除操作记录在redo和undo表空间中以便进行回滚（<code>rollback</code>）和重做操作，但要注意表空间要足够大，需要手动提交（<code>commit</code>）操作才能生效，可以通过<code>rollback</code>撤消操作。</p>
<p>2、delete可根据条件删除表中满足条件的数据，如果不指定where子句，那么删除表中所有记录。</p>
<p>3、delete语句不影响表所占用的extent，高水线(high watermark)保持原位置不变。表和索引所占用的空间不会恢复，保持原状。</p>
<p>二、truncate</p>
<p>1、truncate是DDL，会隐式提交，所以，不能回滚，不会触发触发器。</p>
<p>2、truncate会删除表中所有记录，并且将重新设置高水线和所有的索引，缺省情况下将空间释放到<code>minextents</code>个<code>extent</code>，除非使用<code>reuse storage</code>。不会记录日志，所以执行速度很快，但不能通过rollback撤消操作（如果一不小心把一个表truncate掉，也是可以恢复的，只是不能通过rollback来恢复）。</p>
<p>3、对于外键（<code>foreign key</code>）约束引用的表，不能使用<code>truncate table</code>，而应使用不带<code>where</code> 子句的<code>delete</code>语句。</p>
<p>4、<code>truncate table</code>不能用于参与了索引视图的表,作用范围只局限于<code>table</code>级别。</p>
<p>三、drop</p>
<p>1、drop是DDL，会隐式提交，所以，不能回滚，不会触发触发器。</p>
<p>2、drop语句删除表结构及所有数据，并将表所占用的空间全部释放。</p>
<p>3、drop语句将删除表的结构所依赖的约束，触发器，索引，依赖于该表的存储过程/函数将保留,但是变为<code>invalid</code>状态。</p>
<p>1、在速度上，一般来说，drop&gt; truncate &gt; delete。</p>
<p>2、在使用drop和truncate时一定要注意，虽然可以恢复，但为了减少麻烦，还是要慎重。</p>
<p>3、如果想删除部分数据用delete，注意带上where子句，回滚段要足够大；</p>
<p>   如果想删除表，当然用drop； </p>
<p>   如果想保留表而将所有数据删除，如果和事务无关，用truncate即可；</p>
<p>   如果和事务有关，或者想触发trigger，还是用delete；</p>
<p>4、<code>truncate table</code>在功能上与不带<code>WHERE</code>子句的<code>DELETE</code>语句相同：二者均删除表中的全部行。但<code>TRUNCATE TABLE</code>比<code>DELETE</code>速度快，且使用的系统和事务日志资源少。<code>DELETE</code>语句每次删除一行，并在事务日志中为所删除的每行记录一项。<code>TRUNCATE TABLE</code>通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 </p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 优化</title>
    <url>/2020/05/18/Hexo%20%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="Hexo-next自适应宽屏"><a href="#Hexo-next自适应宽屏" class="headerlink" title="Hexo next自适应宽屏"></a>Hexo next自适应宽屏</h2><p><code>/themes/next/source/css/_schemes/Picses/_layout.styl</code>在文件末尾添加代码<br><code>// 以下为新增代码！！修改post宽度</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">header&#123;</span> <span class="attr">width:</span> <span class="number">80</span><span class="string">%</span> <span class="type">!important</span><span class="string">;</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">header.post-header</span> <span class="string">&#123;</span></span><br><span class="line"> 		<span class="attr">width:</span> <span class="string">auto</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">	<span class="string">&#125;</span></span><br><span class="line"><span class="string">.container</span> <span class="string">.main-inner</span> <span class="string">&#123;</span> <span class="attr">width:</span> <span class="number">80</span><span class="string">%;</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">.content-wrap</span> <span class="string">&#123;</span> <span class="attr">width:</span> <span class="string">calc(100%</span> <span class="bullet">-</span> <span class="string">260px);</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">.header</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">+tablet()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="string">auto</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">+mobile()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="string">auto</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">.container</span> <span class="string">.main-inner</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">+tablet()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="string">auto</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">+mobile()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="string">auto</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">.content-wrap</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">+tablet()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">100</span><span class="string">%</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">+mobile()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">100</span><span class="string">%</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="顶部进度条"><a href="#顶部进度条" class="headerlink" title="顶部进度条"></a>顶部进度条</h2><pre><code>1. 在主题的配置文件中，找到pace:标签，可以开启进度条的设置
2. pace_theme: pace-theme-flash：具体的样式</code></pre><p><a href="https://blog.csdn.net/u011236348/article/details/88146947" target="_blank" rel="noopener">进度条参考博客地址</a></p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>在<code>themes/*/source/css/_custom/custom.styl</code>中添加代码<br>`</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Zitiming;</span><br><span class="line">    src: url('/fonts/Zitiming.ttf');</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.site-title</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">40px</span> !important;</span><br><span class="line">	<span class="attribute">font-family</span>: <span class="string">'Zitiming'</span> !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中字体文件在 <code>themes/next/source/fonts</code> 目录下，里面有个 <code>.gitkeep</code>的隐藏文件，打开写入你要保留的字体文件，比如我的是就是写入 <code>Zitiming.ttf</code>，具体字库自己从网上下载即可</p>
<h2 id="设置网站缩略图标"><a href="#设置网站缩略图标" class="headerlink" title="设置网站缩略图标"></a>设置网站缩略图标</h2><p>把你的图片（png或jpg格式，不是favicon.ico）放在<code>themes/next/source/images</code>里，然后打开 主题配置文件 找到<code>favicon</code>，将<code>small、medium、apple_touch_icon</code>三个字段的值都设置成<code>/images/图片名.jpg</code>就可以了，其他字段都注释掉</p>
<h2 id="静态资源压缩"><a href="#静态资源压缩" class="headerlink" title="静态资源压缩"></a>静态资源压缩</h2><pre><code>参考文档：</code></pre><ul>
<li><a href="https://maplerain.cc/posts/69416b20.html" target="_blank" rel="noopener">静态资源压缩</a></li>
<li><a href="https://blog.csdn.net/guang_s/article/details/84751813" target="_blank" rel="noopener">cache的使用</a></li>
<li><a href="https://wiki.zthxxx.me/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/gulp-imagemin-%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener">imagemin参数设置</a></li>
</ul>
<h3 id="gulp-imagemin中的默认组件无法加载"><a href="#gulp-imagemin中的默认组件无法加载" class="headerlink" title="gulp-imagemin中的默认组件无法加载"></a>gulp-imagemin中的默认组件无法加载</h3><pre><code>1. 卸载原来的版本</code></pre><p><code>npm uninstall gulp-imagemin --save-dev</code></p>
<pre><code>2. 安装cnpm</code></pre><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<pre><code>3. 重新安装gulp-imagemin</code></pre><p><code>cnpm install gulp-imagemin --save-dev</code></p>
<pre><code>4. --save-dev的含义</code></pre><p>保存配置信息至<code>package.json</code>的<code>devDependencies</code>节点</p>
<h3 id="gulp-imagemin使用缓存cache"><a href="#gulp-imagemin使用缓存cache" class="headerlink" title="gulp-imagemin使用缓存cache"></a>gulp-imagemin使用缓存cache</h3><pre><code>由于图片压缩的速度太过于缓慢，而且每次重新部署的时候都需要进行压缩，时间浪费太严重，可以使用cache进行缓解这种现象
1. 安装gulp-cache插件</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cnpm install gulp-imagemin --save-dev</span><br></pre></td></tr></table></figure>

<pre><code>2. gulpfile.js的编写</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cache=request(<span class="string">"gulp-cache"</span>);</span><br><span class="line">gulp.task(<span class="string">'minify-img'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.*'</span>)</span><br><span class="line">        .pipe(cache(imagemin(&#123;</span><br><span class="line">            optimizationLevel: <span class="number">5</span>, <span class="comment">// 取值范围：0-7（优化等级），默认：3  </span></span><br><span class="line">            progressive: <span class="literal">true</span>,  <span class="comment">// 无损压缩jpg图片，默认：false </span></span><br><span class="line">            interlaced: <span class="literal">true</span>,   <span class="comment">// 隔行扫描gif进行渲染，默认：false </span></span><br><span class="line">            multipass: <span class="literal">true</span>         <span class="comment">// 多次优化svg直到完全优化，默认：false </span></span><br><span class="line">        &#125;)))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<pre><code>3. 清理cache</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'cleanCache'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.clearAll(done);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="imagemin-pngquant深度压缩png图片"><a href="#imagemin-pngquant深度压缩png图片" class="headerlink" title="imagemin-pngquant深度压缩png图片"></a>imagemin-pngquant深度压缩png图片</h3><pre><code>1. 安装imagemin-pngquant插件</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cnpm install pngquant --save-dev</span><br></pre></td></tr></table></figure>

<pre><code>2. gulpfile.js</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp=request(<span class="string">"gulp"</span>);</span><br><span class="line"><span class="keyword">var</span> pngquant=request(<span class="string">"imagemin-pngquant"</span>);</span><br><span class="line">gulp.task(<span class="string">'testImagemin'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	gulp.src(<span class="string">'src/img/*.*'</span>)</span><br><span class="line">    	.pipe(imagemin(&#123;</span><br><span class="line">        	progressive: <span class="literal">true</span>, <span class="comment">//类型：Boolean 默认：false 无损压缩jpg图片</span></span><br><span class="line">        	use: [pngquant()] <span class="comment">//使用pngquant深度压缩png图片的imagemin插件</span></span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'dist/img'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<pre><code>3. 使用
    1. 可以在命令行下使用：gulp testImagemin
    2. 创建新的执行脚本，里面包含 testImagemin</code></pre><h2 id="更新时间"><a href="#更新时间" class="headerlink" title="更新时间"></a>更新时间</h2><p>在主题的配置文件下，使用<code>update</code>会找到一个<code>updated_at</code>的属性改为<code>true</code>即可。</p>
<h2 id="代码显示"><a href="#代码显示" class="headerlink" title="代码显示"></a>代码显示</h2><p>在hexo的根目录下，<code>_config.yml</code>中的<code>auto_detect: false</code>改为true<br>在hexo的主题目录下，<code>_config.yml</code>中的<code>auto_detect: false</code>改为true</p>
<p><code>highlight_theme: night eighties</code>,指定代码主题的样式</p>
<h2 id="增加代码复制功能"><a href="#增加代码复制功能" class="headerlink" title="增加代码复制功能"></a>增加代码复制功能</h2><pre><code>参考文件地址：</code></pre><ul>
<li><a href="https://blog.csdn.net/Awt_FuDongLai/article/details/107466848" target="_blank" rel="noopener">代码复制</a></li>
</ul>
<h2 id="隐藏网页底部powered-By-Hexo-强力驱动"><a href="#隐藏网页底部powered-By-Hexo-强力驱动" class="headerlink" title="隐藏网页底部powered By Hexo / 强力驱动"></a>隐藏网页底部powered By Hexo / 强力驱动</h2><p>打开<code>themes/next/layout/_partials/footer.swig</code>,隐藏驱动之间的代码即可，或者直接删除。</p>
<h2 id="底部显示错误"><a href="#底部显示错误" class="headerlink" title="底部显示错误"></a>底部显示<i class="fa fa-angle-right"></i>错误</h2><p>更改<code>\themes\next\layout\_partials\pagination.swig</code>中的代码，将paginator()的代码改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">paginator(&#123;</span><br><span class="line">  prev_text: <span class="string">'&lt;i class="fa fa-hand-o-left" aria-label="'</span> + __(<span class="string">'accessibility.prev_page'</span>) + <span class="string">'"&gt;&lt;/i&gt;'</span>,</span><br><span class="line">  next_text: <span class="string">'&lt;i class="fa fa-hand-o-right" aria-label="'</span> + __(<span class="string">'accessibility.next_page'</span>) + <span class="string">'"&gt;&lt;/i&gt;'</span>,</span><br><span class="line">  mid_size : <span class="number">1</span>,</span><br><span class="line">  <span class="built_in">escape</span>   : <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="增加雪花特效"><a href="#增加雪花特效" class="headerlink" title="增加雪花特效"></a>增加雪花特效</h2><pre><code>已经配置完成，在样式配置文件中打开配置就行了</code></pre><p>在<code>\themes\next\layout\_layout.swig</code>文件引用</p>
<ul>
<li><a href="https://blog.csdn.net/stormdony/article/details/86001618" target="_blank" rel="noopener">雪花特效</a></li>
</ul>
<h2 id="引入背景图片"><a href="#引入背景图片" class="headerlink" title="引入背景图片"></a>引入背景图片</h2><p>打开文档下<code>themes\next\source\css\ _custom\custom.sty</code>l文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(https:<span class="comment">//source.unsplash.com/random/1600x900);</span></span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:<span class="number">50</span>% <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加不蒜子统计-可惜在本博客无法使用，不知道为什么"><a href="#增加不蒜子统计-可惜在本博客无法使用，不知道为什么" class="headerlink" title="增加不蒜子统计: 可惜在本博客无法使用，不知道为什么"></a>增加不蒜子统计: 可惜在本博客无法使用，不知道为什么</h2><pre><code>1. 修改代码文件</code></pre><p>先将busuanzi的脚本文件下载到本地<code>themes/next/source/js/src/</code>下，保存为<code>busuanzi.pure.mini.js</code>,修改文件<code>themes/next/layout/_third-party/analytics/busuanzi-counter.swig</code>中的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"> # 将其改为</span><br><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"/js/src/busuanzi.pure.mini.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<pre><code>2. 修改配置文件_config.yml</code></pre><p>在<code>themes/next/_config.yml</code>主题配置文件，搜索关键字<code>busuanzi_count</code>,将enable的值改为true,并对站点UV配置、站点PV配置、单页面PV进行配置。如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_uv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-user"&gt;本站访客数&lt;/i&gt;</span></span><br><span class="line">  <span class="string">site_uv_footer:人次</span></span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-eye"&gt;本站总访问量&lt;/i&gt;</span></span><br><span class="line">  <span class="string">site_pv_footer:次</span></span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-file-o"&gt;本文总阅读量&lt;/i&gt;</span></span><br><span class="line">  <span class="string">page_pv_footer:次</span></span><br></pre></td></tr></table></figure>

<h2 id="Hexo表格优化"><a href="#Hexo表格优化" class="headerlink" title="Hexo表格优化"></a>Hexo表格优化</h2><p>在使用Hexo表格的时候，不太满意，这里对Hexo的表格样式进行改进:修改CSS文件，<code>themes\next\source\css\_custom\custom.styl</code></p>
<p><strong>基本样式</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 基本样式</span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; <span class="comment">/*表格宽度*/</span></span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">65em</span>; <span class="comment">/*表格最大宽度，避免表格过宽*/</span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#dedede</span>; <span class="comment">/*表格外边框设置*/</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span> auto; <span class="comment">/*外边距*/</span></span><br><span class="line">    <span class="attribute">border-collapse</span>: collapse; <span class="comment">/*使用单一线条的边框*/</span></span><br><span class="line">    <span class="attribute">empty-cells</span>: show; <span class="comment">/*单元格无内容依旧绘制边框*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">th</span>,<span class="selector-tag">table</span> <span class="selector-tag">td</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">35px</span>; <span class="comment">/*统一每一行的默认高度*/</span></span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#dedede</span>; <span class="comment">/*内部边框样式*/</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>; <span class="comment">/*内边距*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>表头</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 表头</span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">th</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold; <span class="comment">/*加粗*/</span></span><br><span class="line">    <span class="attribute">text-align</span>: center <span class="meta">!important</span>; <span class="comment">/*内容居中，加上 !important 避免被 Markdown 样式覆盖*/</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(158,188,226,0.2); <span class="comment">/*背景色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>隔行变色</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tbody</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(2n)</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(158,188,226,0.12); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>悬浮变色</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#efefef</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>表头不换行</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">th</span> &#123;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap; <span class="comment">/*表头内容强制在一行显示*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>首列不换行</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">td</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>列宽问题</strong><br>    基本上，Hexo表格的样式还是可以的，但是列宽平分，让人难受，暂时没有找到解决方法</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>1819-password-does-not-satisfy</title>
    <url>/2020/10/28/pwd_not_safe/</url>
    <content><![CDATA[<h2 id="ERROR-1819-HY000-Your-password-does-not-satisfy-the-current-policy-requirements"><a href="#ERROR-1819-HY000-Your-password-does-not-satisfy-the-current-policy-requirements" class="headerlink" title="ERROR 1819 (HY000): Your password does not satisfy the current policy requirements"></a>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>在更改MySQL数据库的密码时，出现这个问题，这是因为设置的密码过于简单，MySQL中对于密码 的设置具有限制</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> authentication_string=<span class="keyword">PASSWORD</span>(<span class="string">'root'</span>) <span class="keyword">where</span> <span class="keyword">USER</span>=<span class="string">'root'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</span><br></pre></td></tr></table></figure>

<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><pre><code>1. 更改MySQL中对于密码设置的限制</code></pre><p>密码的长度是由<code>validate_password_length</code>决定的,但是可以通过以下命令修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p><code>validate_password_policy</code>决定密码的验证策略,默认等级为<code>MEDIUM</code>(中等),可通过以下命令修改为<code>LOW</code>(低)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>修改完成后密码就可以设置的很简单，比如1234之类的。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>MySQL</category>
        <category>Error</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>1524-plugin-not-load</title>
    <url>/2020/10/28/plugin_not_load/</url>
    <content><![CDATA[<h2 id="ERROR-1524-HY000-Plugin-‘msyql-native-password’-is-not-loaded"><a href="#ERROR-1524-HY000-Plugin-‘msyql-native-password’-is-not-loaded" class="headerlink" title="ERROR 1524 (HY000): Plugin ‘msyql_native_password’ is not loaded"></a>ERROR 1524 (HY000): Plugin ‘msyql_native_password’ is not loaded</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>在登录MySQL本地服务器的时候，出现上面的问题</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">zhaolong@zl-vm:~$ sudo mysql -uroot -proot</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">ERROR 1524 (HY000): Plugin 'msyql_native_password' is not loaded</span><br></pre></td></tr></table></figure>

<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul>
<li>在文件<code>/etc/mysql/my.cnf</code>文件中增加代码,开启<code>无密码登录</code>：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-<span class="keyword">grant</span>-<span class="keyword">tables</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重启MySQL,重新进行登录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo service mysql restart</span><br><span class="line">sudo mysql</span><br></pre></td></tr></table></figure>

<ul>
<li>输入以下命令，在将<code>/etc/mysql/mysql.cnf</code>修改过来就可以了</li>
<li>如果此时不修改<code>mysql.cnf</code>文件，可以使用<code>sudo mysql</code>直接进入客户端</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> authentication_string=<span class="keyword">PASSWORD</span>(<span class="string">"密码"</span>) <span class="keyword">where</span> <span class="keyword">User</span>=<span class="string">'root'</span>;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">plugin</span>=<span class="string">"mysql_native_password"</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line">quit;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>MySQL</category>
        <category>Error</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>1045-access-denied</title>
    <url>/2020/10/28/access_denied/</url>
    <content><![CDATA[<h2 id="ERROR-1045-28000-Access-denied-for-user-‘debian-sys-maint’-’localhost’-using-password-YES"><a href="#ERROR-1045-28000-Access-denied-for-user-‘debian-sys-maint’-’localhost’-using-password-YES" class="headerlink" title="ERROR 1045 (28000): Access denied for user ‘debian-sys-maint’@’localhost’ (using password: YES)"></a>ERROR 1045 (28000): Access denied for user ‘debian-sys-maint’@’localhost’ (using password: YES)</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p> 在使用<code>sudo mysql -udebian-sys-maint -p</code>的时候，出现这个错误<br>    使用的是MySQL登录密码</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><pre><code>修改root用户的密码，通过命令来修改root用户的密码：</code></pre><ul>
<li>查看密码</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 通过查看文件获取原始的密码</span></span><br><span class="line">sudo vim /etc/mysql/debian.cnf</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/28/access_denied/1045_1.png" alt></p>
<ul>
<li>更新密码</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 更改密码</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> authentication_string=<span class="keyword">PASSWORD</span>(<span class="string">'root'</span>) <span class="keyword">where</span> <span class="keyword">USER</span>=<span class="string">'root'</span>; </span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"><span class="comment">-- 退出</span></span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<ul>
<li>重新登录    </li>
</ul>
<p>使用更新后的密码可以进行登录</p>
<h3 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h3><ul>
<li><a href="https://blog.csdn.net/xiaoshunzi111/article/details/51898939" target="_blank" rel="noopener">1045 Error&lt;/&gt;</a></li>
<li><a href="https://blog.csdn.net/pengge0727/article/details/81448952?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.channel_param" target="_blank" rel="noopener">1045 Error2</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>MySQL</category>
        <category>Error</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>2002-mysql-conn-err</title>
    <url>/2020/10/28/conn_err/</url>
    <content><![CDATA[<h2 id="2002-Can’t-connect-to-local-MySQL-server-through-socket-‘-var-lib-mysql-mysql-sock’-13-“权限不够”"><a href="#2002-Can’t-connect-to-local-MySQL-server-through-socket-‘-var-lib-mysql-mysql-sock’-13-“权限不够”" class="headerlink" title="2002 - Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (13 “权限不够”)"></a>2002 - Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (13 “权限不够”)</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>在Linux中安装MySQL5.7.31以及Navicat可视化界面，MySQL的连接没有问题，但是在Navicat连接
数据库的过程中出现错误，错误如下：</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn.png" alt="Navicat连接MySQL界面"></p>
<pre><code>具体的错误代码:</code></pre><blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn_2.png" alt="2002_MySQL_Error"></p>
</blockquote>
<h3 id="本地MySQL客户端不能连接MySQL"><a href="#本地MySQL客户端不能连接MySQL" class="headerlink" title="本地MySQL客户端不能连接MySQL"></a>本地MySQL客户端不能连接MySQL</h3><pre><code>1. 查看MySQL的server配置文件</code></pre><p>在<code>socket ‘/var/lib/mysql/mysql.sock’</code>中，这个目录是连接本地mysql，通常通过一个Unix域套接字文件进行的，可能这个mysql.sock套接字文件配置有问题，本地客户端就不能连接。</p>
<pre><code>2. 方法</code></pre><p>ubuntu系统的mysql配置文件在<code>/etc/mysql/my.cnf</code>,在此目录里还有一个<code>mysql.cnf</code>,这两个文件是通过软连接的同一个文件, 我在<code>my.cnf</code>里添加配置信息,<code>mysql.cnf</code>里会自动改变。</p>
<p>使用<code>mysql</code>客户端不能连接到mysql服务端，是因为<code>mysql</code>连接的时候，使用了这个配置文件的<code>[client]</code>部分,新安装的mysql配置文件里是没有内容的,也就没有指定客户端的<code>mysql.sock</code>套接字文件位置;默认使用的是<code>mysql-server</code>服务端的配置,在<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>里;</p>
<blockquote>
</blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn_3.png" alt="mysql配置文件"></p>
<pre><code>3. 更改文件</code></pre><p>更改mysql客户端的mysql.sock套接字文件, 在配置文件<code>/etc/mysql/my.cnf</code>里添加:</p>
<blockquote>
</blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn_4.png" alt="mysql配置文件更改"></p>
<pre><code>4. 重启</code></pre><p>使用<code>sudo service mysql restart</code>命令重启服务，使用<code>mysql -uroot -p</code>登录</p>
<h3 id="本地可以登录，Navicat无法登录"><a href="#本地可以登录，Navicat无法登录" class="headerlink" title="本地可以登录，Navicat无法登录"></a>本地可以登录，Navicat无法登录</h3><p>在终端命令行下可以登录，但是使用Navicat无法登录，看了mysql服务端的配置<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>文件</p>
<blockquote>
</blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn_5.png" alt="mysql配置文件"></p>
<pre><code>1. 解决
    重新编辑连接，将主机名称进行更改</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn_6.png" alt="navicat连接"></p>
<blockquote>
</blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn_7.png" alt="navicat连接成功"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>MySQL</category>
        <category>Error</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>multi-categories</title>
    <url>/2020/10/29/multi-categories/</url>
    <content><![CDATA[<h2 id="Hexo博客的多个分类的解决方案"><a href="#Hexo博客的多个分类的解决方案" class="headerlink" title="Hexo博客的多个分类的解决方案"></a>Hexo博客的多个分类的解决方案</h2><pre><code>在写博客的时候，很多方面并不是单一的，需要和其他的事务关联起来，此时的分类不能单一的看作一个，需要分为多个标签，这里提供一些解决方案。
多个标签的解决方法相同</code></pre><h3 id="子分类"><a href="#子分类" class="headerlink" title="子分类"></a>子分类</h3><pre><code>1. 含义
    将文章的分类方式，按照包含的关系进行分类，后面的分类包含于前面的分类

2. 使用
    将文章分类于，java.servlet</code></pre><ul>
<li>分类方式一：</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Servlet</span></span><br></pre></td></tr></table></figure>

<ul>
<li>分类方式二：</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span> <span class="string">[Java,</span> <span class="string">Servlet]</span></span><br></pre></td></tr></table></figure>

<pre><code>这两个的作用一致，分类的结构都是树形结构</code></pre><h3 id="多个分类"><a href="#多个分类" class="headerlink" title="多个分类"></a>多个分类</h3><p>希望将一篇文章分类于多个目录中,下面的是将文件分类于<code>java</code>和<code>servlet</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="string">-[Java]</span></span><br><span class="line">  <span class="string">-[Servlet]</span></span><br></pre></td></tr></table></figure>

<pre><code>也可以在多分类的基础上使用子分类</code></pre><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="string">-[Java,</span> <span class="string">Servlet]</span></span><br><span class="line">  <span class="string">-[Programming]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>soft</title>
    <url>/2020/10/26/soft/</url>
    <content><![CDATA[<h2 id="SecureCRT"><a href="#SecureCRT" class="headerlink" title="SecureCRT"></a>SecureCRT</h2><pre><code>1. 作用
    Windows和Linux之间的文件传输，支持SSH

2. 官网地址</code></pre><ul>
<li><p><a href="https://www.vandyke.com/cgi-bin/releases.php?product=securecrt" target="_blank" rel="noopener">SecureCRT官网</a></p>
</li>
<li><p><a href="https://www.vandyke.com/cgi-bin/releases.php?product=securecrt" target="_blank" rel="noopener">https://www.vandyke.com/cgi-bin/releases.php?product=securecrt</a></p>
<p><a href="https://pan.baidu.com/s/163MKL_sAXwfQ_8oPXGW7MA" target="_blank" rel="noopener">百度网盘地址，提取码：ab12 </a></p>
<ol start="3">
<li><p>安装<br> 需要注意安装路径，其余的直接next</p>
</li>
<li><p>破解</p>
</li>
</ol>
</li>
<li><p><a href="http://www.xue51.com/soft/10266.html" target="_blank" rel="noopener">SecrueCRT破解教程</a></p>
</li>
</ul>
<p>在软件安装包中存在注册机，直接根据教程进行破解就可以了</p>
<pre><code>5. 使用
    建立链接，可以使用sz,rz进行文件的下载和上传，也可以使用sftp进行文件的下载和上传</code></pre><ul>
<li><p><a href="https://blog.csdn.net/yule117737767/article/details/82388285" target="_blank" rel="noopener">SecrueCRT使用教程1</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_41880069/article/details/89643358?utm_medium=distribute.pc_relevant.none-task-blog-title-3&spm=1001.2101.3001.4242" target="_blank" rel="noopener">SecrueCRT使用教程2</a></p>
<p>  使用SFTP进行文件传输：Alt + P,打开sftp界面</p>
<ul>
<li>lcd 本地上传或者下载目录</li>
<li>cd linux文件目录</li>
<li>put 本地文件夹下的文件名</li>
<li>get linux文件夹下的文件名<blockquote>
</blockquote>
<img src="/2020/10/26/soft/secureCRT_1.png" alt="secure文件上传和下载"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>1046-no-database</title>
    <url>/2020/10/28/not_db/</url>
    <content><![CDATA[<h2 id="1046-3D000-No-database-selected"><a href="#1046-3D000-No-database-selected" class="headerlink" title="1046 (3D000): No database selected"></a>1046 (3D000): No database selected</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><pre><code>在MySQL进行数据更新的时候，出现这个错误</code></pre><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><pre><code>1. 出现位置</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> authentication_string=<span class="keyword">PASSWORD</span>(<span class="string">'root'</span>) <span class="keyword">where</span> <span class="keyword">USER</span>=<span class="string">'root'</span>;</span><br></pre></td></tr></table></figure>

<pre><code>2. 错误代码</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ERROR 1046 (3D000): No database selected</span><br></pre></td></tr></table></figure>

<pre><code>3. 解决
    因为是直接使用 SQL 语句的方式来删除账户，所以必须先选择 mysql 自身的数据库：</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>MySQL</category>
        <category>Error</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2020/10/12/maven/</url>
    <content><![CDATA[<h2 id="Maven基础知识"><a href="#Maven基础知识" class="headerlink" title="Maven基础知识"></a>Maven基础知识</h2><pre><code>1. Maven的含义
    * 一个项目管理工具
    * 依赖管理：
        Maven对项目的jar包的管理过程，传统项目直接把jar包放置在项目中，
        maven工程真正的jar包放置在仓库中，项目中只需要放置坐标
    * 一键构建：
        maven中集成了对tomcat插件，可以对项目进行编译，测试，打包，安装和发布等

2. 依赖管理
    1. 仓库的种类
        * 本地仓库
        * 远程仓库（私服）
        * 中央仓库

    2. 仓库之间的关系
        当我们启动一个maven工程时，maven会通过pom文件中的jar坐标去本地仓库寻找
        如果本地仓库没有对应jar包，会默认到中央仓库寻找对应jar包，下载到本地仓库
        在公司中，如果本地仓库没有对应jar包，会先从私服下载，如果私服没有jar包，可以从中央仓库下载jar包，也可以从本地仓库上传jar包

3. 一键构建
    1. 常用命令
        * clean:对构建信息进行清理
        * complie: src/main/java目录进行编译
        * test: 对测试进行编译
        * package: 对项目进行打包，默认目录在target目录（本地complie目录）
        * install：将包安装到本地仓库
        * deploy：项目上传到私服

    2. maven的生命周期
        * 清理生命周期：clean
        * 默认生命周期: complie test package install deploy
        * 站点生命周期：</code></pre><h2 id="Maven传统使用"><a href="#Maven传统使用" class="headerlink" title="Maven传统使用"></a>Maven传统使用</h2><pre><code>1. jar包的冲突原因
    如果一个项目导入核心jar包，会自动导入它所依赖的其他jar，如果导入的jar包所依赖的包是同一个，可能因为导入jar包的顺序问题，产生jar包的冲突

2. 解决jar包的冲突
    1. 第一声明优先原则
        哪个jar包的坐标在靠上的位置，这个jar包就是先声明的，先声明的jar包的坐标下的依赖包可以优先进入项目

    2. 路径近者优先原则
        * 直接依赖：项目中直接导入的jar包，就是该项目的直接依赖jar包
        * 传递依赖：项目中没有直接导入的jar包，可以通过直接依赖的jar包传递到项目中的jar
        直接依赖路径比传递依赖路径近，最终进入项目的jar包会是路径近的直接依赖

    3. 直接排除法
        排除某个jar包的依赖包，使用exclusions排除该jar包的依赖包，在坐标内部排除当前jar包，可以不写版本号，默认和当前jar包的版本号一致

3. 版本锁定
    1. 原因
        maven工程可以分为父子依赖，
        凡是依赖别的项目后拿到的别的项目的依赖，都属于传递依赖。
        项目A,被项目B依赖，项目A中的所有jar包都会传递到项目B,如果此时项目B的开发人员重新导入的jar包，由于是直接依赖，会覆盖到项目A的jar包

    2. 解决方法
        使用&lt;dependencyManagement&gt;来进行版本锁定，将项目主要的jar包的版本锁定，那么其他依赖该项目的项目中，即使有同名的jar包，也不会发生jar包覆盖

    3. 使用方法
        使用&lt;DependencyManagement&gt;标签只是起到版本锁定的作用，导入jar包还是需要使用&lt;Dependencies&gt;标签来进行导入jar包        

    4. 简化pom.xml文件
        * 使用&lt;properties&gt;标签来进行坐标版本的引入，减少后续的开发中的jar版本修改问题
        * 使用&lt;DependencyManagement&gt;来进行版本锁定</code></pre><h2 id="Maven工程的拆分聚合"><a href="#Maven工程的拆分聚合" class="headerlink" title="Maven工程的拆分聚合"></a>Maven工程的拆分聚合</h2><pre><code>1. 拆分的思想
    将一个完整的项目，拆分成多个独立的模块，在需要其中的某个模块的时候，可以直接引用该模块，有利于提高代码的可重用性，以及维护性

2. 聚合的思想
    把拆分的零散的模块组合起来形成一个完整的项目的过程，就是maven的聚合过程</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/12/maven/maven_1.png" alt="拆分聚合"></p>
<h3 id="拆分案例"><a href="#拆分案例" class="headerlink" title="拆分案例"></a>拆分案例</h3><pre><code>1. 步骤
    * 建立一个project,作为父工程，只需要工程中包含pom.xml文件就可以
    * 建立子模块，选中当前的项目，右键New-&gt;Module
    * 在创建子模块的时候会显示父工程的名称
    * 子模块中的pom.xml文件包含父工程的组织名和版本号（共享），父工程pom.xml会包含子模块的模块名</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/12/maven/maven_parent.png" alt="父工程的建立"></p>
<blockquote>
<p><img src="/2020/10/12/maven/maven_son_dao.png" alt="子工程的建立"></p>
</blockquote>
<p><img src="/2020/10/12/maven/maven_son_dao_2.png" alt="子工程的建立2"></p>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/maven/maven_pom.png" alt></p>
<pre><code>2. 注意
    1. 项目,工程和模块之间的区别
        工程不等于一个完整的项目，模块也不等于一个完整的项目，一个完整的项目看的是代码，代码完整，才说明是一个完整的项目，和此项目是工程或模块没有关联

        1. 工程天生只能使用自己的内部资源，天生是独立的，后期可以和其他的工程或模块建立关联关系
        2. 模块天生属于父工程的，天生不是独立的，模块一旦创建，所有的父工程的资源模块都可以使用

    2. 父子工程
        * 子模块天生集成父工程，可以使用父工程的所有资源
        * 子模块之间天生没有任何关联，后期可以自己建立关系，
            子模块在需要使用其他模块的地方引用模块的坐标就可以了

        * 父子工程之间不用建立关系，继承关系是天生的，不需要手动建立
        * 子工程之间引用叫做依赖，依赖关系不是天生的，需要手动建立

3. 传递依赖的jar包能否使用
    * 直接依赖的jar包的作用域为complie,传递依赖的jar包的作用域与这个jar包在pom.xml文件中的定义相关，
    * 如果实际开发中发现对应的jar包无法导入，可以重新导入jar包

4. maven父子工程项目的测试
    1. 通过maven的run启动父工程来进行服务启动
    2. 先将父子工程的jar包安装到本地仓库，父工程 install，安装到本地仓库,然后通过子工程的web来进行启动
    3. 使用本地的tomcat来进行服务启动

    第一种和第二种的服务启动的方式是基于maven自带的tomcat服务器启动，
        1. 方式一：使用父工程的run命令来进行服务启动，此时服务首先加载pom.xml文件，进行jar包的导入，由于此时的所有jar包都存在，可以启动服务
        2. 方式二：使用启动web项目来启动服务，在查找jar包的时候只有service层的jar包，本地仓库没有，中央仓库也没有，jar包导入错误，无法启动，只有将jar包安装到本地仓库，才能使用web项目来进行服务的启动（install）

    第三种方式：直接使用本地的tomcat服务器来进行服务的启动</code></pre><h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><pre><code>1. 私服的安装</code></pre><ul>
<li><a href="https://www.cnblogs.com/qdhxhz/p/9801325.html" target="_blank" rel="noopener">maven私服的下载地址</a></li>
</ul>
<h2 id="下载第三方jar"><a href="#下载第三方jar" class="headerlink" title="下载第三方jar"></a>下载第三方jar</h2><pre><code>1. 安装第三方jar包到本地仓库
    1. 进入jar包的所在目录</code></pre><p><code>mvn install:install-file -DgroupId=com.alibaba -DartiactId=fastjson -Dversion=1.1.37 -Dfile=fastjson-1.1.37.jar -Dpackage=jar</code></p>
<pre><code>2. 使用cmd命令行安装</code></pre><p><code>mvn install:install-file -DgroupId=com.alibaba -DartiactId=fastjson -Dversion=1.1.37 -Dfile=D:/2017217796/fastjson-1.1.37.jar -Dpackage=jar</code></p>
<pre><code>注意事项：
    这种安装方法，默认本地仓库的位置为C盘下的指定安装目录，如果曾经更改过本地仓库的位置，会产生错误</code></pre>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>IO</title>
    <url>/2020/12/06/IO/</url>
    <content><![CDATA[<h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>I ：Input，从内存的角度来看，数据从磁盘流入到内存，也叫做”读“</p>
<p>O ：Output ，从内存的角度来看，数据从内存流入到磁盘，也叫做”写“</p>
<p><img src="/2020/12/06/IO/IO_stream.png" alt="IO流的概念"></p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>IO流位于java.io包下</p>
<ol>
<li><p>根据数据流动的方向不同</p>
<ul>
<li>输入流：数据从磁盘流入到内存，也叫做”读“</li>
<li>输出流：数据从内存流入到磁盘，也叫做”写“</li>
</ul>
<p>数据的流动方向是以内存作为分界点的</p>
</li>
<li><p>根据数据的读取方式</p>
<ul>
<li>字节流：每次读取一个字节，<strong>万能的读取方式</strong>，可以读取文本，声音，图像</li>
<li>字符流：每次读取一个字符，只能读取纯文本数据</li>
</ul>
</li>
</ol>
<h4 id="IO流的四种种类"><a href="#IO流的四种种类" class="headerlink" title="IO流的四种种类"></a>IO流的四种种类</h4><ul>
<li>InputStream: 字节输入流</li>
<li>OutputStream: 字节输出流</li>
<li>Reader：字符输入流</li>
<li>Writer：字符输出流</li>
</ul>
<p>以stream结尾的：<strong>字节流</strong></p>
<p>以reader结尾的：<strong>字符流</strong></p>
<h4 id="通用的接口实现"><a href="#通用的接口实现" class="headerlink" title="通用的接口实现"></a>通用的接口实现</h4><ol>
<li><p>Closeable : 可关闭的</p>
<p>所有的IO流都实现了这个接口，所有的IO流都可以关闭，只要引用不是null</p>
<p>close()方法，释放占用的系统资源，在finally语句块中进行资源的释放</p>
</li>
<li><p>Flushable：可刷新的</p>
<p>所有的输出流都实现了这个接口，强制将缓冲区的数据输出，清空缓冲区</p>
</li>
</ol>
<h4 id="常用的IO流的类"><a href="#常用的IO流的类" class="headerlink" title="常用的IO流的类"></a>常用的IO流的类</h4><ul>
<li>文件流<ul>
<li>FileInputStream</li>
<li>FileOutputStream</li>
<li>Reader</li>
<li>Writer</li>
</ul>
</li>
<li>转换流<ul>
<li>InputStreamReader</li>
<li>OutputStreamWriter</li>
</ul>
</li>
<li>缓冲流<ul>
<li>BufferedInputStream</li>
<li>BufferedOutputStream</li>
<li>BufferedReader</li>
<li>BufferedWriter</li>
</ul>
</li>
<li>数据流<ul>
<li>DataInputStream</li>
<li>DataOutputStream</li>
</ul>
</li>
<li>对象流<ul>
<li>ObjectInputStream</li>
<li>ObjectOutputStream</li>
</ul>
</li>
<li>标准输出流<ul>
<li>PrintWriter</li>
<li>PrintStream</li>
</ul>
</li>
</ul>
<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><h3 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h3><p>IDEA中当前路径：本Project的目录下，如果使用相对路径，需要从根目录往下找</p>
<h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><p>int read()：读取文件的一个字节，返回值表示读取的字节的值</p>
<p>int read(byte[] bytes): 读取数据放入到byte数组，返回值表示读取的字节个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">"src/io/file/temp.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次将数据读取到byte数组中，减少磁盘消耗</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((count = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">	System.out.print(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>int read() : 读取一个字节，返回读取到的字节，没有数据，返回-1</li>
<li>int available(): 返回还剩下多少字节没有读取，可以作为byte数组长度，一次性读取所有数据</li>
<li>long skip(long n): 跳过n个字节的数据不进行读取</li>
</ul>
<h3 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h3><h4 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数，尾部追加元素，如果文件不存在，创建文件</span></span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"src/io/file/test1.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">fos.write(bytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要刷新数据</span></span><br><span class="line">fos.flush();</span><br></pre></td></tr></table></figure>

<h3 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h3><p>和FileInputStream使用方法大致相同，只是byte数组变为char数组</p>
<h4 id="使用：-2"><a href="#使用：-2" class="headerlink" title="使用："></a>使用：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line">fileReader = <span class="keyword">new</span> FileReader(<span class="string">"src/io/file/test1.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((readCount = fileReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(chars,<span class="number">0</span>,readCount));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h3><p>和FileOutputStream类似，只是byte数组变为char数组</p>
<h4 id="使用：-3"><a href="#使用：-3" class="headerlink" title="使用："></a>使用：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">writer = <span class="keyword">new</span> FileWriter(<span class="string">"src/io/file/test1.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以写 单个字符，字符数组，字符串</span></span><br><span class="line">writer.write(<span class="string">"hello"</span>);</span><br><span class="line">writer.write(<span class="string">'\n'</span>);</span><br><span class="line">writer.write(<span class="string">"Java"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新</span></span><br><span class="line">writer.flush();</span><br></pre></td></tr></table></figure>

<h3 id="使用文件流进行文件复制"><a href="#使用文件流进行文件复制" class="headerlink" title="使用文件流进行文件复制"></a>使用文件流进行文件复制</h3><ol>
<li>使用FileInputStream/FileOutputStream</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">"src/io/file/test1.txt"</span>);</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"src/io/copytest1.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一边读取数据，一边写入数据</span></span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">512</span>];       <span class="comment">// 512K</span></span><br><span class="line"><span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((readCount = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">	fos.write(buffer,<span class="number">0</span>,readCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新缓冲区</span></span><br><span class="line">fos.flush();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用FileReader/FileWriter</li>
</ol>
<p>参考上面的文件复制</p>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>缓冲流：带有缓冲区的输入输出流，不需要手动创建缓冲数组</p>
<h3 id="BufferedReader类"><a href="#BufferedReader类" class="headerlink" title="BufferedReader类"></a>BufferedReader类</h3><h4 id="使用：-4"><a href="#使用：-4" class="headerlink" title="使用："></a>使用：</h4><p>BufferedReader的构造器需要传入<strong>字符输入流对象</strong></p>
<ul>
<li>创建FileReader对象作为参数传递</li>
<li>使用转换流InputStreamReader将字节流转换为字符流</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"src/io/file/text1.txt"</span>));</span><br><span class="line">br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"src/io/file/text1.txt"</span>)));</span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((str =  br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">     System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个流作为另外一个流的构造函数的参数出现，将参数的叫做：节点流</p>
<p>另一个叫做：包装流，处理流</p>
<p>此时只需要调用包装流的close方法就行，包装流内部释放节点流的资源</p>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>将字节流转换为字符流</p>
<p>InputStreamReader</p>
<p>OutputStreamWriter</p>
<h2 id="数据输入输出流"><a href="#数据输入输出流" class="headerlink" title="数据输入输出流"></a>数据输入输出流</h2><h3 id="DataOutputStream类"><a href="#DataOutputStream类" class="headerlink" title="DataOutputStream类"></a>DataOutputStream类</h3><p>将数据的值连同数据类型一起写入到文件中，此文件使用文本文件无法打开，需要使用DataInputStream以及按照存储顺序取出类型数据才能读取</p>
<h2 id="DataInputStream类"><a href="#DataInputStream类" class="headerlink" title="DataInputStream类"></a>DataInputStream类</h2><h4 id="使用：-5"><a href="#使用：-5" class="headerlink" title="使用："></a>使用：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line">dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"data"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">12L</span>;</span><br><span class="line">dos.writeByte(b);</span><br><span class="line">dos.writeLong(l);</span><br><span class="line">dos.flush();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"data"</span>));</span><br><span class="line">System.out.println(dis.readByte());</span><br><span class="line">System.out.println(dis.readLong());</span><br></pre></td></tr></table></figure>

<h2 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h2><h3 id="PrintStream类"><a href="#PrintStream类" class="headerlink" title="PrintStream类"></a>PrintStream类</h3><p>标准字节输出流，将数据打印到控制台上</p>
<ul>
<li>setOut(PrintStream ps): 可以将输出信息重新定向，一般用作日志信息记录</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"lon.txt"</span>,<span class="keyword">true</span>));</span><br><span class="line"><span class="comment">// 重定向输出流</span></span><br><span class="line">System.setOut(ps);</span><br></pre></td></tr></table></figure>

<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>File是文件和目录的抽象化表示形式，可以表示一个目录，也可以表示一个目录</p>
<h3 id="使用：-6"><a href="#使用：-6" class="headerlink" title="使用："></a>使用：</h3><ul>
<li>File类主要是对文件和目录的操作<ul>
<li>文件是否存在</li>
<li>是否为目录，或者文件</li>
<li>创建目录，创建多重目录</li>
<li>获取文件名称，获取文件路径（绝对路径，相对路径）</li>
<li>获取目录下的所有文件对象</li>
</ul>
</li>
</ul>
<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><ul>
<li>序列化 Serialize</li>
</ul>
<p>将内存中的java状态信息保存到磁盘文件中，叫做序列化 Serialize</p>
<ul>
<li>反序列化 DeSerialize</li>
</ul>
<p>将磁盘文件保存的java状态信息还原为内存的java状态信息，叫做反序列化 DeSerialize</p>
<p><img src="/2020/12/06/IO/serialize.png" alt="序列化和反序列化"></p>
<h3 id="实现序列化"><a href="#实现序列化" class="headerlink" title="实现序列化"></a>实现序列化</h3><p>使用<strong>ObjectOutputStream</strong>可以将java对象的状态进行序列化</p>
<p>序列化的对象必须实现<strong>java.io.Serializable</strong>接口，特别是自定义类，否则NotSerializableException异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象输出流</span></span><br><span class="line">oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"serialize.txt"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写出数据</span></span><br><span class="line">oos.writeObject(<span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"12"</span>));</span><br></pre></td></tr></table></figure>

<h3 id="实现反序列化"><a href="#实现反序列化" class="headerlink" title="实现反序列化"></a>实现反序列化</h3><p>使用<strong>ObjectInputStream</strong>可以进行反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileIntputStream(<span class="string">"serialize.txt"</span>));</span><br><span class="line">System.out.println(ois.readObject());</span><br></pre></td></tr></table></figure>

<h3 id="Serializable的含义"><a href="#Serializable的含义" class="headerlink" title="Serializable的含义"></a>Serializable的含义</h3><p>Serializable接口是一个标志接口，JVM看到这个标志，会自动为java对象生成序列化版本号</p>
<p>JVM识别不同的类？</p>
<ul>
<li>如果类名不同，肯定不是同一个类</li>
<li>如果类名相同，比较序列化版本号来区分</li>
</ul>
<h4 id="关键字：transient-游离态"><a href="#关键字：transient-游离态" class="headerlink" title="关键字：transient 游离态"></a>关键字：transient 游离态</h4><p>transient关键字表示属性不被序列化，在序列化时，跳过该属性</p>
<h4 id="序列化版本号"><a href="#序列化版本号" class="headerlink" title="序列化版本号"></a>序列化版本号</h4><p>serialVersionUID: 序列化版本号，JVM用来不同的类</p>
<p>建议自己手动指定序列化版本号，每次修改类源码，重新编译之后，系统会再次分配序列化版本号，可能造成无法读取以前序列化的文件</p>
<p><code>private static final long serialVersionUID = 1L;</code></p>
<p>指定序列化版本号</p>
<h3 id="序列化多个对象"><a href="#序列化多个对象" class="headerlink" title="序列化多个对象"></a>序列化多个对象</h3><p>可以创建List集合存储数据，可以一次序列化多个对象</p>
<h2 id="流与Properties类"><a href="#流与Properties类" class="headerlink" title="流与Properties类"></a>流与Properties类</h2><p>Properties称为配置类，键值都是String类型数据</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>后缀名为<em>.properties</em>的文件称为配置文件</p>
<p>如果所有的内容都是：</p>
<p>​            key=value，这种配置问价又称为属性配置文件</p>
<h3 id="读取属性配置文件"><a href="#读取属性配置文件" class="headerlink" title="读取属性配置文件"></a>读取属性配置文件</h3><p>读取属性配置文件，需要使用输入流，Reader InputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"config.prperties"</span>);</span><br><span class="line">Properties p = <span class="keyword">new</span> Properties().load(fr);</span><br><span class="line"></span><br><span class="line">Object obj = p.get(key);</span><br></pre></td></tr></table></figure>

<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>可以在修改属性配置的时候，不用更改源代码，程序动态读取配置信息</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java-SE</tag>
      </tags>
  </entry>
  <entry>
    <title>thread</title>
    <url>/2020/12/06/thread/</url>
    <content><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>1、进程和线程？</p>
<ul>
<li>进程：程序执行的过程，一个程序就是一个进程</li>
<li>线程：进程的其中一个执行单元，粒度更小的进程，可以多个线程并发，提高程序运行的效率</li>
</ul>
<p>2、资源共享？</p>
<ul>
<li>在进程中：多个进程相互独立，互不干扰</li>
<li>在线程中：java语言<ul>
<li>堆，方法区共享</li>
<li>栈独立，不同的线程拥有不同的栈空间</li>
</ul>
</li>
</ul>
<p>3、main方法结束，程序是否执行结束?</p>
<p>​    在多线程的条件下，主程序执行结束，只表示主线程执行结束，主栈被清空，不代表其他的线程执行结束</p>
<p>4、真正的多线程并发？</p>
<p>​    在单核状态下，不存在真正的多线程并发，只是CPU执行的速度很快，在多个线程切换的速度比较快，人无法察觉</p>
<p>​    在多核状态下，通过调度算法，可以保证多个任务在同一个时间点执行，才是真正的多线程并发</p>
<h2 id="实现多线程"><a href="#实现多线程" class="headerlink" title="实现多线程"></a>实现多线程</h2><h3 id="继承java-lang-Thread类"><a href="#继承java-lang-Thread类" class="headerlink" title="继承java.lang.Thread类"></a>继承java.lang.Thread类</h3><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><p>在需要使用多线程的类上继承Thread类，重写run方法，在需要开启线程的时候调用start方法（start方法只是开启新的栈空间，启动一个分支线程，并不执行run方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 重写run方法  </span></span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启分支线程</span></span><br><span class="line"><span class="keyword">new</span> MyThread().start();</span><br></pre></td></tr></table></figure>

<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul>
<li>继承Thread，需要重写run方法</li>
<li>使用start方法是开启一个分支线程，直接调用run方法不能开启一个分支线程</li>
<li>run方法和main方法都会在栈底开辟栈帧，这两个方法的地位一样</li>
</ul>
<h3 id="实现java-lang-Runnable接口"><a href="#实现java-lang-Runnable接口" class="headerlink" title="实现java.lang.Runnable接口"></a>实现java.lang.Runnable接口</h3><h4 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h4><p>需要实现Runnable接口，重写run方法，需要将该对象作为参数传入Thread的构造函数中，在调用start方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"============"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">thread,strat();</span><br><span class="line"><span class="comment">// 使用lambda表达式实现多线程</span></span><br></pre></td></tr></table></figure>

<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>在java.util.concurrent包下，JDK新特性，java并发包，FutureTash Callable接口，可以进行线程的实现</p>
<ul>
<li>可以获取线程执行的结果，call方法允许返回数据，抛出异常</li>
<li>如果线程返回执行结果，会等到执行结果出现</li>
</ul>
<h4 id="FutureTask-Callable"><a href="#FutureTask-Callable" class="headerlink" title="FutureTask Callable"></a>FutureTask Callable</h4><p>1、FutureTask类</p>
<p>juc包下的类，未来任务类，可以创建一个未来任务对象，传入Thread构造函数中，启动线程</p>
<p>2、Callable接口</p>
<p>函数式编程接口，可以使用lambda实现</p>
<p>内部的call方法需要重写，包含返回值，可以抛出异常</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest08</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// FutureTask 未来任务对象</span></span><br><span class="line">        <span class="comment">// 构造函数 Callable&lt;V&gt; 参数</span></span><br><span class="line">        FutureTask&lt;Object&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" ---&gt; "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Object();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取返回值</span></span><br><span class="line">        Object o = task.get();</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"主线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/2020/12/06/thread/thread_life_cycle.png" alt="线程的生命周期"></p>
<ul>
<li>新建状态</li>
<li>就绪状态</li>
<li>运行状态</li>
<li>阻塞状态</li>
<li>死亡状态</li>
</ul>
<p>运行状态下的线程遇到synchronized关键字时，会进入<strong>锁池 lockpool</strong>,在锁池中寻找共享对象的对象锁，线程进入所持的额时候，会释放占用的时间片，如果找到了，进入就绪状态抢占时间片，没找到在锁池中等待</p>
<p><strong>运行状态线程：遇到synchronized时，如果在锁池中没有找到共享对象的对象锁，进入阻塞状态；否则进入就绪状态</strong></p>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>Thread类位于java.lang包下，不需要导入</p>
<h3 id="修改线程信息"><a href="#修改线程信息" class="headerlink" title="修改线程信息"></a>修改线程信息</h3><p>1、修改线程的名称？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread1 thread = <span class="keyword">new</span> Thread();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程的名称</span></span><br><span class="line">thread.setName(<span class="string">"T1"</span>);</span><br><span class="line"><span class="comment">// 获取线程的名称</span></span><br><span class="line">thread.getName();</span><br></pre></td></tr></table></figure>

<ul>
<li>默认线程的名称：Thread-0，Thread-1</li>
<li>主线程的名称：main</li>
</ul>
<p>2、获取当前线程以及线程名称？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法 currentThread()</span></span><br><span class="line">Thread.currentThread().getName()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在那个线程内部调用该方法，获取哪个线程的名称</span></span><br></pre></td></tr></table></figure>

<h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><p>sleep方法，当前线程进入休眠，放弃CPU时间片的使用权</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>sleep方法是静态方法，使用类名调用，出现在哪个线程内，哪个线程睡眠</li>
<li>参数：毫秒</li>
<li>Thread.sleep()</li>
<li>可以间隔特定的事件，执行一段特定的代码</li>
</ul>
<h4 id="中止线程的sleep方法"><a href="#中止线程的sleep方法" class="headerlink" title="中止线程的sleep方法"></a>中止线程的sleep方法</h4><p>使用线程的方法：interrupt方法可以提前唤醒睡眠的线程</p>
<p>interrupt方法调用之后，Thread.sleep()会产生InterruptException异常，该异常发生之后，进入catch语句，终端sleep的执行</p>
<h4 id="终止线程的sleep方法"><a href="#终止线程的sleep方法" class="headerlink" title="终止线程的sleep方法"></a>终止线程的sleep方法</h4><h5 id="强制终止"><a href="#强制终止" class="headerlink" title="强制终止"></a>强制终止</h5><p>使用stop方法可以强制终止线程的sleep方法，可能会造成数据丢失，此方法已被弃用</p>
<h5 id="合理终止"><a href="#合理终止" class="headerlink" title="合理终止"></a>合理终止</h5><p>在自定义线程类中设定终止标志，通过改变该标志来进行线程终止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread6</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程终止标志</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(run)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程进入阻塞状态"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 数据保存</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><ul>
<li>静态方法，当前线程让出CPU的使用权，从“运行状态”转换为“就绪状态”</li>
<li>yield方法不会产生阻塞</li>
</ul>
<h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><ul>
<li>实例方法，某个线程合并到当前正在执行的线程中，当前线程阻塞，合并的线程执行结束，当前线程再执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    MyThread7 myThread7 = <span class="keyword">new</span> MyThread7();</span><br><span class="line">    myThread7.start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主线程阻塞，myThread7在执行，直到执行结束</span></span><br><span class="line">    myThread7.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"执行。。。"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="为什么会产生线程安全问题？"><a href="#为什么会产生线程安全问题？" class="headerlink" title="为什么会产生线程安全问题？"></a>为什么会产生线程安全问题？</h3><ul>
<li>多线程并发</li>
<li>有共享数据</li>
<li>对共享数据进行修改</li>
</ul>
<h3 id="解决线程安全问题？"><a href="#解决线程安全问题？" class="headerlink" title="解决线程安全问题？"></a>解决线程安全问题？</h3><p>使用线程同步机制，让多个线程排队执行，不在并发执行</p>
<p>线程同步机制牺牲效率，保证了数据安全</p>
<h4 id="线程同步-异步"><a href="#线程同步-异步" class="headerlink" title="线程同步/异步"></a>线程同步/异步</h4><ul>
<li>异步：多线程并发，多个线程互不干扰，独立执行</li>
<li>同步：多线程顺序执行，多个线程排队执行</li>
</ul>
<h4 id="使用synchronized保证线程安全"><a href="#使用synchronized保证线程安全" class="headerlink" title="使用synchronized保证线程安全"></a>使用synchronized保证线程安全</h4><p>synchronized关键字，保证线程同步的机制</p>
<p>原理：</p>
<ul>
<li>每个对象都有一把对象锁，线程t1和线程t2进入到方法内部时具有先后顺序</li>
<li>假如t1先执行，遇到synchronized，会先找共享对象的对象锁，找到之后占用这把锁，直到同步代码块中的语句执行完毕，才会释放对象锁</li>
<li>在线程t1持有对象锁的时候，t2也进入方法，遇到synchronized，发现对象锁已经被占用，线程t2就会阻塞，等到对象锁释放，才会继续执行，这样线程t1,t2就不会同时执行。</li>
</ul>
<p><strong>因此，同步代码块的共享对象必须选择好，需要是多个线程对象所共享的</strong></p>
<h4 id="synchronized的作用位置？"><a href="#synchronized的作用位置？" class="headerlink" title="synchronized的作用位置？"></a>synchronized的作用位置？</h4><h5 id="作用在实例方法内部："><a href="#作用在实例方法内部：" class="headerlink" title="作用在实例方法内部："></a>作用在实例方法内部：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(共享对象)&#123;</span><br><span class="line">	<span class="comment">// 同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>共享对象：选择希望同步的线程共享的资源对象</li>
</ul>
<h5 id="作用在实例方法上："><a href="#作用在实例方法上：" class="headerlink" title="作用在实例方法上："></a>作用在实例方法上：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">do</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在实例方法名上的synchronized，共享对象只能为 this，不灵活，可能导致锁住的内容太多，运行较慢</li>
</ul>
<h5 id="作用在静态方法上："><a href="#作用在静态方法上：" class="headerlink" title="作用在静态方法上："></a>作用在静态方法上：</h5><p>静态方法上的锁为类锁，静态方法只会创建一次，无论创建多少个对象，指向的都是同一个对象</p>
<h4 id="三种变量的线程安全问题？"><a href="#三种变量的线程安全问题？" class="headerlink" title="三种变量的线程安全问题？"></a>三种变量的线程安全问题？</h4><ul>
<li>静态变量：在方法区，共享资源，会产生线程安全问题</li>
<li>实例变量：在堆中，共享资源，会产生线程安全问题</li>
<li>局部变量：栈中，不是共享资源</li>
</ul>
<h4 id="尽量避免出现线程安全问题"><a href="#尽量避免出现线程安全问题" class="headerlink" title="尽量避免出现线程安全问题"></a>尽量避免出现线程安全问题</h4><ul>
<li><p>使用局部变量，而不是使用静态或者实例变量</p>
</li>
<li><p>必须使用实例变量，可以每个线程创建一个实例对象</p>
</li>
<li><p>万不得已，使用synchronized为共享对象加锁</p>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="产生原因？"><a href="#产生原因？" class="headerlink" title="产生原因？"></a>产生原因？</h3><ul>
<li>占有并等待</li>
<li>非抢占资源</li>
<li>互斥</li>
<li>循环等待</li>
</ul>
<p>两个或多个线程为了访问共享资源，由于资源的访问顺序不一样，synchronized的共享对象加锁顺序不一样，可能会导致线程相互等待，程序无法进行下去，形成死锁</p>
<h3 id="代码演示？"><a href="#代码演示？" class="headerlink" title="代码演示？"></a>代码演示？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        MThread thread = <span class="keyword">new</span> MThread(o1, o2);</span><br><span class="line">        MThread2 thread2 = <span class="keyword">new</span> MThread2(o1, o2);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object o1;</span><br><span class="line">    <span class="keyword">private</span> Object o2;</span><br><span class="line"></span><br><span class="line">    MThread(Object o1,Object o2)&#123;</span><br><span class="line">        <span class="keyword">this</span>.o1 = o1;</span><br><span class="line">        <span class="keyword">this</span>.o2 = o2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MThread()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于共享资源加锁的时机不一样，可能会导致死锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object o1;</span><br><span class="line">    <span class="keyword">private</span> Object o2;</span><br><span class="line"></span><br><span class="line">    MThread2(Object o1,Object o2)&#123;</span><br><span class="line">        <span class="keyword">this</span>.o1 = o1;</span><br><span class="line">        <span class="keyword">this</span>.o2 = o2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MThread2()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于共享资源加锁的时机不一样，可能会导致死锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">            <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="守护线程-daemon"><a href="#守护线程-daemon" class="headerlink" title="守护线程 daemon"></a>守护线程 daemon</h2><p>java中有两种线程，用户线程，守护线程</p>
<ul>
<li><p>用户线程：main线程</p>
</li>
<li><p>守护线程中最具有代表性的：垃圾回收线程</p>
</li>
</ul>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><strong>守护线程一般是死循环，所有的用户线程只要结束，守护线程自动结束</strong></li>
<li>在线程启动之前，通过setDaemon(true)可以将用户线程设置为守护线程</li>
</ul>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DaemonTask daemonTask = <span class="keyword">new</span> DaemonTask();</span><br><span class="line"></span><br><span class="line">daemonTask.setName(<span class="string">"守护线程"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置守护线程</span></span><br><span class="line">daemonTask.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h2 id="定时器-Timer"><a href="#定时器-Timer" class="headerlink" title="定时器 Timer"></a>定时器 Timer</h2><p>定时器：可以间隔固定的时间，执行一段特定的java代码</p>
<h3 id="实现定时器功能"><a href="#实现定时器功能" class="headerlink" title="实现定时器功能"></a>实现定时器功能</h3><ul>
<li>使用Thread.sleep()进行设置</li>
<li>使用java.util.Timer设置定时器</li>
<li>使用框架提供的定时器功能，Spring框架中SpringTask框架</li>
</ul>
<h3 id="使用Timer定时器"><a href="#使用Timer定时器" class="headerlink" title="使用Timer定时器"></a>使用Timer定时器</h3><h4 id="Timer构造器"><a href="#Timer构造器" class="headerlink" title="Timer构造器"></a>Timer构造器</h4><ul>
<li>Timer()</li>
<li>Timer(String name)</li>
<li>Timer(boolean daemon)</li>
<li>Timer(String name,boolean daemon)</li>
</ul>
<p>daemon表示是否将其设置为守护线程</p>
<h4 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h4><p>schedule(定时任务对象，首次执行时间，间隔时常)</p>
<p>定时任务对象：TimerTask抽象类，可以创建新的对象继承，也可以使用匿名内部类，需要重写run方法，设置执行代码</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建定时器对象</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置定时任务</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">Date parse = sdf.parse(<span class="string">"2021-03-08 10:38:20"</span>);</span><br><span class="line"></span><br><span class="line">timer.schedule(<span class="keyword">new</span> TimerTask1(),parse,<span class="number">1000</span> * <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait notify"></a>wait notify</h2><p>wait和notify不是多线程特有的方法，是Object对象的方法，换句话说，每个对象都可以调用这两个方法</p>
<h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">o.wait()</span><br></pre></td></tr></table></figure>

<p>将正在占用o的线程阻塞，让其无限期等待，直到被唤醒，释放正在占用对象的对象锁，直到被唤醒</p>
<h3 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">o.notify();</span><br></pre></td></tr></table></figure>

<p>唤醒当前对象上等待的线程，但是不释放对象锁</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>wait和notify方法用在共享对象上，使用同步控制synchronized控制同步对象才有效，需要和多线程并发配合使用</p>
<p>如果没有synchronized占用共享对象的锁，当前线程无法获取锁，也就没有wait的让出占用的对象锁</p>
<h3 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h3><p>生产者-消费者模式是一种特殊的需求，两个线程，一个生产者线程，一个消费者线程，生产者生产共享数据，消费者消费共享数据; 生产满了，不能继续生产，消费者需要进行消费；消费完了，不能继续消费，需要生产者继续生产</p>
<p>生产者：producer </p>
<p>消费者：consumer</p>
<p>产品：共享数据</p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><p>一共生产一个数据，需要交替生产和消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 共享数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list;</span><br><span class="line"></span><br><span class="line">    Producer(List&lt;Object&gt; list)&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">                <span class="comment">// 已经有数据</span></span><br><span class="line">                <span class="keyword">if</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 当前线程阻塞，让出对象锁</span></span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 还没有数据,生产数据</span></span><br><span class="line">                Object object = <span class="keyword">new</span> Object();</span><br><span class="line">                list.add(object);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 生产 "</span> + object);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唤醒正在等待的线程</span></span><br><span class="line">                list.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 共享数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list;</span><br><span class="line"></span><br><span class="line">    Consumer(List&lt;Object&gt; list)&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">                <span class="comment">// 如果没有资源，消费者线程阻塞，让出对象锁</span></span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 有数据，取出数据</span></span><br><span class="line">                Object o = list.remove(<span class="number">0</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 消费 "</span> + o);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唤醒对象上在等待的线程</span></span><br><span class="line">                list.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java-SE</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet路径有关的问题</title>
    <url>/2020/09/26/servlet_path/</url>
    <content><![CDATA[<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><pre><code>1. getRequestDispacher(url) : 只有相对路径，相对于项目路径，还是相对于当前文件路径
    *  ServletRequest接口中的参数路径不仅可以相对于当前Servlet上下文根，还可以相对与当前Servlet路径    
    *  因为在getRequestDispatcher(url)方法中封装了ServletContext.getRealPath()以获得相应的项目根路径，再通过字符串相加，从而可以获得一个完整的路径

2. 如果在静态页面中引用资源，可以直接写拦截路径，不需要增加/,默认在当前项目的文件夹下，如果增加/,会在当前目录的上一级目录中寻找资源
3. 如果使用 /xxxx/xx，则认为在当前项目的路径下寻找资源（在项目的路径下寻找资源）
4. 如果使用 xxxx/xxx,会将当前访问资源的上一级目录作为根目录，进行字符串拼接，寻找目标资源（在当前的路径下寻找资源）

5. 在使用的时候，可以按照访问的路径长短来进行转发资源的url书写
    * 在同一个访问路径下，可以直接使用文件名作为url参数，会得到想要的资源
    * 不在同一访问路径下，可以使用项目文件路径，就是在注解中使用的路径，也可以访问目标资源

总结：
    1. 如果是在静态页面，比如html,如果访问路径不加/，意味着在当前的项目路径下寻找资源；如果增加/,意味着在当前项目路径的上一级目录中寻找资源
    2. 如果是在servlet中进行转发，使用/xx,意味着从项目路径下寻找资源；不使用/，意味着从当前的访问路径中寻找资源
    3. res.getContextPath()查找当前的上下文路径，不能用在转发上</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/26/servlet_path/dispacher_1.png" alt="静态页面的访问形式"><br><img src="/2020/09/26/servlet_path/dispacher_2.png" alt="两种路径的区别"><br><img src="/2020/09/26/servlet_path/dispacher_url_use.png" alt="url的格式，使用方式"></p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><pre><code>1. sendRedirect(url):只有相对于项目路径的url
    * 通过使用 req.getContextPath()+&quot;/xxx/xxx&quot;进行资源的访问</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/26/servlet_path/sendredirect_1.png" alt="sendRedirect"></p>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><pre><code>* 不需要增加/,默认在当前项目的文件夹下，如果增加/,会在当前目录的上一级目录中寻找资源</code></pre>]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2020/09/19/servlet/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="两种架构"><a href="#两种架构" class="headerlink" title="两种架构"></a>两种架构</h3><pre><code>1. C/S架构和B/S架构
    C/S：Client/Server，客户端和服务器
        * 必须在客户端安装特定软件
        * 图形显示效果好，但是在服务器的软件和功能升级的时候，客户端也必须一起升级

    B/S: Brower/Server，浏览器和服务器
        * 无需安装客户端，任何浏览器都可以进行访问
        * 涉及到升级的，只需要升级服务器就可以了
        * 需要使用HTTP协议</code></pre><h3 id="服务器简介"><a href="#服务器简介" class="headerlink" title="服务器简介"></a>服务器简介</h3><pre><code>1. 什么是web？
    Web（World Wide Web）称为万维网，简单理解就是网站，表示internet主机上供外界访问的资源。
    资源分类：
        * 静态资源：Web页面中供人们浏览的数据始终是不变的。（HTML,CSS）
        * 动态资源：Web页面中人们浏览的数据是根据程序产生的，不同的时间，甚至不同的设备访问看到的内容是不同的。（JSP,Servlet）

2. 什么是Web服务器？
    Web服务器是运行以及发布Web应用的一个容器，只有将开发的Web项目放置到该容器中，才能使网络中的用户通过浏览器访问。

3. 常见服务器
    * 开源：
        1. Tomcat,主流的服务器之一
        2. jetty,淘宝的使用
        3. resin,效率最高的
        用法相同，只有开启和关闭服务器的命令上有差别

4. Tomcat服务器：
    * Apache软件基金会的Jakarta的一个核心项目，免费开源，支持JSP和servlet规范。
    * 技术先进，性能稳定，比较主流的Web服务器

    1. 下载安装

    2. Tomcat的目录结构
        1. bin: 二进制可执行文件
        2. conf:
            * server.xml,Tomcat服务器的配置信息，修改端口号，字符编码等
            * web.xml，项目部署描述文件
        3. lib: Tomcat的类库，jar包，服务器运行需要的jar包
        4. logs: 日志文件
        5. temp: 临时文件，Tomcat停止后可以删除
        6. webapps: 所有部署的项目，每个文件夹都是一个项目，ROOT是一个特殊的项目，在没有写地址栏时，对应的就是ROOT项目。
        7. work: 运行生成的文件，最终运行的文件都在这里

    3. Tomcat的启动
        * 在安装目录下的bin,双击startup.bat,显示毫秒数，启动成功
        * 在浏览器内输入，http://localhost:8080,出现页面，则显示成功

    4. 停止Tomcat
        双击shutdown.bat即可关闭

    5. 修改默认端口号
        在conf文件夹的内部，打开server.xml,找到&lt;connector&gt;标签，可以修改默认端口号
        修改后，重启Tomcat可以使用修改后的端口

    6. 项目部署的访问静态资源
        Tomcat是Web服务器，项目存在于webapps内部，通过特定的URL访问

        * 创建项目
            在webapps中建立文件夹，myapp
                - 创建WEB—INF，存放项目的核心内容
                    * 创建.classes文件夹，存放.class文件
                    * 创建lib,存放jar文件
                    * 创建web.xml，项目配置文件
                - 静态资源，与WEB—INF同级目录

        * URL访问资源
            在浏览器输入：http://localhost:8080/myapp/hello.html,可以访问到资源

    7. Tomcat的响应流程
        一旦用户访问，服务器会到webapps查找对应的资源文件，找到之后，回响应用户请求，显示对应的资源文件


    8. Tomcat的常见错误
        * Tomcat闪退
            JAVA_HOME配置是否有问题

        * 404
            服务器访问资源不存在，产生404</code></pre><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="Servlet的基础概念"><a href="#Servlet的基础概念" class="headerlink" title="Servlet的基础概念"></a>Servlet的基础概念</h3><pre><code>1. 含义
    * Server Applet的简称，是服务器端的程序（代码，功能实现），可交互式的处理客户端发送到服务器的请求，并完成响应操作。
    * 动态网页技术

2. 作用
    * 接收客户端发送的请求，并完成相应的操作
    * 动态生成网页
    * 将包含操作结果的网页响应给客户端</code></pre><h3 id="Servlet开发步骤"><a href="#Servlet开发步骤" class="headerlink" title="Servlet开发步骤"></a>Servlet开发步骤</h3><pre><code>1. 搭建开发环境
    将Servlet相关的jar包(lib/servlet-api.jar)导入classpath中

2. 编写Servlet的实现类
    * 实现javax.servlet.Servlet接口
    * 重写方法
    * 在service()核心编写语句

3. 将编译生成的.class文件放在WEB-INF/classes文件下
4. 修改web.xml的配置信息</code></pre><blockquote>
</blockquote>
<pre><code>&lt;servlet&gt;
&lt;!-- 为指定的class起别名 --&gt;
  &lt;servlet-name&gt;my&lt;/servlet-name&gt;
  &lt;servlet-class&gt;MyServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;!-- 访问资源的映射。使用/来访问MyServlet资源 --&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;my&lt;/servlet-name&gt;
  &lt;!-- 访问路径，浏览器的访问路径 --&gt;
  &lt;url-patten&gt;/&lt;/url-patten&gt;
&lt;/servlet-mapping&gt;

url-patten:配置的内容就是浏览器地址栏输入的URL项目名称后资源的内容

5. 错误
    500 ：服务器端错误</code></pre><h3 id="使用IDEA开发部署Servlet"><a href="#使用IDEA开发部署Servlet" class="headerlink" title="使用IDEA开发部署Servlet"></a>使用IDEA开发部署Servlet</h3><pre><code>1. 步骤
    * 创建项目，选择Java EE 7，并勾选Web Application
    * 输入项目名称和保存位置，点击Finsh，完成项目创建

2. 文件目录结构
    * .idea: 项目配置文件
    * src:存放Java代码
    * web : 存放静态资源
        WEB-INF:项目配置文件，classes和jar文件
            web.xml:
        index.jsp:动态页面

3. 使用方式
    * 导入外部jar包，servlet-api.jar
    * 重写实现类实现Servlet接口
    * 将访问路径进行绑定，使用servlet 和 servlet-mapping进行路径绑定
    * 开启服务，进行结果查看

4. IDEA集成Tomcat服务器
    * File -&gt; Setting -&gt; ApplicatioServices -&gt; + ,导入Tomcat的解压缩位置
    * 点击Edit Configurations,将项目放置到Deployment中
    * 开启Tomcat

5. 手动导入第三方jar包
    * 在web目录下，WEB-INF建立lib文件夹，将需要导入的jar包复制，然后点击lib目录，使用右键，Add As Librarys

6. 导出war包
    * 项目完成后，可以打包成war包，将其放在Tomcat的webapps目录下，一旦开启服务器，可以自动解压，实现项目部署。
    * 步骤：
        1. Project Structure -&gt; Artifacts -&gt; + -&gt; Web Application:Archive -&gt; For 
        2. 构建项目，bulid -&gt; bulid Artifacts
        3. 会在项目的out文件夹下生成，war包，将该包复制到webapps中，在再次开启服务器时，会将该项目解压，部署

7. 热部署
    在不进行服务器重启的前提现，进行数据的更新
    整个项目从新部署，包括从新打上.war 文件。会清空session ，释放内存。

    * war包，项目最终完成，将其放在服务器的文件目录下，可以实现启动服务器的同时部署项目
    * IDEA的开发工具集成Tomcat,编译项目时，生成的文件会放置在out文件夹中，再次刷新浏览器，会得到最新的信息</code></pre><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><pre><code>1. 含义
    超文本传输协议（HyperText Transfer Protocol），是互联网的一种网络协议
    基于请求与响应模式的，无状态的，应用层的协议，运行于TCP协议之上

2. 特点    
    * 由于是基于请求和响应的，可以支持浏览器/服务器模式
    * 简单快速：
        客户端只向服务器发送请求方法和路径，服务器就可以发送响应数据，通信速度很快，请求的方法有GET,POST
    * 灵活：可以传输不同类型的数据
    * 无连接的：每次TCP连接只处理一个请求或多个，服务器处理完客户端的请求之后，会断开连接，可以减少开销
    * 无状态的：HTTP协议对于事务没有记忆能力

3. HTTP通信流程
    1. 客户端与服务器建立TCP连接（三次握手）
    2. 客户端发送请求
    3. 服务器接受请求，并响应
    4. 客户端与服务器关闭连接（四次挥手）

4. 请求报文
    当浏览器向服务器发出请求时，向服务器传递一个数据块，就是请求报文
    * 请求行 请求方法/地址 URI协议/版本
    * 请求头 Request Header：可以接受的数据，语言，端口号，以及当前浏览器信息    
    * 空行
    * 请求正文    

5. 响应报文
    当服务器响应浏览器的请求，向浏览器传递一个数据块，就是响应报文
    * 状态行 
    * 响应头 Respone Header
    * 空行
    * 响应正文    

6. 常见状态码</code></pre><table>
<thead>
<tr>
<th align="center">状态编码</th>
<th align="center">状态描述</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">OK</td>
<td align="center">客户端请求成功</td>
</tr>
<tr>
<td align="center">302</td>
<td align="center">Found</td>
<td align="center">临时重定向</td>
</tr>
<tr>
<td align="center">403</td>
<td align="center">Forbidden</td>
<td align="center">服务器收到请求，但是拒绝提供服务，在正文中给原因</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">Not Found</td>
<td align="center">请求的资源不存在</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">Internal Server Error</td>
<td align="center">服务器错误，无法完成请求</td>
</tr>
</tbody></table>
<h2 id="Servlet深入"><a href="#Servlet深入" class="headerlink" title="Servlet深入"></a>Servlet深入</h2><h3 id="Servlet核心接口和类"><a href="#Servlet核心接口和类" class="headerlink" title="Servlet核心接口和类"></a>Servlet核心接口和类</h3><pre><code>1. Servlet的实现类
    * 通过实现Servlet接口创建Servlet类
    * 继承GenericServlet类
    * 继承HttpServlet类

2.1 Servlet接口
    Servlet是Servlet API的最重要的接口，所有的Servlet都会与该接口相关联，或是直接实现该接口，或是间接继承该接口的实现类

    接口中的方法：
    void init()
    ServletConfig getServletConfig()
    void service(ServletRequest request,ServletRespone respone)
    String getServletInfo()
    void destroy()

2.2 GenericServlet抽象类
    提供了生命周期方法init和destroy的实现方法，我们只需要实现service方法就可以
    实现了Servlet接口，重写了除了service()之外的所有方法
    一旦我们继承了该抽象类，只需要重写该方法就行

2.3 HttpServlet抽象类
    具体处理HTTP协议服务器端程序，继承了GenericServlet抽象类，重写了service()方法，针对HTTP协议的抽象类
    doGet,doPost,doPut,doDelete等方法</code></pre><h3 id="Servlet的创建方式"><a href="#Servlet的创建方式" class="headerlink" title="Servlet的创建方式"></a>Servlet的创建方式</h3><pre><code>1. 实现Servlet的接口</code></pre><blockquote>
</blockquote>
<pre><code>public class MyServlet implements Servlet { 
@Override
public void init(ServletConfig servletConfig) throws ServletException {

}

@Override
public ServletConfig getServletConfig() {
    return null;
}

@Override
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    System.out.println(new Date());
}

@Override
public String getServletInfo() {
    return null;
}

@Override
public void destroy() {

}</code></pre><p>}</p>
<pre><code>2. 继承HttpServlet抽象类（推荐）</code></pre><blockquote>
<pre><code>可以重写doGet,doPost，对访问进行修改
public class MyServlet3 extends HttpServlet {
    可以重写Http访问有关的方法
    doGet,doPost
}</code></pre></blockquote>
<pre><code>3. 常见错误
    1. 404:未找到资源
        * 地址书写错误
        * 地址没有问题，将IDEA的out目录删除，然后重新运行
    2. servlet地址重复
        * both mapped to the url-patten which is not permitted
    3. servlet配置地址错误</code></pre><h3 id="Servlet的配置方式"><a href="#Servlet的配置方式" class="headerlink" title="Servlet的配置方式"></a>Servlet的配置方式</h3><pre><code>1. 使用web.xml（2.5之前）</code></pre><blockquote>
<pre><code>&lt;!-- 建立访问映射 --&gt;
  &lt;servlet&gt;
    &lt;!-- 名称 --&gt;
    &lt;servlet-name&gt;servlet&lt;/servlet-name&gt;
    &lt;!-- 全限定类名 --&gt;
    &lt;servlet-class&gt;com.servlet_02_start.servlet.MyServlet&lt;/servlet-class&gt;
    &lt;!-- 启动时加载 --&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/start&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;</code></pre></blockquote>
<pre><code>url-patten的匹配规则：</code></pre><table>
<thead>
<tr>
<th align="center">含义</th>
<th align="center">具体</th>
<th align="center">触发时机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">精确匹配</td>
<td align="center">/具体的名称</td>
<td align="center">只有url路径是具体的名称的时候才会出发Servlet</td>
</tr>
<tr>
<td align="center">后缀匹配</td>
<td align="center">*.xxx</td>
<td align="center">只要是以xxx结尾的就匹配</td>
</tr>
<tr>
<td align="center">通配匹配符</td>
<td align="center">/*</td>
<td align="center">匹配所有的请求,包括服务器的所有资源</td>
</tr>
<tr>
<td align="center">通配匹配符</td>
<td align="center">/</td>
<td align="center">匹配所有的请求,包括服务器的所有资源,不包括.jsp</td>
</tr>
<tr>
<td align="center">&gt;   <strong>通配符的匹配并不影响精确匹配的结果</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>load-on-startup标签
    * 元素标记容器是否在web应用启动的时候加载servlet
    * 值必须是整数，值越小，优先级越高，加载的时机越早，表示在初始化时被加载的顺序
    * 如果不写或者是负数，表示在servlet被使用的时候加载
    * 如果值相同，则按照顺序加载servlet,0优先级最高

2. 使用注解配置（Servlet3.0之后）
    类名之上添加，不用在.xml中配置
    @WebServlet注解
        属性：
            * name:servlet的名称，可以不写
            * value:配置url路径，可以配置多个
            * urlPattens:配置url路径，与value作用相同，但不能同时使用
            * loadOnStartup:表示配置创建servlet的时间，默认-1，表示在访问的时候创建

注解和web.xml之间没有冲突</code></pre><h2 id="Servlet应用"><a href="#Servlet应用" class="headerlink" title="Servlet应用"></a>Servlet应用</h2><h3 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h3><pre><code>获取客户端请求，所有的客户端的请求数据都存在于Request对象里</code></pre><h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><pre><code>1. get提交的数据会放在URL之后，以?分隔，URL和数据，参数之间以&amp;连接
2. get方式明文传递，数据量小，不安全
3. 效率高，浏览器默认为GET请求
4. 对应的方法为doGet</code></pre><h4 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h4><pre><code>1. post请求把提交的数据放在HTTP的Body中
2. post密文传输，数据量大，安全
3. 效率相对不高
4. 对应的Servlet方法是doPost</code></pre><h4 id="Request的常用方法"><a href="#Request的常用方法" class="headerlink" title="Request的常用方法"></a>Request的常用方法</h4><pre><code>1. 方法</code></pre><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String getParameters(String name)</td>
<td align="center">组件名称</td>
<td align="center">根据表单组件名称获取数据</td>
</tr>
<tr>
<td align="center">void setCharacterEncoding(String chaset)</td>
<td align="center">设置字符编码</td>
<td align="center">指定请求的编码</td>
</tr>
</tbody></table>
<h4 id="Request的应用"><a href="#Request的应用" class="headerlink" title="Request的应用"></a>Request的应用</h4><pre><code>1. 从表单中使用get方法获取数据</code></pre><blockquote>
<pre><code>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    //1.获取用户的请求
    String username = req.getParameter(&quot;username&quot;);
    String password = req.getParameter(&quot;password&quot;);
    System.out.println(&quot;username:&quot;+username+&quot;  --&gt; &quot;+&quot;password:&quot;+password);
}
&lt;form action=&quot;register&quot; method=&quot;get&quot;&gt;
    用户名:&lt;label&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
&lt;/label&gt;&lt;br/&gt;
    密码:&lt;label&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;
&lt;/label&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;
&lt;/form&gt;</code></pre></blockquote>
<pre><code>通过浏览器的内容可看出，使用get方法提交的数据是明文，以?分隔URL和数据，以&amp;拼接参数

问题：get方法参数乱码
    客户端和服务器端的编码不一致，可以使用统一的编码格式，按照此编码进行数据的传输和接受

    Tomcat的7以及以下版本，客户端以UTF-8的编码格式进行数据传输，服务器以ISO8859-1的字符编码来接收数据，两边的编码方式不一样，导致乱码问题。

    可以在服务器接受收数据的时候以IOS8859-1来接收，在进行编码转换

    Tomcat的8版本解决了get方法的乱码问题

2. 使用post方法获取数据</code></pre><blockquote>
<pre><code>protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
  //设置统一编码
  req.setCharacterEncoding(&quot;UTF-8&quot;);     
    //1.获取用户的请求
    String username = req.getParameter(&quot;username&quot;);
    String password = req.getParameter(&quot;password&quot;);
    System.out.println(&quot;username:&quot;+username+&quot;  --&gt; &quot;+&quot;password:&quot;+password);
}</code></pre></blockquote>
<pre><code>通过浏览器的内容可看出，使用post方法提交的数据没有出现数据信息,只有接受的路径名称，更安全

问题：post中文乱码
    客户端的编码格式为UTF-8,在post使用的时候，将服务器的编码格式转化为UTF-8
    使用ServletRequest的setCharacterEncoding设置编码</code></pre><h3 id="Respone对象"><a href="#Respone对象" class="headerlink" title="Respone对象"></a>Respone对象</h3><pre><code>响应客户端请求，并向客户端输出信息    </code></pre><h4 id="Resopne的主要方法"><a href="#Resopne的主要方法" class="headerlink" title="Resopne的主要方法"></a>Resopne的主要方法</h4><table>
<thead>
<tr>
<th>方法名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>setHeader(name,value)</td>
<td>设置响应信息头</td>
</tr>
<tr>
<td>setContentType(String)</td>
<td>设置响应文件类型,文件编码</td>
</tr>
<tr>
<td>setCharacterEncoding(String)</td>
<td>设置响应编码</td>
</tr>
<tr>
<td>getWriter()</td>
<td>获取字符输出流,返回数据</td>
</tr>
</tbody></table>
<h5 id="响应数据给客户端"><a href="#响应数据给客户端" class="headerlink" title="响应数据给客户端"></a>响应数据给客户端</h5><blockquote>
<pre><code>//响应数据给客户端
  resp.setCharacterEncoding(&quot;UTF-8&quot;);
  PrintWriter printWriter = resp.getWriter();
  printWriter.println(&quot;OK&quot;)</code></pre></blockquote>
<pre><code>问题：出现中文乱码
    和Request的乱码原因相同
    1. 方法一
    * 使用setCharacterEncoding(&quot;UTF-8&quot;)方法来进行服务端编码格式设置
    * 使用setHeader(&quot;Content-type&quot;,&quot;text/html;charset=UTF-8&quot;);
    2. 方法二
    * setContentType(&quot;text/html;charset=UTF-8&quot;),同时设置文件类型和编码格式，必须在获取输出流之前使用</code></pre><h3 id="案例-数据传递"><a href="#案例-数据传递" class="headerlink" title="案例 数据传递"></a>案例 数据传递</h3><pre><code>问题
1. 在servlet中，调用业务逻辑和显示页面都在同一个servlet中，职能不单一，不利于后期维护
2. 可以将业务逻辑和显示信息分离

单独写类进行业务逻辑、显示信息的打印
XxxController extend HttpServlet
XxxJsp extend HttpServlet

如何跳转到JSP
如何将查询到的数据传送给展示的servlet</code></pre><h4 id="转发（request）"><a href="#转发（request）" class="headerlink" title="转发（request）"></a>转发（request）</h4><pre><code>转发的作用在服务器端，将请求发送给服务器的其他资源，共同完后一次请求</code></pre><h5 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h5><pre><code>1. 页面跳转实现
    在调用业务逻辑的servlet中，编写
        request.getRequestDispatcher(&quot;/目标url-patten&quot;).forward(request,respone)

    页面跳转属于同一次请求，客户端察觉不到转发的过程，在服务器内部进行跳转，地址栏不发生改变</code></pre><h5 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h5><pre><code>1. forword表示同一次请求，在服务器内部内部跳转，可以共享同一次request作用域的数据

2. request作用域: 拥有存储数据的空间，作用范围是一次请求(可以进行多次转发)
    * 可以将数据存储到request内部，在一次请求的内部进行数据传递，任意位置获取数据
    * 可以传递任意数据类型(基本数据类型，对象，集合等)

3. request数据存储：以键值对存储数据
    * request.setAttribute(key,value)：key，String类型，value,Object类型
    * 将数据以键值对的方式存储在数据空间内部

4. 获取数据
    * request.getAttribute(key)
    * 通过String类型的key访问value
    * 需要转换数据类型</code></pre><h5 id="转发的注意事项"><a href="#转发的注意事项" class="headerlink" title="转发的注意事项"></a>转发的注意事项</h5><pre><code>1. 转发是服务器的行为
2. 转发浏览器只有一次请求
3. 浏览器地址不变
4. 转发两次的跳转信息不会丢失，可以使用request作用域传递数据
5. 转发只能将请求转发给同一个web中的组件</code></pre><h4 id="重定向-（respone）"><a href="#重定向-（respone）" class="headerlink" title="重定向 （respone）"></a>重定向 （respone）</h4><pre><code>重定向作用在客户端，客户端将请求发送给服务器之后，服务器响应给客户端一个新的请求地址，客户端重新发送请求</code></pre><h5 id="页面跳转-1"><a href="#页面跳转-1" class="headerlink" title="页面跳转"></a>页面跳转</h5><pre><code>1. 实现
    * respone.sendRedirect(&quot;目标URI&quot;)
    * 表示服务器中的一个资源，资源在服务器中的路径(/项目/资源)

    客户端做了两次请求，地址栏发生了改变</code></pre><h5 id="数据传递-1"><a href="#数据传递-1" class="headerlink" title="数据传递"></a>数据传递</h5><pre><code>1. sendRedirect跳转时，地址栏发生改变，代表客户端重新发送的请求，属于两次请求

2. respone没有作用域，两次的request数据无法共享

3. 传递数据：
    使用拼接字符串进行数据传递(&quot;/webproject/b&quot;+&quot;?name=1&amp;password=1&quot;)

4. 获取数据
    使用request.getParameters,只能是string的数据类型</code></pre><h5 id="重定向注意实项"><a href="#重定向注意实项" class="headerlink" title="重定向注意实项"></a>重定向注意实项</h5><pre><code>1. 客户端的行为
2. 浏览器有两次请求
3. 浏览器地址栏发生改变
4. 两次跳转的传输信息会丢失(request范围)
5. 重定向可以指向任意资源，包括其他站点的资源</code></pre><h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><h3 id="生命周期的四个阶段"><a href="#生命周期的四个阶段" class="headerlink" title="生命周期的四个阶段"></a>生命周期的四个阶段</h3><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><pre><code>1. 当用户第一次访问servlet时，由容器调用servlet的构造方法创建servlet对象，也可以在容器启动之后进行创建，使用load_on_startup可以控制对象的创建时间    
2. 只进行一次实例化</code></pre><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre><code>1. 在初始化阶段，init()被调用，方法定义在javax.servlet.Servlet的接口中，以servletConfig对象作为参数
2. init()只执行一次</code></pre><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><pre><code>1. 当客户端有一个请求，容器就会将ServletRequest与响应ServletRespone转给对应的servlet对象，以参数的形式传给service()
2. service()执行多次</code></pre><h4 id="死亡"><a href="#死亡" class="headerlink" title="死亡"></a>死亡</h4><pre><code>1. 当容器停止或者重新启动都会销毁servlet对象
2. destroy()执行一次</code></pre><h3 id="Servlet的特性"><a href="#Servlet的特性" class="headerlink" title="Servlet的特性"></a>Servlet的特性</h3><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><pre><code>1. 问题
    servlet对象只创建一个实例对象，类似于单例模式，而Tomcat服务器容器可以同时多个线程并发访问同一个servlet,如果某个线程对成员变量进行修改，会造成线程安全问题

2. 解决线程安全问题
    * synchronized同步锁
        将存在线程安全问题的代码放入synchroized内部

        但是servlet只进行一次实例化，在线程进行访问的时候，对业务进行上锁，多个其他线程会等待释放锁，效率比较低

    * 实现SingleThreadModel接口
        servlet实现SingleThreadModel接口，每个线程会创建自己的servlet实例，请求不存在资源共享的问题，没有线程安全问题，但是servlet已经不使用

    * 使用局部变量，防止共享资源的出现
        推荐使用局部变量进行数据操作</code></pre><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h3 id="现有问题"><a href="#现有问题" class="headerlink" title="现有问题"></a>现有问题</h3><pre><code>1. HTTP协议是无状态的，不能保存每次提交的信息
2. 如果用户发来一个新的请求，服务器无法知道是否与上次的请求有关
3. 如果需要多次进行请求的操作，没有关联，难以进行下去</code></pre><h3 id="状态管理的概念"><a href="#状态管理的概念" class="headerlink" title="状态管理的概念"></a>状态管理的概念</h3><pre><code>将浏览器与web服务器的多次交互当作一个整体来处理，并且将多次的交互数据保存下来</code></pre><h3 id="状态管理的分类"><a href="#状态管理的分类" class="headerlink" title="状态管理的分类"></a>状态管理的分类</h3><pre><code>1. 客户端状态管理：
    将状态保存在客户端：Cookie
2. 服务器状态管理：
    将状态保存在服务端：Session</code></pre><h2 id="Cookie的使用"><a href="#Cookie的使用" class="headerlink" title="Cookie的使用"></a>Cookie的使用</h2><h3 id="什么是Cookie"><a href="#什么是Cookie" class="headerlink" title="什么是Cookie"></a>什么是Cookie</h3><pre><code>1. Cookie是浏览器访问Web服务器的某个资源时，由web服务器在HTTP响应消息头中附带传送给浏览器的一小段数据(服务器创建，保存在浏览器端)
2. 一旦Web浏览器保存了某个Cookie，在每次访问该web服务器都应该将这个cookie附加在HTTP请求头上回传给服务器
3. 一个Cookie主要由标识该信息的名称和值组成(key:value)

Cookie的原理
    * 在浏览器首次连接服务器，并得到服务器的响应数据，由服务器创建一个Cookie响应给浏览器，浏览器将响应的Cookie进行存储
    * 在以后的请求中，每次的请求数据中都会添加Cookie数据，而服务器收到请求后会首先进行Cookie的比对，如果存在Cookie,就获取Cookie，进行下面的操作</code></pre><h3 id="创建Cookie"><a href="#创建Cookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h3><pre><code>1. 创建Cookie</code></pre><blockquote>
<pre><code>//1.创建Cookie对象
  Cookie ck = new Cookie(&quot;zxl&quot;,&quot;123456&quot;);
//2.将Cookie响应给浏览器
  resp.addCookie(ck);</code></pre></blockquote>
<blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/cookie1.png" alt="cookie在浏览器"><br><img src="/2020/09/19/servlet/cookie2.png" alt="cookie在浏览器2"></p>
<pre><code>2. 常用的设置：
    1. setPath()：指定可以获取Cookie的路径
    2. setMaxAge():设置生命周期    
        * &gt;0:设置过期时间，以秒为单位，不随浏览器的关闭而结束
        * =0:浏览器关闭,Cookie结束
        * &lt;0:浏览器临时存储，一旦内存清理或者浏览器关闭，就不存在，默认-1</code></pre><p><img src="/2020/09/19/servlet/cookie_setting.png" alt="Cookie的设置"></p>
<h3 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h3><pre><code>获取Cookie必须包含创建cookie对象时允许访问的的路径，即在创建cookie的setPath</code></pre><blockquote>
<p>//获取Cookie<br>    Cookie[] cookies = req.getCookies()；<br>    //2.获取需要的cookies<br>    if(cookies != null){<br>     for(Cookie cookie:cookies){<br>          System.out.println(“cookie”+cookie.getName()+”—&gt;”+cookie.getValue());<br>       }<br>      }</p>
</blockquote>
<h3 id="修改Cookie"><a href="#修改Cookie" class="headerlink" title="修改Cookie"></a>修改Cookie</h3><pre><code>只需要保证Cookie的名称和路径一致，就可以覆盖原来的cookie，只是名称一样的，不会进行覆盖
其余步骤和创建cookie一样</code></pre><blockquote>
<pre><code>Cookie ck = new Cookie(&quot;1&quot;,&quot;1&quot;)；
ck.setPath(&quot;/webs&quot;)；
ck.setMaxAge(60*60)；
resq.addCookie(ck)；</code></pre></blockquote>
<h3 id="Cookie编码与解码"><a href="#Cookie编码与解码" class="headerlink" title="Cookie编码与解码"></a>Cookie编码与解码</h3><pre><code>Cookie是不需要中文的，只能包含ASCII码，如果需要使用unicode，需要进行编码和解码    </code></pre><p><img src="/2020/09/19/servlet/charset.png" alt="编码异常"></p>
<pre><code>* 编码可以使用java.net.URLEncoder的encode(String str,String encoding)
* 解码可以使用java.net.URLDecoder的decode(String str,String encoding)</code></pre><h4 id="创建-读取带有中文的Cookie"><a href="#创建-读取带有中文的Cookie" class="headerlink" title="创建 读取带有中文的Cookie"></a>创建 读取带有中文的Cookie</h4><p><img src="/2020/09/19/servlet/encode_decode.png" alt></p>
<h3 id="Cookie的优点和缺点"><a href="#Cookie的优点和缺点" class="headerlink" title="Cookie的优点和缺点"></a>Cookie的优点和缺点</h3><pre><code>1. 优点：
    * 可以配置到期规则
    * 简单：基于文本结构，包含简单的键值对
    * 数据持久性：Cookie默认在到期之前可以一直存在于浏览器

2. 缺点
    * 数据大小受限制：一般浏览器的Cookie在4k,8k字节的限制
    * 用户配置为禁用，会限制Cookie的使用
    * cookie可能被篡改，对安全性造成威胁</code></pre><h2 id="Session对象"><a href="#Session对象" class="headerlink" title="Session对象"></a>Session对象</h2><h3 id="Session概述"><a href="#Session概述" class="headerlink" title="Session概述"></a>Session概述</h3><pre><code>1. Session用于记录用户的状态，是指在一段时间内，单个客户端与Web服务器的一连串相关的交互过程
2. 在一个Session中，一个用户可能会多次请求同一个资源，也有可能访问不同的服务器资源

Session的原理：
    * 服务器会为每一个会话分配一个Session对象
    * 同一个浏览器的多次请求，同属于一个会话
    * 首次使用Session时，服务器会创建Session，并创建Cookie存储SessionId发回服务器

Session对象是由服务器创建的，存储于服务器端</code></pre><h3 id="Session使用"><a href="#Session使用" class="headerlink" title="Session使用"></a>Session使用</h3><pre><code>1. Session作用域：拥有存储数据的空间，作用范围是一次会话
    * 一次会话，是使用同一个浏览器发送的多次请求，一旦浏览器关闭，则会话结束
    * 可以将数据存入Session,在一次会话的任意位置进行获取
    * 可以传递任意数据类型（基本数据，字符串，数组，集合等）</code></pre><h4 id="获取Session对象"><a href="#获取Session对象" class="headerlink" title="获取Session对象"></a>获取Session对象</h4><pre><code>在浏览器首次连接服务器时，服务器自动创建Session对象，并创建Cookie返回sessionId
//1.通过request对象获取Session对象</code></pre><p><code>HttpSession session = request.getSession();</code><br><code>System.out.println(session.getId());</code></p>
<h3 id="Session数据传递"><a href="#Session数据传递" class="headerlink" title="Session数据传递"></a>Session数据传递</h3><h4 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h4><pre><code>* setAttribute(属性名，Object)
    session.setAttribute(key,value);以键值对的形式存储数据</code></pre><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><pre><code>* getAttribute(属性名)
    session.getAttribute(key);获取数据</code></pre><h4 id="移除数据"><a href="#移除数据" class="headerlink" title="移除数据"></a>移除数据</h4><pre><code>* removeAttribute(key)
    session.removeAttribute(key)</code></pre><h3 id="Session的生命周期"><a href="#Session的生命周期" class="headerlink" title="Session的生命周期"></a>Session的生命周期</h3><pre><code>* 开始：浏览器首次使用到Session的请求，会创建Session
* 结束：
        浏览器关闭，则无效
        Session超时，则无效（可以设置最大有效时间，单位秒）
            session.setMaxInactiveInter
        手工销毁，则失效
            session.invalidate();//退出登录，注销</code></pre><h3 id="Session超时设置"><a href="#Session超时设置" class="headerlink" title="Session超时设置"></a>Session超时设置</h3><pre><code>session.setMaxInactiveInterval(60);</code></pre><h3 id="禁用session解决"><a href="#禁用session解决" class="headerlink" title="禁用session解决"></a>禁用session解决</h3><pre><code>由于session是借助cookie来进行传递的，如果浏览器禁止cookie，浏览器不会接收session，在下一次连接的时候，会创建一个新的session

URL重写：
    浏览器在访问服务器的地址时，不再使用原来的地址，而是经过改写的地址，原来的地址后面增加了sessionId

实现：
    使用respone.encodeRedirectURL(String url)生成新的URL，根据是否禁用cookie来在尾部追加SessionId</code></pre><h3 id="Seeeion的案例"><a href="#Seeeion的案例" class="headerlink" title="Seeeion的案例"></a>Seeeion的案例</h3><pre><code>* 进行登录验证</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/session_exp_1.png" alt="Seeeion的案例_进行登录验证"></p>
<pre><code>* 进行邮箱验证</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/session_exp_2.png" alt="Seeeion的案例_进行登录验证"></p>
<h3 id="Request-Session的区别"><a href="#Request-Session的区别" class="headerlink" title="Request,Session的区别"></a>Request,Session的区别</h3><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/request_session.png" alt="请求和会话"></p>
<h3 id="重定向和转发的区别"><a href="#重定向和转发的区别" class="headerlink" title="重定向和转发的区别"></a>重定向和转发的区别</h3><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/redirect_forward.png" alt="重定向和转发"></p>
<h3 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h3><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/cookie_session.png" alt="cookie session"></p>
<pre><code>* cookie和session都是保存浏览器访问服务器的状态，使用方式和存储位置不一样
* cookie存储的数据都是字符串，需要使用`respone.addCookie()`,将数据响应给浏览器，可以一次响应多个Cookie
* sesssion可以存储任意类型数据，直接`session.setAttribute()`,一个会话只有一个Session，一个SessionId</code></pre><h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><pre><code>* 全局对象，拥有作用域，对应tomcat的一个web应用
* 当web服务器启动时，会为每一个web应用程序创建一个ServletContext对象，共享的存储区
* ServletContext在服务器启动的时候创建，服务器关闭的时候销毁</code></pre><h3 id="获取ServletContext"><a href="#获取ServletContext" class="headerlink" title="获取ServletContext"></a>获取ServletContext</h3><pre><code>1. 使用GenericServlet对象
    * getServletContext(),HttpServlet继承了GenericServlet,可以使用this.getServletContext()获取对象

2. HttpServletRequest对象
    * getServletContext()

3. HttpSession
    * getServletContext()</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><pre><code>1. 获取当前项目的真实路径：
    * context.getRealPath()

2. 获取项目的上下文名称：部署时的路径，项目的名称
    * context.getContextPath()

3. 全局容器 : 整个web应用都可以使用
    * 存储数据：setAttribute(string,object)
    * 获取数据：getAttribute(string)
    * 移除数据：removeAttribute(string)</code></pre><h3 id="ServletContext特点"><a href="#ServletContext特点" class="headerlink" title="ServletContext特点"></a>ServletContext特点</h3><pre><code>* 唯一性：一个项目只有一个ServletContext
* 生命周期：只要容器不关闭或者应用不卸载，servletContext一直存在</code></pre><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 统计当前项目的访问次数</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/servletcontext_count.png" alt="servletcontext"></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><pre><code>现有问题
    代码冗余，可以抽取代码，比如编码问题</code></pre><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><pre><code>过滤器(Filter)是位于客户端和服务器目标资源的一道过滤技术</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/filter_exe.png" alt="过滤器的执行流程"></p>
<h3 id="filter作用"><a href="#filter作用" class="headerlink" title="filter作用"></a>filter作用</h3><pre><code>1. 执行在servlet之前，客户端发送请求的时候，会先经过过滤器，再到达目标资源；响应的时候，会根据执行流程再次反向执行filter
2. 可以解决多个servlet的代码冗余问题，编码处理，登录验证</code></pre><h3 id="filter的编写"><a href="#filter的编写" class="headerlink" title="filter的编写"></a>filter的编写</h3><pre><code>Servlet API提供了一个Filter接口，只要实现了这个接口，就会成为过滤器（Filter）</code></pre><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><pre><code>1. 编写java的实现代码
2. 编写doFileter()方法
3. 让请求继续下去，使用FilterChain,拦截链
    filterChain.doFilter(req,resp):让请求继续下去

在响应的时候，也会将响应传递给过滤器，然后再传递给客户端</code></pre><h3 id="filter的配置"><a href="#filter的配置" class="headerlink" title="filter的配置"></a>filter的配置</h3><pre><code>1. 注解配置
    @WebFilter(value = &quot;/过滤的目标资源&quot;)

2. 在web.xml中配置filter
    使用filter filter-mapping</code></pre><h3 id="过滤器链和过滤优先级"><a href="#过滤器链和过滤优先级" class="headerlink" title="过滤器链和过滤优先级"></a>过滤器链和过滤优先级</h3><pre><code>1. 过滤器链
    * 客户端对服务器请求之后，服务器会执行一组过滤器，那么这组过滤器就叫做过滤器链。
    * 每个过滤器实现特定的功能当第一个过滤器的doFilter方法被调用的时候，web服务器会创建一个代表过滤器链的filterChain对象，在doFilter方法中，开发人员如果调用了`FilterChain`的`doFilter`方法，web服务器会检查是否还有其他的过滤器，如果还有，就会执行第二个过滤器，如果没有，就调用目标资源。

2. 过滤器链的优先级
    * 如果全是注解，会按照类全名称的字典顺序
    * 如果全是xml,按照filter的注册顺序，从上往下
    * 两者都有，xml的优先级高于注解
    * 同时配置，会执行多次过滤</code></pre><h3 id="filter拦截路径设置"><a href="#filter拦截路径设置" class="headerlink" title="filter拦截路径设置"></a>filter拦截路径设置</h3><pre><code>1. 精确拦截;
    /index.jsp
2. 后缀拦截:
    *.jsp，不需要加/
3. 通配符拦截
    /* ,/aaa/bbb/*
    不能使用/进行拦截</code></pre><h3 id="filter使用场景"><a href="#filter使用场景" class="headerlink" title="filter使用场景"></a>filter使用场景</h3><pre><code>1. 过滤器解决编码问题
    * 统一解决字符编码问题
2. 解决权限验证问题
    * 在过滤器中验证是否登录过服务器</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/errors_01.png" alt></p>
]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM</title>
    <url>/2020/09/18/ssm/</url>
    <content><![CDATA[<h2 id="SSM框架的整合"><a href="#SSM框架的整合" class="headerlink" title="SSM框架的整合"></a>SSM框架的整合</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>SSM,spring springmvc mybatis三大框架的整合，可以使用多种方式，这里使用xml+注解的方式</code></pre><h3 id="整合的思路"><a href="#整合的思路" class="headerlink" title="整合的思路"></a>整合的思路</h3><pre><code>1. 以spring框架为核心，进行其他的框架的整合(针对各个框架的使用范围进行整合)</code></pre><p><img src="/2020/09/18/ssm/ssm_1.png" alt></p>
<h4 id="导入的坐标版本"><a href="#导入的坐标版本" class="headerlink" title="导入的坐标版本"></a>导入的坐标版本</h4><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_version.png" alt="使用的坐标版本"></p>
<h4 id="日志文件的配置"><a href="#日志文件的配置" class="headerlink" title="日志文件的配置"></a>日志文件的配置</h4><pre><code>1. pom.xml
    * log4j
    * slf4j-api
    * slf4j-log4j12
        完成日志文件的配置，将标准日志转为log4j格式日志</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_log.png" alt="日志文件的配置"></p>
<pre><code>2. log4j.propreties配置文件</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_log2.png" alt="日志文件的配置"></p>
<h4 id="spring框架的配置"><a href="#spring框架的配置" class="headerlink" title="spring框架的配置"></a>spring框架的配置</h4><pre><code>1. pom.xml配置
    * spring-context: 容器，扫描数据
    * spring-aop
    * spring-tx
    * spring-test:单元测试
    * spring-jdbc
    * aspectjweaver:切入点，切面
    * jstl: Java EL表达式</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_spring1.png" alt="spring的配置1"></p>
<pre><code>2. applicationContext.xml的配置
    * 配置需要扫描的包，指定不需要扫描的MVC层的包，MVC的数据由springMV来进行数据扫描</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_spring2.png" alt="spring的配置2"></p>
<pre><code>3. 配置完上述的配置文件
    可以使用spring的注解，进行对象注册</code></pre><h4 id="springMVC的整合"><a href="#springMVC的整合" class="headerlink" title="springMVC的整合"></a>springMVC的整合</h4><pre><code>1. pom.xml配置
    * spring-web
    * spring-webmvc
    * servlet-api
    * jsp-api</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_springmvc1.png" alt="springmvc的配置"></p>
<pre><code>2. web.xml配置
    * DispatcherServlet：前端控制器
    * CharacterEncodingFilter: 字符编码过滤器

3. springmvc.xml配置
    * 开启注解扫描：controller由springmvc来进行扫描
    * 开启视图解析器：InternalViewResolver
    * 配置静态资源过滤：mvc:resources
    * 配置开启springmvc注解支持
    * 配置监听器</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_springmvc2.png" alt="springmvc的配置"></p>
<pre><code>4. spring整合springMVC
    在启动服务器的时候，加载web.xml文件的时候，只加载了springMVC的配置文件，没有读取spring的配置文件来进行容器的创建以及加载。

    使用监听器：ContextLoaderListener,来监听ServletContext实例的创建，一旦创建，就会扫描spring的配置文件，进行spring容器的创建

    监听器的默认配置文件：/WEB-INF/applicationContext.xml
        1. 在/WEB-INF/复制文件
        2. 使用&lt;context-param&gt;进行容器扫描路径的配置</code></pre><p><img src="/2020/09/18/ssm/ssm_listener.png" alt="spring整合springmvc"></p>
<pre><code>5. 监听器的配置
    使用spring框架的监听器，在创建ServletContext的时候，同时扫描spring的配置文件，可以通知框架注册实例，以供数据注入</code></pre><h4 id="MyBatis的整合"><a href="#MyBatis的整合" class="headerlink" title="MyBatis的整合"></a>MyBatis的整合</h4><pre><code>1. pom.xml文件的配置
    * mybatis
    * mysql-connector-java
    * c3p0
    * mybatis-spring 整合jar包</code></pre><p><img src="/2020/09/18/ssm/ssm_dao_1.png" alt></p>
<pre><code>2. SqlMapConfig.xml配置
    * typeAlisaes：为实体类创建别名，使用package
    * 数据库连接环境
    * mappers: 配置映射文件

3. 整合思路
    * 将数据的DAO层的代理对象存入容器
    * 步骤
        1. 在applicationContext.xml文件编写使用MyBatis的文件步骤
        2. 编写数据库连接池bean对象</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/mybatis_spring_1.png" alt="数据连接池"></p>
<pre><code>3. 配置SqlSessionFactoryBean对象
可以使用参数设置生成的bean的名称，指定读取的配置文件以及mapper的配置文件</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/mybatis_spring_2.png" alt="将dao对象交由spring容器创建"></p>
<pre><code>4. 配置扫描的映射文件所在的包</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/mybatis_spring_3.png" alt="将dao对象交由spring容器创建"></p>
<pre><code>        5. 总结
            spring整合mybatis时，可以在核心配置文件applicationContext.xml中，整合mybatis的配置文件，可以将SqlMapConfig.xml文件的内容完全整合进核心配置文件，也可以整合部分，然后在核心配置文件中引用SqlMapConfig.xml文件。

4. 出现的错误</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/erroer_1.png" alt="web.xml或使用此应用程序部署的jar文件中解析"><br><img src="/2020/09/18/ssm/error_2.png" alt="classnotfound:org.apache.jsp.">    </p>
<h4 id="spring的声明式事务控制"><a href="#spring的声明式事务控制" class="headerlink" title="spring的声明式事务控制"></a>spring的声明式事务控制</h4><pre><code>1. 配置事务管理器
2. 配置事务通知
    * 配置事务的使用位置，传播级别。。
3. 配置AOP
    * 配置切入点表达式
    * 配置事务</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_transaction.png" alt="事务管理"></p>
]]></content>
      <categories>
        <category>SpringFramework</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2020/09/18/springMVC/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><pre><code>1. B/S，浏览器/服务器模式的开发中，服务端程序一般分为三层，展示层，业务层和持久层。
    * 展示层：WEB层，用来与客户端进行数据交互的，表现层采用MVC的设计
    * 业务层：处理业务逻辑
    * 持久层：与数据库进行交互

2. MVC?
    MVC(Model View Controller):模型视图控制器，一种设计模式
    * Model: javaBean,通常代指数据模型，用于封装数据
    * View:  jsp,jsp或者html,用于展示数据
    * Controller: servlet,处理用户交互的部分，处理程序逻辑的部分</code></pre><h3 id="SpringMVC的入门案例"><a href="#SpringMVC的入门案例" class="headerlink" title="SpringMVC的入门案例"></a>SpringMVC的入门案例</h3><pre><code>1. 项目环境搭建
    1. 选择maven工程的archetype
    2. 选择webapp模板
    3. 填写项目名称等信息
    4. 添加archetypeCagalog internal加快项目创建的速度
    5. 使用webapp在main目录下创建java和resources目录，并使用mark directory as声明</code></pre><blockquote>
<p><img src="/2020/09/18/springMVC/maven_createproject_quickstart.png" alt="maven_createproject_quickstart"></p>
</blockquote>
<blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/change_directory.png" alt="change_directory"></p>
<pre><code>2. 配置MVC项目的步骤
    1. 配置前端控制器，在servlet上配置控制器,主要是访问路径以及拦截</code></pre><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置前端控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<pre><code>&lt;!-- 配置过滤器 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;:初始化参数
              &lt;param-name&gt;encoding&lt;/param-name&gt;
              &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;</code></pre></blockquote>
<pre><code>2. 配置TomCat服务器
    配置项目路径，端口等服务器信息配置</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/quickstart_tomcat.png" alt="tomcat设置"></p>
<pre><code>3. 配置视图解析器
    在项目配置文件中配置视图解析器，配置前缀路径以及后缀文件名</code></pre><h3 id="SpringMVC实例解析"><a href="#SpringMVC实例解析" class="headerlink" title="SpringMVC实例解析"></a>SpringMVC实例解析</h3><pre><code>1. SpringMVC的流程的说明
    * 启动服务器，加载配置文件
        1. DispacherServlet被创建
        2. springmvc.xml被加载
        3. HelloController被加载到容器
        4. 开启注解扫描的包，配置视图解析器，开启MVC注解
    * 发送http请求，后台处理</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/quickstart_1.png" alt><br><img src="/2020/09/18/springMVC/quickstart_2.png" alt></p>
<pre><code>2. springMVC的三大组件(容器)
    * 处理器映射器：HandlerMapping
    * 处理器适配器：HandlerAdapter
    * 视图解析器：ViewResolver

    在开启springMVC的注解时，会自动加载处理器映射器，处理器适配器</code></pre><h2 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h2><h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><pre><code>1. @RequestMapping：建立请求和方法之间的关联
    path,value:请求路径的字符串

2. 使用位置
    * 放在方法上，可以直接使用路径来请求数据，二级目录
    * 放在类上，类上的路径为一级目录，可以先访问一级目录再访问二级目录的方法</code></pre><p><img src="/2020/09/18/springMVC/requestmapping.png" alt></p>
<pre><code>3. RequestMapping的属性: 任意两个属性之间是&amp;&amp;的关系
    1. value,path: 互为别名，都是指定请求的路径,请求的URL
    2. mathod: 用于指定请求的方法，method={RequestMethod.GET,RequestMethod.POST}等
    3. params: 指定限制请求参数的条件，支持简单的表达式，要求请求参数中的key和value必须和配置一样
        * params={&quot;accountName&quot;},请求参数中必须要有accountName
        * params={&quot;money!100&quot;},请求参数money不能是100
    4. headers: 发送的请求中必须包含的请求头</code></pre><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><pre><code>1. 含义
    把请求中指定名称的参数传给控制器的形参（形参赋值）

2. 使用位置
    * 只能定义在参数上
    * 在请求的参数名称和方法上的形参名称不一样时，使用注解进行映射

3. 属性
    1. name,value: 请求中的参数名称
    2. required: 默认true，请求中的参数名称必须与name属性的值相同</code></pre><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><pre><code>1. 含义
    用于获取请求体内容，直接使用得到的是 key=value&amp;key=value 的数据    
    get请求方式不适用，参数不在请求体

2. 属性
    required:是否必须要有请求体，默认为true。当取值为true时，使用get方式报错，为false时，使用get获取数据为null

3. 使用
    注解定义在参数上
    直接注解将请求体内部的数据以键值对的方式赋给指定的形参</code></pre><h4 id="PathVarible"><a href="#PathVarible" class="headerlink" title="@PathVarible"></a>@PathVarible</h4><pre><code>1. 含义
    绑定url中的占位符，url中有/delete/{id},{id}就是占位符

2. 属性
    * value: 指定占位符的名称
    * required: 必须包含占位符

3. 使用
    * 只能作用在参数上
    * value的名称必须和访问路径下的占位符的名称一致
    * 访问时只需要在访问路径的占位符上添加数据就可以了</code></pre><h5 id="RESTful编程风格"><a href="#RESTful编程风格" class="headerlink" title="RESTful编程风格"></a>RESTful编程风格</h5><pre><code>1. Representational State Transfer：
    表述性状态转换

2. 请求地址相同，但是具体的请求方法不同
    * 获取：GET
    * 创建：POST
    * 更新：PUT
    * 删除：DELETE</code></pre><h5 id="HiddentHttpMethodFilter"><a href="#HiddentHttpMethodFilter" class="headerlink" title="@HiddentHttpMethodFilter"></a>@HiddentHttpMethodFilter</h5><pre><code>1. 说明
    浏览器form表单只支持GET,POST请求，DELETE以及PUT不支持，这个过滤器可以将浏览器的请求改为指定的请求方式</code></pre><h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h4><pre><code>1. 说明
    获取请求头

2. 属性
    * name,value: 指定需要获取请求头中的那个属性名称
    * required: 默认true,是否必须有此属性名称

3. 使用
    * 只能作用在参数上
    * 必须指定想要获取的标签的名称</code></pre><h4 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h4><pre><code>1. 说明
    把指定的Cookie名称的值传入控制器方法参数

2. 属性
    * value: 指定Cookie的名称
    * required: 是否必须有此cookie

3. 使用
    * 作用在参数上
    * 需要指定cookie的key</code></pre><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h4><pre><code>1. 说明
    可以出现在方法和参数上
    * 方法：当前方法会在控制器的方法执行之前先执行，可以修饰没有返回值的方法，也可以修饰有返回值的方法
    * 参数：获取指定的参数给属性赋值

2. 属性
    * value: 用于获取数据的key,数据类型可以是JavaBean,也可以是集合

3. 使用
    * 当表单提交的字段不完整，可以保证没有提交的数据使用数据库原本的字段数据    </code></pre><h4 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h4><pre><code>1. 说明
    用于多次执行控制器方法之间的参数共享

2. 属性
    * value: 指定存入的属性名称
    * type: 指定存入的数据类型

3. 使用
    * 只能作用在类上
    * 可以借助Model来将数据存入Request域中</code></pre><h2 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>1. 绑定机制
    1. 表单提交的数据都是key=value格式的，username=hh&amp;password=oooo
    2. SpringMVC的参数绑定过程是把表单提交的数据作为控制器中的参数进行绑定的
    3. 表单的name和参数的名称必须是一样的（不一致可以使用@RequestParam）

2. 支持的数据类型
    1. 基本数据类型和字符串类型
    2. 实体类型（javaBean）
    3. 集合数据类型（List,Map）

3. 基本数据类型和字符串类型
    * 表单中的name属性和参数列表的名称一致，可以直接进行封装
    * 表单中的name属性和参数列表的名称不一致

4. 实体类型
    1. 简单的JavaBean
        * 表单中的name属性和实体类的属性名称一致，框架会自动封装
        * 使用@RequestParam进行映射

    2. 包含其他的JavaBean引用
        * 将引用的其他JavaBean的属性名称连同该对象的属性作为表单的name属性

5. 集合数据类型
    将集合的引用以及属性进行数据封装</code></pre><p><img src="/2020/09/18/springMVC/connection.png" alt="集合的参数封装"></p>
<h4 id="数据转换器"><a href="#数据转换器" class="headerlink" title="数据转换器"></a>数据转换器</h4><pre><code>1. 说明
    表单传输的数据都是字符串类型，SpringMVC框架进行了数据类型转换
    string-&gt; Integer, Double,...
    字符串转换为Date时，格式不正确，需要显式指定自定义类型转换器

2. 使用接口
    将S类型的数据转换为T类型
    public interface Converter&lt;S,T&gt;{
        T converter(S); S:source,T:target
    }
    将指定的数据类型进行转换，实现converter

3. 使用步骤
    1. 编写Converter接口的实现类，实现converter方法
    2. 配置自定义类型转换器
        * springMVC项目配置文件中配置，将自定义配置类加入ConversionServiceFactortBean中
    3. 配置转换器服务</code></pre><p><img src="/2020/09/18/springMVC/defaultconversion.png" alt="自定义类型转换器"></p>
<h2 id="Servlet-API"><a href="#Servlet-API" class="headerlink" title="Servlet API"></a>Servlet API</h2><h3 id="获取原生的Servlet-API"><a href="#获取原生的Servlet-API" class="headerlink" title="获取原生的Servlet API"></a>获取原生的Servlet API</h3><pre><code>1. 获取方式
    使用参数获取的方式，将希望获取到的对象作为参数绑定到路径

2. 实例
    @RequestMapping(&quot;/servletAPI&quot;)
    public String testServletAPI(HttpServletRequest request){

    }</code></pre><h2 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><pre><code>因为配置了视图解析器，包含String类型返回值，会自动解析我们配置的静态资源，会到指定的路径寻找返回值名称相同的文件
1. 字符串代表一个静态或者动态页面
2. 在方法中获取需要的数据，使用Request域来获取，将其填充在页面上显示</code></pre><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><pre><code>1. 默认值，返回一个和当前方法相同的访问路径的一个jsp文件</code></pre><p><img src="/2020/09/18/springMVC/void_01.png" alt="默认返回值void"></p>
<pre><code>2. 可以使用servlet的请求转发，重定向
    * 转发：request.getRequestDispatcher(&quot;/WEB-INF/pages/xx.jsp&quot;).forward(req,resp);
        自已手动转发的路径必须写当前项目的全路径，视图解析器不再自动寻找路径

    * 重定向：response.sendRedirect(req.getContextPath()+&quot;/WEB-INF/pages/xx.jsp&quot;)

    转发在当前的web项目内部进行，不需要带项目名称；重定向，不知道项目路径，需要加上项目路径

3. 直接进行响应
    直接使用输出流来响应数据</code></pre><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><pre><code>1. 说明
    ModelAndView对象为spring提供的一个对象，可以用来调整具体的JSP视图

2. 使用
    创建ModelAndView对象，使用addObject(key,Object)添加数据
    使用setViewName()指定返回的页面

    返回值String类型的与ModelAndView的实现机制相同，String基于ModelAndView来实现的</code></pre><p><img src="/2020/09/18/springMVC/model.png" alt></p>
<h3 id="使用关键字来进行转发和重定向"><a href="#使用关键字来进行转发和重定向" class="headerlink" title="使用关键字来进行转发和重定向"></a>使用关键字来进行转发和重定向</h3><pre><code>1. 需要使用视图解析器来进行资源的获取
    如果没有配置视图解析器，需要手动配置转发和重定向的路径

2. 基于返回值为字符串的方式
    * &quot;forward:success&quot; : 转发到配置好的路径下的指定后缀的页面
    * &quot;rediect:success&quot; ：重定向

3. 注意
    使用关键字，会使用UrlBaseViewReslover进行视图解析，会使用到配置的视图解析器</code></pre><h3 id="JSON数据：ResponseBody响应"><a href="#JSON数据：ResponseBody响应" class="headerlink" title="JSON数据：ResponseBody响应"></a>JSON数据：ResponseBody响应</h3><h4 id="过滤静态资源"><a href="#过滤静态资源" class="headerlink" title="过滤静态资源"></a>过滤静态资源</h4><pre><code>1. 问题
    在配置前端控制器的时候，使用了通配符 / 来进行URL拦截，DispatcherServlet拦截了除了.jsp之外的所有资源，静态资源也会被拦截，从而不能使用。如果希望不拦截静态资源，可以再springmvc.xml中配置。

2. 解决</code></pre><blockquote>
<pre><code>&lt;!-- 配置静态资源过滤: js下的文件不进行拦截 --&gt;
&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt; &lt;!-- js文件 --&gt;
&lt;mvc:resources mapping=&quot;/images/**&quot; location=&quot;/images/&quot;/&gt;
&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot;/&gt;</code></pre></blockquote>
<pre><code>location: webapp目录下的所有指定文件
mapping: 表示以/static开头的所有的请求路径</code></pre><h4 id="响应json格式数据"><a href="#响应json格式数据" class="headerlink" title="响应json格式数据"></a>响应json格式数据</h4><pre><code>1. 导入必须的包
    jackson-databind jackson-core jackson-annotations,可以由框架进行数据的赋值

2. 使用@ResponseBody
    将查询到的数据封装到json格式的页面中，完成异步请求，响应json格式数据</code></pre><h3 id="响应数据总结"><a href="#响应数据总结" class="headerlink" title="响应数据总结"></a>响应数据总结</h3><table>
<thead>
<tr>
<th align="center">返回值类型</th>
<th align="center">跳转页面</th>
<th align="center">要求</th>
<th align="center">使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String</td>
<td align="center">指定的返回字符串表示的页面</td>
<td align="center">使用视图解析器配置需要解析的页面</td>
<td align="center">在对应的文件夹下创建和返回值名称相同的页面</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">默认返回和访问路径相同的目录结构下的文件</td>
<td align="center">可以使用重定向和转发，Model来进行页面跳转，或者直接响应数据</td>
<td align="center">配合转发和重定向来使用</td>
</tr>
<tr>
<td align="center">ModelAndView</td>
<td align="center">使用setViewName()指定跳转的页面</td>
<td align="center">需要使用addAttribute()添加元素</td>
<td align="center">ModelMap</td>
</tr>
<tr>
<td align="center">关键字字符串</td>
<td align="center">使用关键字 redirect forward进行转发和重定向</td>
<td align="center">在返回值为字符串的格式下</td>
<td align="center">和String类似</td>
</tr>
<tr>
<td align="center">json格式数据</td>
<td align="center">返回json格式的数据</td>
<td align="center">使用第三方库来进行解析和包装</td>
<td align="center">使用@ResponseBody</td>
</tr>
</tbody></table>
<pre><code>* ModelAndView和String的实现机制类似
* 使用转发和重定向可以访问的资源范围不仅局限在定义的资源文件
* void的返回类型，可以使用上述三种方式来响应数据
* json格式的数据应该和ajax(异步 JavaScript XML)配合来使用</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="传统的文件上传"><a href="#传统的文件上传" class="headerlink" title="传统的文件上传"></a>传统的文件上传</h3><pre><code>1. form表单的要求
    * enctype的属性要求，multipart/form-data
    * method：post</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/file_upload.png" alt="文件上传1"></p>
<pre><code>2. 解析工具
    * 第三方jar包：commons-fileupload-1.4,commons-io-2.6</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/file_pom.png" alt="导入jar包"></p>
<pre><code>3. 步骤
    将本地文件上传至服务器
    * 编写文件上传的jsp文件
    * 导入第三方库，处理上传后的文件
    * 一旦提交表单，所有的数据会存在于request对象的域中，将数据传送给方法，进行处理</code></pre><blockquote>
<pre><code>//1.指定文件上传位置
    String path = request.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);
    System.out.println(path);
    //2.判断文件路径是否存在
    File file = new File(path);
    if (!file.exists()){
        //文件不存在，创建目录
        file.mkdirs();
    }
    //3.解析request对象，获取上传文件项
    DiskFileItemFactory fileItemFactory = new DiskFileItemFactory();
    ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);
    List&lt;FileItem&gt; fileItems = null;
    //4.解析
    try {
        fileItems = servletFileUpload.parseRequest(request);
        //遍历
        for(FileItem item:fileItems){
            //判断当前的item是否为上传文件项
            if(item.isFormField()){
                //普通表单
            }else {
                //上传文件
                //获取上传文件的名称
                String name = item.getName();
                //设置文件名称唯一,防止相同的文件名产生的覆盖
                String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
                name = uuid+&quot;_&quot;+name;
                //完成上传,指定路径上传文件
                item.write(new File(path,name));
                //删除临时文件
                item.delete();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }</code></pre></blockquote>
<h3 id="springMVC的文件上传"><a href="#springMVC的文件上传" class="headerlink" title="springMVC的文件上传"></a>springMVC的文件上传</h3><pre><code>1. 说明
    * springMVC框架提供了MultipartFile对象，该对象表示要上传的文件，要求变量名称必须和表单file标签的name属性名称相同
    * 由前端控制器获取请求，将请求传送给文件解析器来进行request对象的解析，获取文件上传项，再由控制器将获取到的文件上传项作为参数绑定到对应的方法上，在方法中只需要进行文件的上传就可以，不需要关注文件的解析和获取工作
    * 注意：
        参数绑定：方法的参数必须和file的name属性相同

2. 配置文件
    commons-fileupload connoms-io</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/springmvc_upload.png" alt="springMVC文件上传的原理"><br><img src="/2020/09/18/springMVC/springmvc_upload1.png" alt="springMVC文件上传的部分源码"></p>
<pre><code>一旦配置上传文件的大小，不能超过限制</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/springmvc_upload_error.png" alt="springMVC文件大小上传限制"></p>
<pre><code>2. 步骤
    * 书写文件上传表单
    * 配置文件解析器
        CommonsMultipartResoler,其中id属性必须为 multipartReslover
            可以进行依赖注入

    * 方法书写</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/springmvc_upload2.png" alt="springMVC文件上传"></p>
<h3 id="同一个服务器的文件上传总结"><a href="#同一个服务器的文件上传总结" class="headerlink" title="同一个服务器的文件上传总结"></a>同一个服务器的文件上传总结</h3><pre><code>springMVC的框架只是将解析文件的过程进行了封装，本质上还是使用FileItemFactory等进行文件解析，在方法中可以直接调用上传文件项

1. 通用上传文件步骤
    1. 获取上传文件目录，可以使用file.mkdirs()进行创建
    2. 对request域进行文件解析，获取文件项(FileItem)[文件解析器]
    3. 生成唯一Id,防止文件覆盖，UUID.randomUUID().toString().replace(&quot;_&quot;,&quot;&quot;);
    4. 文件上传，transferTo(new File(path,name));将文件上传到指定的路径下，生成指定文件名称的文件
    5. 清理临时文件</code></pre><h3 id="跨服务器方式的文件上传"><a href="#跨服务器方式的文件上传" class="headerlink" title="跨服务器方式的文件上传"></a>跨服务器方式的文件上传</h3><pre><code>1. 分服务器的目的
    不同的功能服务器将其分开，方便开发
        * 应用服务器
        * 数据库服务器
        * 缓存服务器

2. 步骤
    * 导入跨服务器传输文件的第三方jar包，jersey-core,jersey-client
    * 编写业务程序
        1. 确定上传的文件路径，文件服务器上的路径
        2. 获取上传文件项的UUID,生成唯一ID
        3. 获取客户端对象（客户端-服务器的方式建立连接）
            Client client = Client.create();
        4. 建立连接，
            WebResource resource = client.resource(path);
        5. 上传文件
            resource.put(upload.getBytes());</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/file_upload3.png" alt="跨服务器上传"></p>
<pre><code>3. 出现的错误
    1. 500：Method Not Allowed
        可以在文件服务器的文件目录下建立文件夹改变Tomcat服务器的readonly属性，Tomcat服务器的安装目录下的conf文件中的web.xml，属性值改为false</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/e1.png" alt></p>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><pre><code>1. 配置文件
    1. commons-fileupload_1.4.jar commons-io_2.5.jar
    2. CommonsMultipartResolver对象
    3. 需要下载的文件的文件名

2. 演示代码</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/filedown.png" alt="文件下载演示代码"></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><pre><code>Controller调用service,service调用dao,异常向上抛出，最终由DispatcherServlet找异常处理器进行处理。</code></pre><blockquote>
<p><img src="/2020/09/18/springMVC/error_process.png" alt="异常处理流程"><br><img src="/2020/09/18/springMVC/exception_1.png" alt="异常抛出演示"></p>
</blockquote>
<h3 id="springMVC的异常处理"><a href="#springMVC的异常处理" class="headerlink" title="springMVC的异常处理"></a>springMVC的异常处理</h3><pre><code>1. 步骤
    * 编写自定义异常处理类 （提示信息）
    * 编写异常处理器，必须实现异常处理器接口，HandlerExceptionResolver
    * 配置异常处理器（决定跳转页面）
        在springmvc.xml中增加bean标签，将异常处理器加载到容器中</code></pre><p><img src="/2020/09/18/springMVC/exception_2.png" alt="异常抛出"></p>
<h2 id="拦截器（Interceptor）"><a href="#拦截器（Interceptor）" class="headerlink" title="拦截器（Interceptor）"></a>拦截器（Interceptor）</h2><pre><code>springMVC的拦截器和servlet的Filter过滤器的作用类似，用于对处理器（controller）进行预处理和后处理。
    Interceptor chain : 拦截器链，对一组拦截器按照一定的顺序进行访问

interceptor和filter的区别
* interceptor: 只能在springMVC中，在配置/*之后，只会拦截访问的控制器方法，如果访问的是jsp,css,html不会进行拦截
* filter: servlet规范的部分，所有的java web都可以使用，在配置之后，对所有要访问的资源进行拦截

编写拦截器必须实现 HandlerInterceptor接口</code></pre><h3 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h3><pre><code>1. 步骤
    * 编写自定义拦截器类（implements HandlerInterceptor）
    * 在容器中注册该拦截器类
    * 声明需要拦截的对象

2. 注册拦截器
    * 可以编写多个拦截器，构成拦截器链
    * &lt;mvc:mapping path=&quot;&quot;&gt;：指定要拦截的请求路径</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/inter_1.png" alt></p>
<pre><code>3. 拦截的方法</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/inter_2.png" alt></p>
<pre><code>* preHandler: 预处理，在controller方法执行之前执行
    return true: 放行，继续执行后面的拦截器
    return false: 不放行，可以使用转发和重定向来进行页面跳转

* postHandler: 后处理，在controller方法执行结束，跳转页面之前执行

* afterCompletion: 页面执行结束后，执行这个方法</code></pre>]]></content>
      <categories>
        <category>SpringFramework</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Reflection</title>
    <url>/2020/09/10/reflection/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><pre><code>1. 反射（reflection）：动态语言的关键
    * 反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性和方法
    * 加载完类之后，在堆内存的方法区产生一个Class对象（一个类只有一个Class对象），这个对象就包含完整的类的信息，可以通过这个Class对象看到类的结构，通过对象看到类的结构的过程，叫做反射

2. 使用反射的应用
    * 在运行时判断一个对象所属的类
    * 在运行时构造任意一个类的对象
    * 在运行时获取泛型的信息
    * 在运行时获取私有属性，私有方法
    * 在运行时父类的信息，父类上的泛型
    * 在运行时获取接口
    * 在运行时获取所在包，注解
    * 。。。

3. 相干的API
    * java.lang.Class
    * java.lang.reflect.Method    //方法
    * java.lang.reflect.Filed    //成员变量    
    * java.lang.reflect.Constructor        //构造器

4. 反射和封装性
    * 通过直接new对象，或反射的方式都可以调用公共的结构，具体使用位置？
        1. 建议直接使用new方式，编译的时候可以确定创建哪个对象
        2. 编译的时候无法确定创建哪个对象，根据传入的参数进行对象的创建，使用反射的方式：
            反射机制具有动态性

    * 有了反射机制，与对象的封装性，如何看待两种技术？
        1. 不矛盾
        2. 封装性：将对象的属性和方法进行权限限定，暴露出的接口表现用户可以使用的方法，建议用户使用的方法和属性，不建议使用私有方法[建不建议]
        3. 反射：可以使用的方法，用户强制使用私有的属性和方法[能不能]</code></pre><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><h3 id="java-lang-Class的理解"><a href="#java-lang-Class的理解" class="headerlink" title="java.lang.Class的理解"></a>java.lang.Class的理解</h3><pre><code>1. 类的加载过程
    程序在经过javac.exe命令之后，会生成一个或多个字节码文件（.class）文件，
    接着使用java.exe命令对某个字节码文件进行解释运行。相当于将字节码文件加载到内存，此过程叫做类的加载。
    加载到内存中的类，我们称为运行时类，此运行时类，就作为Class类的一个实例。

2. 换句话说，Class的实例就是一个运行时类的对象
3. 加载到内存的运行时类，会缓存一定的时间。在此时间之内，可以通过不同的方法获取运行时类</code></pre><h3 id="获取Class的实例方式"><a href="#获取Class的实例方式" class="headerlink" title="获取Class的实例方式"></a>获取Class的实例方式</h3><pre><code>1. 方式一：通过运行时类的.class属性获取Class实例
    Class clazz1 = Person.class();
    System.Out.Println(clazz1);

2. 方式二：通过运行时类的对象的.getClass()方法获取实例
    Person person = new Person();
    Class clazz2 = person.getClass();

3. 方式三：通过Class的.forName(&quot;运行时类的全限定类名&quot;)获取实例
    Class clazz3 = Class.forName(&quot;全限定类名&quot;)；

4. 方式四：通过类的加载器获取实例
     ClassLoader classLoader = Reflection.class.getClassLoader();
    Class clazz4 = classLoader.loadClass(&quot;全限定类名&quot;);

上述的四种Class实例的获取方式，方式一和方式二，都与具体的实现类绑定，在开发中一般使用Class类的.forName()方法获取Class实例对象。</code></pre><h3 id="Class对象的范围"><a href="#Class对象的范围" class="headerlink" title="Class对象的范围"></a>Class对象的范围</h3><pre><code>1. class:各种类对象
2. interface
3. []:数组 只要数组的类型和维度相同，就是一个Class对象
4. enum:枚举
5. annotation
6. 基本数据类型
7. void</code></pre><h2 id="ClassLoader-类加载器"><a href="#ClassLoader-类加载器" class="headerlink" title="ClassLoader(类加载器)"></a>ClassLoader(类加载器)</h2><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><pre><code>1. 加载：将类的字节码文件读入内存，并为其创建一个java.lang.Class对象，实现类的加载过程
2. 链接：静态变量初始化为默认值
3. 初始化：JVM使用构造器方法完成类变量的赋值和静态代码块的语句顺序合并产生数据</code></pre><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><pre><code>1. 将.class加载到内存，将这些静态数据转换成方法区运行时的数据结构，生成Class对象，作为方法区中类数据的访问入口
2. 类缓存：一旦某个类被加载到类加载器，会在类加载器中维持一段时间，JVM的垃圾回收机制可以回收Class对象

3. 分类
    * 引导类加载器：C++编写的，主要加载Java的核心类库，用户无法获取到该加载器
    * 扩展类加载器：加载java/lib/ect中的jar包
    * 系统类加载器：加载当前程序中的类</code></pre><blockquote>
<pre><code>//1.对于自定义类，使用系统级类加载器
ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
System.out.println(classLoader);

//2.调用系统类加载器的getParent()，获取扩展类加载器
ClassLoader classLoader1 = classLoader.getParent();
System.out.println(classLoader1);

//3.调用扩展类加载器getParent()，无法获取引导类加载器
//引导类加载器加载java的核心类库
ClassLoader classLoader2 = classLoader1.getParent();
System.out.println(classLoader2);</code></pre></blockquote>
<h2 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h2><h3 id="反射创建运行时类的对象"><a href="#反射创建运行时类的对象" class="headerlink" title="反射创建运行时类的对象"></a>反射创建运行时类的对象</h3><pre><code>1. 使用.newInstance()方法创建运行时类的对象
    newInstance:
        * 调用此方法，创建运行时类的方法
        * 内部调用运行时类的空参构造器
        * 如果没有空参构造器，产生异常

2. 满足两个条件
    * 运行时类必须提供空参的构造器
    * 访问权限不能为private,通常设置为public</code></pre><h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><pre><code>修饰符 返回类型 变量名；

1. 获取所有属性
    1. 获取当前运行时类的所有属性（getDeclaredFileds）
        * 不考虑权限问题，不会获取父类的属性</code></pre><blockquote>
<pre><code>Field[] fields1 = clazz.getDeclaredFields();
for(Field field:fields1){
    System.out.println(field);
}</code></pre></blockquote>
<pre><code>2. 获取属性包含父类的属性（getFileds）
    * 获取当前运行时类以及父类的所有权限为public的属性</code></pre><blockquote>
<pre><code>Field[] fields = clazz.getFields();
for(Field field:fields){
    System.out.println(field);
}        </code></pre></blockquote>
<pre><code>2. 获取属性的修饰符,数据类型，变量名</code></pre><blockquote>
<pre><code>Class clazz = Person.class;

//获取当前运行时类的所有属性
Field[] fields = clazz.getDeclaredFields();

for(Field field:fields){
//修饰符
//权限被分配了 整型数据,使用Modifier的方法可以翻译为字符串
int modifiers = field.getModifiers();
System.out.print(Modifier.toString(modifiers)+&quot;\t&quot;);
//数据类型
Class&lt;?type = field.getType();
System.out.print(type.getName()+&quot;\t&quot;);
//属性名
System.out.println(field.getName());
}</code></pre></blockquote>
<p><img src="/2020/09/10/reflection/fields.png" alt="运行时类的属性"></p>
<h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><pre><code>1. 获取当前运行类声明的所有方法</code></pre><blockquote>
<pre><code>Method[] methods = clazz.getMethods();
for(Method method:methods){
    System.out.println(method);
}</code></pre></blockquote>
<pre><code>2. 获取当前运行时类以及所有父类的声明为public权限的方法</code></pre><blockquote>
<pre><code>Method[] declaredMethods = clazz.getDeclaredMethods();
for(Method method:declaredMethods){
    System.out.println(method);
}</code></pre></blockquote>
<pre><code>3. 获取方法的修饰符，数据类型，方法名
    * @Anno
    * 权限修饰符 返回值类型 方法名(形参列表) Throws Exception{}

    Method[] declaredMethods = clazz.getDeclaredMethods();
    for(Method method:declaredMethods){
        System.out.println(&quot;-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&quot;);
        //1.注解获取
        Annotation[] methodAnnotations = method.getAnnotations();
        for(Annotation anno:methodAnnotations){
            System.out.print(anno+&quot;\t&quot;);
        }

        //2.权限修饰符
        System.out.print(Modifier.toString(method.getModifiers())+&quot;\t&quot;);
        //3.返回值类型
        System.out.print(method.getReturnType()+&quot;\t&quot;);
        //4.方法名
        System.out.print(method.getName());
        System.out.print(&quot;(&quot;);
        //5.形参列表参数
        Class[] parameterTypes = method.getParameterTypes();
        if(parameterTypes.length 0){
            for(int i = 0;i &lt; parameterTypes.length;i++){
                if(i == parameterTypes.length-1){
                    System.out.print(parameterTypes[i].getName()+&quot; args_&quot;+i);
                    break;
                }
                System.out.print(parameterTypes[i].getName()+&quot; args_&quot;+i+&quot; , &quot;);
            }
        }
        System.out.print(&quot;)&quot;);
        //6.获取抛出的异常
        Class[] exceptionTypes = method.getExceptionTypes();
        if(exceptionTypes.length 0){
            System.out.print(&quot; throws &quot;);
            for(int i = 0;i &lt; exceptionTypes.length;i++){
                if(i == exceptionTypes.length-1){
                    System.out.print(exceptionTypes[i].getName());
                    break;
                }
                System.out.print(exceptionTypes[i].getName()+&quot; , &quot;);
            }
        }
        System.out.println(&quot;{&quot;+&quot;\n&quot;+&quot;}&quot;);
    }</code></pre><h3 id="获取构造器的结构"><a href="#获取构造器的结构" class="headerlink" title="获取构造器的结构"></a>获取构造器的结构</h3><pre><code>1. 当前运行时类的所有的构造器</code></pre><blockquote>
<pre><code>Constructor&lt;?&gt;[] constructors = clazz.getConstructors();
for(Constructor c:constructors){
    System.out.println(c);
}</code></pre></blockquote>
<pre><code>2. 当前运行时类的所有public的构造器</code></pre><blockquote>
<pre><code>Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();
for(Constructor c:constructors){
    System.out.println(c);
}</code></pre></blockquote>
<h3 id="获取运行时类的父类"><a href="#获取运行时类的父类" class="headerlink" title="获取运行时类的父类"></a>获取运行时类的父类</h3><pre><code>1. getSuperClass():获取父类
2. getGenericSuperClass()：获取带有泛型的父类</code></pre><h2 id="调用运行时类的指定结构（方法和属性）"><a href="#调用运行时类的指定结构（方法和属性）" class="headerlink" title="调用运行时类的指定结构（方法和属性）"></a>调用运行时类的指定结构（方法和属性）</h2><pre><code>1. 获取指定的属性
    方法：
        getFiled():
            属性声明必须为public
        getDeclaredFiled()
            可以访问，但是如果想要访问私有属性，必须显式
            &lt;属性名&gt;.setAccessible(true);                

    1. 步骤
        * 获取Class对象
        * 创建Class对象的实例
        * 获取指定的属性
        * set方法
            * set(obj,value):obj：指明设置哪个对象的属性 value:设置的值
        * get方法
            * get(obj):obj：指明获取那个对象的属性

    2. 实例
        Class clazz = Person.class;
        Person p = (Person)clazz.newInstance();
        Filed filed = clazz.getDeclaredFiled(&quot;age&quot;);
        filed.setAccessible(true);
        filed.set(p,&quot;11111&quot;);

2. 获取指定的方法
    方法：
        getDeclaredMethod(name,param): 参数1：获取的方法的名称，参数2：获取的方法的形参列表
            可以访问，但是如果想要访问私有属性，必须显式
            &lt;方法名&gt;.setAccessible(true);

        &lt;方法名&gt;.invoke(obj,value):参数1:方法的调用者，参数2(可变形参)：赋值的实参
            invoke()方法的返回值为类中调用方法的返回值，
                如果调用的方法没有返回值，那么返回值为null

    1. 实例</code></pre><blockquote>
<pre><code>//1.获取指定的方法名
Method method = clazz.getDeclaredMethod(&quot;compareTo&quot;, String.class);
//2.确定当前方法是可以访问的
method.setAccessible(true);
//3.调用方法
method.invoke(p,&quot;HHHHH&quot;);   //p.show(&quot;HHHHH&quot;)</code></pre></blockquote>
<pre><code>2. 调用静态方法
    invoke(null)
    invoke(Person.class)</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2020/09/09/spring/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-什么是spring："><a href="#1-什么是spring：" class="headerlink" title="1. 什么是spring："></a>1. 什么是spring：</h3><pre><code>1. 分层的Java SE/EE的轻量级开源框架
2. 提供了展现层Spring MVC 和持久层Spring JDBC以及业务层事务管理的众多技术
3. 展现层和持久层的中间部分，业务层controller</code></pre><h3 id="2-spring的核心："><a href="#2-spring的核心：" class="headerlink" title="2. spring的核心："></a>2. spring的核心：</h3><pre><code>1. IoC（Inversion of Control）: 控制反转
2. AOP（Aspect Oriented Programming）: 面向切面编程</code></pre><h3 id="3-优势"><a href="#3-优势" class="headerlink" title="3. 优势"></a>3. 优势</h3><pre><code>spring优势：
    1. 方便解耦，简化开发 IOC
    2. AOP编程的支持
    3. 声明式事务的支持
    4. 方便程序的测试 junit集成
    5. 方便集成各种优秀的框架 mybatis等框架的集成</code></pre><h2 id="程序的耦合和解耦"><a href="#程序的耦合和解耦" class="headerlink" title="程序的耦合和解耦"></a>程序的耦合和解耦</h2><h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><pre><code>1. 什么是耦合：
    程序之间的依赖关系：
        * 类之间的依赖关系
        * 方法之间的依赖关系

2. 开发中的做法：
    编译时不依赖，运行时依赖

3. 方法：
    1. 使用读取配置文件来获取要创建的对象的全限定类名(包含所有包名的类名)
        使用类加载器，获取配置文件的输入流
    2. 使用反射（reflect）来创建对象，而不是使用new关键字
        * 使用反射，如果字符串写死，以后无法再次使用别的数据库配置
        * 可以根据配置文件的不同，创建不同的对象实例</code></pre><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><pre><code>1. 什么是解耦：
    降低程序之间的依赖关系

2. 解耦的方式：使用工厂模式创建Bean对象
      * bean: 可重用组件
      * javaBean &gt; 实体类
      * javaBean 用java语言编写的可重用组件
      * beanFactory：创建bean对象的工厂

3. 如何创建工厂模式
    1. 读取配置文件来反射bean对象

    2. 通过配置文件来创建service和dao中的对象

        map结构

        唯一标识=全限定类名，key = value，根据对应的value创建实例对象</code></pre><h2 id="IoC（Inversion-of-Control）"><a href="#IoC（Inversion-of-Control）" class="headerlink" title="IoC（Inversion of Control）"></a>IoC（Inversion of Control）</h2><pre><code>1. 概念：
    把创建对象的权力交给框架，是框架的重要特征，包括依赖注入（Dependency Injection,DI）和依赖查找（Dependency Lookup）

2. 作用
    * 降低程序之间的耦合度
    * 将类中的对象创建工作交给spring框架来完成，只要获取该对象就可以了
    * 使用依赖注入进行属性值的填充，在创建对象的同时完成赋值</code></pre><h3 id="基于XML的IoC配置"><a href="#基于XML的IoC配置" class="headerlink" title="基于XML的IoC配置"></a>基于XML的IoC配置</h3><h4 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h4><pre><code>1. 步骤
    * 读取配置文件创建IoC容器（ApplicationContext）
    * 根据id，获取容器中的文件

2. 配置文件的内容
    * 主要是&lt;bean&gt;标签，id:查找对象的唯一标识符，class:要创建的对象的全限定类名

3. 读取配置文件创建容器
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    根据类路径下的xml配置文件创建容器，配置文件需要放置在类路径下

    ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;bean.xml&quot;);
    可以加载磁盘任意路径下的配置文件

    ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class);
    根据类上有@Configuration的类创建容器

4. 根据id获取对象
    as.getBean(&quot;id&quot;);</code></pre><h4 id="BeanFactory和ApplicationContext"><a href="#BeanFactory和ApplicationContext" class="headerlink" title="BeanFactory和ApplicationContext"></a>BeanFactory和ApplicationContext</h4><pre><code>1. BeanFactory接口
    * 创建核心容器时，创建对象的方式采用延迟加载的方式，什么时候根据ID获取对象的时候，什么时候开始创建真正的对象
     * 多例模式适用

2. ApplicationContext接口
    * 创建核心容器时，创建对象的方式采用立即加载的方式，只要一读取完配置文件马上创建配置文件中的对象
     * 单例模式时适用：只创建一个对象

3. 具体的使用
    BeanFactory是顶层接口，功能不如ApplicationContext，实际使用的接口为ApplicationContext接口

    ApplicationContext可以根据配置文件的不同，选择合适的加载方式
    可以感知到对象的单例还是多例，从而选择不同的方式创建对象</code></pre><h4 id="spring对bean对象的管理细节"><a href="#spring对bean对象的管理细节" class="headerlink" title="spring对bean对象的管理细节"></a>spring对bean对象的管理细节</h4><h5 id="1-创建bean的三种方式"><a href="#1-创建bean的三种方式" class="headerlink" title="1. 创建bean的三种方式"></a>1. 创建bean的三种方式</h5><pre><code>1. 使用默认构造函数创建：
   在spring的配置文件中使用bean标签，配以id 和 class属性，且没有其他的属性和标签时
   采用的就是默认构造函数创建bean对象(Class类的实例反射)，如果此时没有默认构造函数，则无法创建</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_IoC_bean.service.impl.AccountServiceImpl&quot;/&gt;</code></pre></blockquote>
<pre><code>2. 使用普通工厂中的方法创建对象
    使用某个类中的方法创建对象，并存入spring容器中</code></pre><blockquote>
<pre><code>&lt;!-- 创建工厂实例对象 --&gt;

&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.spring_03_IoC_bean.factory.InstanceFactory&quot;/&gt;

&lt;!-- 使用工厂生产bean --&gt;

&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;/&gt;</code></pre></blockquote>
<pre><code>3. 使用工厂的静态方法创建对象（
    使用某个类的静态方法创建对象(可以不创建该对象)，并将其存入spring容器</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_IoC_bean.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;/&gt;</code></pre></blockquote>
<h5 id="2-bean对象的作用范围"><a href="#2-bean对象的作用范围" class="headerlink" title="2. bean对象的作用范围"></a>2. bean对象的作用范围</h5><pre><code>1. bean标签的scope属性规定bean对象的范围
2. 类型
    * singleton: 单例模式（默认）
    * prototype：多例模式
    * requset:web应用的一次请求
    * session：web应用中的一次会话
    * global-session：web应用中的全局会话</code></pre><h5 id="3-bean对象的生命周期"><a href="#3-bean对象的生命周期" class="headerlink" title="3. bean对象的生命周期"></a>3. bean对象的生命周期</h5><pre><code>1. 单例对象：singleton
  出生：当容器创建时，对象出生
  活着：只要容器还在，对象活着
  死亡：容器销毁，对象死亡
2. 多例对象：prototype
  出生：当使用对象时，spring框架创建
  活着：只要在使用的时候一直存在
  死亡：只有在对象长时间不用，且没有其他的对象引用的时候，由垃圾回收机制回收</code></pre><h4 id="依赖注入（dependency-injection-DI）"><a href="#依赖注入（dependency-injection-DI）" class="headerlink" title="依赖注入（dependency injection:DI）"></a>依赖注入（dependency injection:DI）</h4><pre><code>1. 什么是依赖？    
    当前类中引用到其他类的对象，叫做依赖。
    在spring框架中，依赖对象由框架提供，我们只需要提供配置文件的说明（IoC方式）

2. spring降低程序之间的依赖关系?
    IoC控制反转
    依赖注入

3. 依赖注入的数据类型：
    1. 基本数据类型和String类型
    2. 其他bean对象（引用数据类型）
    3. 复杂类型（集合类型，list array set map pros）

4. 依赖注入的方式：
    1. 通过默认构造函数注入依赖
    2. 使用set方法注入 ***
    3. 通过注解注入</code></pre><h5 id="1-通过默认构造函数注入"><a href="#1-通过默认构造函数注入" class="headerlink" title="1. 通过默认构造函数注入"></a>1. 通过默认构造函数注入</h5><pre><code>标签：constructor-arg
位置：bean中的内部
属性含义：
    type: 指定要注入的数据类型，该数据类型是构造函数的某个或者某些参数的类型
    index: 指定要注入数据给构造函数的参数指定索引的位置的赋值
    name: 用于指定给构造函数的指定名称的参数赋值（主要方式）
    ===================指定给构造函数的那个参数赋值=======================

    value: 提供基本类型和String类型的数据
    ref: 指定其他的bean类型的数据，在spring的IoC的核心容器中的bean对象

优势：
    在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功
缺点：
    改变了bean对象的实例化方式，在我们创建对象时，即使用不到这些数据，也必须提供数据</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;李某&quot;/&gt;
    &lt;constructor-arg name=&quot;age&quot; value=&quot;23&quot;/&gt;
    &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;
&lt;/bean&gt;</code></pre></blockquote>
<blockquote>
<pre><code>&lt;!-- 配置一个日期对象 --&gt;
&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;/&gt;</code></pre></blockquote>
<h5 id="2-使用set进行依赖注入"><a href="#2-使用set进行依赖注入" class="headerlink" title="2. 使用set进行依赖注入"></a>2. 使用set进行依赖注入</h5><pre><code>标签：property
位置：bean标签内部
参数：
    name:    指定注入的时候的方法的名称
    value:     指定基本数据类型和String类型
    ref:     指定其他的bean类型的数据，只要是在spring核心容器中的bean对象都可以

优势：创建bean对象的时候，可以直接使用默认构造函数
   缺点：
      如果某个成员必须有值，获取对象的set方法可能没有执行</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService2&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl2&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;22&quot;/&gt;
    &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;
&lt;/bean&gt;</code></pre></blockquote>
<blockquote>
<pre><code>&lt;!-- 配置一个日期对象 --&gt;
&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;/&gt;</code></pre></blockquote>
<h5 id="3-使用注解进行依赖注入"><a href="#3-使用注解进行依赖注入" class="headerlink" title="3. 使用注解进行依赖注入"></a>3. 使用注解进行依赖注入</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// annocation依赖注入</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="meta">@Value</span></span><br></pre></td></tr></table></figure>

<h5 id="4-注入复杂数据类型"><a href="#4-注入复杂数据类型" class="headerlink" title="4. 注入复杂数据类型"></a>4. 注入复杂数据类型</h5><pre><code>List Set Array    
Map Properties

标签：property
位置：property内部
其中：只要数据集合的结构相同，可以使用同一种标签进行依赖注入
    list set array: 都可以使用&lt;list&gt;,&lt;array&gt;,&lt;set&gt;，序列格式
    map property:&lt;map&gt;,&lt;pros&gt;，键值对格式</code></pre><blockquote>
<pre><code>    private String[] myStr;
private List&lt;String&gt; myList;
private Set&lt;String&gt; mySet;
private Map&lt;String,String&gt; myMap;
private Properties myProp;</code></pre></blockquote>
<pre><code>具体的调用方法</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService3&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl3&quot;&gt;
&lt;property name=&quot;myStr&quot;&gt;
  &lt;array&gt;
    &lt;value&gt;AAA&lt;/value&gt;
    &lt;value&gt;VVVDDD&lt;/value&gt;
    &lt;value&gt;SS&lt;/value&gt;
    &lt;value&gt;SSDDD&lt;/value&gt;
  &lt;/array&gt;
&lt;/property&gt;
&lt;!-- map --&gt;
&lt;property name=&quot;myMap&quot;&gt;
  &lt;map&gt;
    &lt;entry key=&quot;1&quot; value=&quot;11111&quot;/&gt;
    &lt;entry key=&quot;2&quot; value=&quot;22222&quot;/&gt;
  &lt;/map&gt;
&lt;/property&gt;</code></pre>  
</blockquote>
<h3 id="基于注解的IoC配置"><a href="#基于注解的IoC配置" class="headerlink" title="基于注解的IoC配置"></a>基于注解的IoC配置</h3><pre><code>使用注解和xml开发要实现的功能都是一致的：
    降低程序之间的耦合，将xml中对应的功能交由注解来实现</code></pre><h4 id="1-用于创建bean对象的注解"><a href="#1-用于创建bean对象的注解" class="headerlink" title="1. 用于创建bean对象的注解"></a>1. 用于创建bean对象的注解</h4><pre><code>* 与xml配置文件中的&lt;bean&gt;标签的作用相同：创建一个bean对象，将其放置在容器中
* 如果想让spring知道存在组件，需要使用spring中的包扫描，将需要创建bean对象的包传入&lt;context&gt;标签中

1. @Component:组件注解
    * 作用：将当前对象存入spring容器中(写在类名上)
    * 属性：value:
            用于指定获取容器中bean的id，当我们不写时，默认是当前类名，首字母小写    

2. @Controller:一般用于表现层
3. @Service：一般用于业务层
4. @Repository:一般用于持久层
以上的三个注解和@Component的作用和属性完全一致，是spring框架为我们明确提供的三层注解，让我们的三层结构更加清晰</code></pre><h4 id="2-用于数据注入的注解"><a href="#2-用于数据注入的注解" class="headerlink" title="2. 用于数据注入的注解"></a>2. 用于数据注入的注解</h4><pre><code>* 与xml配置文件的&lt;property&gt;作用一致：进行数据注入

1. @Autowired:自动按照类型注入
     * 只要IoC容器中有唯一的bean对象和要注入的变量类型相同，就可以自动注入
     * 如果IoC容器中没有任何bean对象和要注入的变量类型相同，无法自动注入
     * 如果IoC容器中有多个bean对象和要注入的变量类型相同，
     * 首先圈定类型相同的bean对象的范围，然后会在进行变量名称的比对,如果名称相同，就可以注入数据</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/autowired.png" alt="autowired注解">         </p>
<pre><code>2. @Qualifier
    * 先按照类型自动注入，如果包含有多个相同类型的bean对象，会按照名称进行数据注入
    * 在按照类型注入的基础上，再按照名称注入，在给类成员的注入的时候不能单独使用，但是在给方法注入的时候可以，将@Qualifier()中的名称所对应的Bean对象注入到方法中
    * 参数：
        value:用于指定注入的bean的id

3. @Resource
    * 直接按照bean的id进行注入，可以单独使用
    * 参数：
        name:用于指定注入的bean的id

注意：
     以上的三种注入方式只能注入其他的bean类型的数据，基本类型和String类型无法通过上述方法注入
          集合类型只能通过xml方式注入

4. @Value
    * 注入基本数据类型和String类型
    * 参数：    
        value:用于指定数据的值，可以使用SpEL（spring的El表达式）                      
        SpEL的写法：${表达式}</code></pre><h4 id="3-用于改变作用范围的注解"><a href="#3-用于改变作用范围的注解" class="headerlink" title="3. 用于改变作用范围的注解"></a>3. 用于改变作用范围的注解</h4><pre><code>* 与xml文件中的&lt;bean&gt;标签的scope属性作用相同

1. @Scope
    * 参数：
        value:singleton prototype</code></pre><h4 id="4-用于改变生命周期的注解"><a href="#4-用于改变生命周期的注解" class="headerlink" title="4. 用于改变生命周期的注解"></a>4. 用于改变生命周期的注解</h4><pre><code>1. @PreDestroy
    * 销毁容器
2. @PostConstruct
    * 初始化容器</code></pre><h3 id="使用IoC的一个简单案例"><a href="#使用IoC的一个简单案例" class="headerlink" title="使用IoC的一个简单案例"></a>使用IoC的一个简单案例</h3><pre><code>1. 环境配置
    使用DBUtils进行Dao数据交互
    spring框架
    mybatis进行JDBC连接
    c3p0作为数据源</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/IoC_exp_pom.png" alt="pom.xml"></p>
<pre><code>2. bean文件结构 application.xml
    1. xml配置</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/Ioc_xml_exp.png" alt="xml配置的bean"></p>
<pre><code>2. annotation配置</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/IoC_anno_exp.png" alt="annotation配置的bean"></p>
<blockquote>
<p>注解的形式以及文件结构<br><img src="/2020/09/09/spring/Ioc_structure.png" alt="annotation的结构"></p>
</blockquote>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><pre><code>在案例中，配置文件存在annotation和xml同时存在，下面将其改造为纯注解方式

1. 改变xml中的组件扫描
    @Configuration:
        * 作用：用于指定当前类是配置类
         * 当配置类作为AnnotationConfigApplicationContext()的参数时可以不写@Configuration，由扫描器直接扫描该配置类
         * 如果是子配置类，而且子配置类的字节码没有作为参数传入，必须写@Configuration

    @ComponentScan
        * 作用：用于指定spring在创建容器是需要扫描的包
        * 参数：value basePackages作用一样（@Alisafor）    
                类似&lt;context:component-scan base-package=&quot;com.spring_04_exp&quot;/&gt;

    一旦这个类上写了@Configuration 和@ComponentScan ,spring就会自动扫描配置包，并且创建对象将其放入容器，只需要拿到这个bean对象就可以了。

2. 根据方法的返回值创建Bean对象
    @Bean
        * 作用：把当前方法的返回值作为Bean对象存入spring容器中
        * 参数：name:
            用于指定bean的id,当不写时，方法名作为默认值
        * 使用注解配置方法时，spring框架会在容器中查找相对于的bean容器，查找方法与@AutoWired相同

3. 配置文件的读取
    @PropertySource
        * 作用：读取配置文件，用于指定properties文件的位置
        * 参数：value
            文件的名称:文件的路径
        * classpath关键字，表示在类路径下

4. 导入其他的配置类
    @Import
        * 作用：用于导入其他的配置类
        * 参数：value
            用于指定其他配置类的的字节码
        * 当我们使用Import注解时，拥有Import的配置类就是父配置类，写在value中的就是子配置类</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/anno_withoutxml_1.png" alt="配置类"><br><img src="/2020/09/09/spring/anno_withoutxml_2.png" alt="配置类"></p>
<pre><code>5. spring整合junit
    1. 程序的入口
        main方法
    2. JUnit单元测试
        没有main方法也能执行，其实junit中集成了main方法
        该方法就会判断当前测试类中有哪些方法上由@Test方法
        junit就会让Test注解执行该方法
    3. junit不知道spring框架
        在执行测试方法的时候，junit根本不知道由spring框架
        所以不会读取配置文件/创建spring容器

    4. 当测试方法执行时，没有IoC容器，就算写了@Autowired注解，也无法注入

    5. 解决方式    
        1. 导入spring整合test的jar包
        2. 使用junit的main方法替换为spring提供的main方法
            1. @Runwith
                * 作用：改变junit的main方法，使用spring框架提供的main方法，可以创建容器
                * 替换的方法的类的字节码
        3. 告诉spring运行器，spring和IoC容器的创建基于xml还是注解
            2. @ContextConfiguration
                * 作用：指定spring和IoC容器的创建基于xml还是注解
                * 参数：
                    locations : 指定xml文件的位置，加上classpath关键字，表示在类路径下
                    classes: 指定配置类位置，字节码文件

    6. 出现问题
        1. spring框架的5.x版本整合junit必须在4.12版本以上
        2. spring-context以及spring-test的版本号要一致
        3. 如果一直无法导入jar包，可以先将本地maven仓库对应的jar包删除，重新导入坐标</code></pre><h2 id="spring的AOP"><a href="#spring的AOP" class="headerlink" title="spring的AOP"></a>spring的AOP</h2><h3 id="完善account的案例"><a href="#完善account的案例" class="headerlink" title="完善account的案例"></a>完善account的案例</h3><h4 id="进行账户之间的转账"><a href="#进行账户之间的转账" class="headerlink" title="进行账户之间的转账"></a>进行账户之间的转账</h4><pre><code>1. 增加新的转账方法
2. 防止转账异常，应该在持久层增加事务控制
3. 将事务控制放在业务层控制
4. 增加数据库连接工具类
5. 为了保证每次连接都只有一个事务控制，将连接和线程绑定
6. 增加事务管理工具类 
7. 改变连接池对象，增加数据注入

增加很多冗余代码，配置文件变得更为复杂</code></pre><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><pre><code>1. 优势
    * 字节码随用随创建，随用随代理
    * 在不改变源码的时候对方法进行增强</code></pre><h4 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><pre><code>1. 涉及的类
    * Proxy类
    * JDK官方

2. 创建代理对象的方法
    * Proxy.newProxyInstance()

3. 要求
    * 被代理对象至少要实现一个接口，如果没有，不能使用，代理对象返回的是接口类型数据
    JDK动态代理的原理是根据定义好的规则，用传入的接口创建一个新类，这就是为什么采用动态代理时为什么只能用接口引用指向代理，而不能用传入的类引用执行动态类。

4. newProxyInstance()的参数
    * ClassLoader:类加载器
        用于加载代理对象的字节码，和被代理对象使用相同的类加载器：固定写法

    * Class[]:字节码数组
        用于指定代理和被代理对象实现相同的方法，代理谁就写谁的接口：固定写法

    * InvacationHandler
        用于指定增强的代码
        让我们写任何实现代理，一般在某个实现方法上进行改变
        一般情况下，为匿名内部类，但是不是必须的
        此接口的实现类，都是谁用谁写

    * 返回值
        返回代理类的接口实例
        Proxy.newProxyInstance返回的是接口类型

5. InvacationHandler的实现方法的参数</code></pre><blockquote>
<pre><code>实现类中需要重写invoke方法,执行被代理对象的任何方法都会经过该方法
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
   return null;
 }
    * proxy : 被代理对象的引用
    * method : 当前执行的方法
    * args : 当前方法执行的参数
    * 返回类型：和被代理对象的相同方法有相同的返回值类型</code></pre></blockquote>
<h4 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h4><pre><code>1. 导入jar包
    cglib包

2. 涉及的类
    * Enhancer类
    * 第三方cglib库

3. 创建代理对象的方法
    * Enhancer.create()方法

4. create方法的参数
    * Class:被代理对象的字节码
    * Callback:
        * 用于提供增强的方法
         * 如何代理对象，该接口的实现类，通常情况下为匿名内部类，但不是必须的
         * 此接口的方法都是谁用谁写
         * 实现该接口的子接口的实现类，MethodInterceptor方法拦截器

5. MethodInterceptor方法的参数</code></pre><blockquote>
<pre><code>方法的重写
@Override
public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
    return null;
}
参数：
    * 执行被代理对象的方法都经过该方法
    * @param o 被代理对象
    * @param method 当前执行的方法
    * @param objects 当前方法执行的对象
    *                和基于接口的方法的invoke参数相同
    * @param methodProxy 当前执行方法的代理对象
    * @return 和当前方法的返回值类型相同
    * @throws Throwable    </code></pre></blockquote>
<h4 id="动态代理在案例中的使用"><a href="#动态代理在案例中的使用" class="headerlink" title="动态代理在案例中的使用"></a>动态代理在案例中的使用</h4><pre><code>1. 创建代理工厂类，在获取AccountService的基础上，对原有的方法进行增强，增加事务控制</code></pre><blockquote>
<pre><code>public class BeanFactory {
    private IAccountService accountService;
    private TransactionManager transactionManager;</code></pre></blockquote>
<pre><code>public void setTransactionManager(TransactionManager transactionManager) {
    this.transactionManager = transactionManager;
}</code></pre><blockquote>
<pre><code>public final void setAccountService(IAccountService accountService) {
    this.accountService = accountService;
}</code></pre></blockquote>
<pre><code>/**
 * 获取代理对象的返回方法
 * @return
    */

  public IAccountService getAccountService(){
    return (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(),
            accountService.getClass().getInterfaces(), new InvocationHandler() {
                /**
                 * 增强方法,对事务进行增强
                 */
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    Object rtValue = null;
                    try {
                        //1.开启事务
                        transactionManager.beginTransaction();
                        //2.执行操作
                        rtValue = method.invoke(accountService,args);
                        //3.提交事务
                        transactionManager.commitTransaction();
                        //4.返回结果
                        return rtValue;
                    } catch (Exception e) {
                        //5.回滚事务
                        transactionManager.rollbackTransaction();
                        throw new RuntimeException(e);
                    } finally {
                        //6.释放资源
                        transactionManager.releaseTransaction();
                    }
                }
           });
     }

  }

2. bean.xml的配置
    * 增加新的bean对象，beanFactory
    * 使用工厂的方法，创建代理类对象，由于代理类对象的数据类型和被代理对象的数据类型相同，在测试的时候需要对注入的数据进行指定</code></pre><p><img src="/2020/09/09/spring/proxy.png" alt="代理类对象的配置文件"></p>
<pre><code>3. 测试类</code></pre><p><img src="/2020/09/09/spring/proxy_test.png" alt="动态代理的测试类"></p>
<h3 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h3><pre><code>1. Aspect Oriented Programming:面向切面编程
    通过预编译和运行期动态代理的方式，实现程序功能的统一维护的一种技术。AOP是OOP编程的延续，是函数式编程的一种衍生泛型，可以使用AOP对业务逻辑进行隔离，降低程序之间的耦合性，提高代码的可重用率。

    简单来说，将重复的代码抽取出来，在需要使用的时候，通过动态代理的方式，在不修改源码的基础上，对已有的方法进行增强。

2. AOP的优势
    1. 作用
        * 在程序的运行期间不改变源码的基础上，对已有的方法进行增强

    2. 优势
        * 减少重复代码
        * 提高开发效率
        * 方便维护

3. 实现方式
    动态代理
    spring会根据是否实现了接口，动态的选择实现代理的方式
    实现接口，使用Proxy.newProxyInstance()动态代理

4. AOP的相关术语
    * Joinpoint(连接点)：
        所谓连接点是指那些被拦截到的点，在spring中，只支持对方法类型的连接点。
        （业务层接口中的所有方法），连接业务和增强方法的点

    * Pointcut(切入点)：
        被增强的方法，叫做切入点，我们对于哪些joinpoint方法进行增强的定义

    切入点都是连接点，但不是所有的连接点都是切入点

    * Advice(通知/增强):
        拦截到Joinpoint之后所作的事情叫做通知。
        通知的类型：
            前置通知，后置通知，异常通知，最后通知，环绕通知</code></pre><p><img src="/2020/09/09/spring/advice.png" alt="advice_types"></p>
<pre><code>    * Target(目标对象)：
        代理的目标对象，即被代理对象

    * Weaving(织入)：
        把增强应用到目标对象来创建新的代理对象的过程。
        spring采用动态代理技术进行织入，动态代理产生新的对象

    * Proxy(代理)：
        一个类被AOP织入后，产生一个代理对象

    * Aspect(切面)：
        切入点和通知的结合，切入点和通知的有序组合
5. 明确
    1. 开发阶段：
        核心业务代码，大部分程序员
        把公共代码抽取出来，制作成通知（最后才做）
        在配置文件中，声明切入点和通知的关系，即切面，

    2. 运行阶段：
        spring框架监控切入点的执行，一旦检测到切入点方法正在执行，则立即使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理的对应位置，将通知的功能织入，完成代码的逻辑运行。</code></pre><h3 id="基于XML的AOP配置"><a href="#基于XML的AOP配置" class="headerlink" title="基于XML的AOP配置"></a>基于XML的AOP配置</h3><pre><code>1. 配置步骤
    1. 把通知的bean交给spring来管理（由spring来统一控制）
    2. 使用aop:config标签表明开始aop配置,开始配置
    3. 使用aop:aspect:配置切面
          id：给切面提供唯一属性
          ref:通知类的bean的id

    4. 在aop:aspect标签的内部使用对应的标签配置通知的类型
         现在的示例的通知类型是printlog方法在切入点的执行，为前置类型
            aop:before表示配置前置通知
                  method属性用于指定那个方法是前置通知

    5. pointcut属性：指定切入点表达式，该表达式的含义：对业务层的那些方法增强
        写法；关键字：execution(表达式)
          表达式：
              访问修饰符 返回值 包名.包名...类名.方法名（参数列表）
          标准表达式：
              execution(public void com.spring_AOP_xml.service.impl.AccountServiceImpl.saveAccount())</code></pre><p><img src="/2020/09/09/spring/xml_AOP.png" alt="XML配置AOP"></p>
<pre><code>2. 切入点表达式的化简
    1. 通配表达式写法：* *..*.*(..),所有包下的方法都被增强
    * 步骤
        public void com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        1. 访问修饰符可以省略：
            void com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        2. 返回值类型可以使用通配符*代替：
            * 
    com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        3. 包名可以使用*.来代替，有几级包，需要写几个 
            * *.*.*.*.IAccountServiceImpl.saveAccount()
            使用*..可以表示当前包和子包，代表所有的包
        4. 类名和方法名可以使用*来表示
            * *..*.*()
        5. 参数：
            基本数据类型：直接写类型  int
            引用数据类型: 包名.类名  java.lang.String
            可以使用*来代表有无参数
                * *..*.*()和* *..*.*(*)不一样
            可以使用 ..来表示有无参数
        所以：
            * *..*.*(..):表示对所有类上的所有方法都进行增强

    2. 开发中：对业务层上的所有方法都进行增强
        * com.spring_AOP_xml.service.impl.*.*(..)

    3. 通用切入点表达式简化最终版：
        aop:pointcut标签：写在&lt;aop:aspect&gt;标签内部，但只能在当前标签内部使用，也可以写在外部，所有切面都可以使用，此时必须出现在切面之前
            id 切入点的唯一表示 
            expression：指定表达式内容
          &lt;aop:pointcut id=&quot;pc1&quot; expression=&quot;execution(* com.spring_AOP_xml.service.impl.*.*(..))&quot;/&gt;

        使用方式：
            &lt;aop:after method=&quot;printLog&quot; pointcut-ref=&quot;pc1&quot;/&gt;

3. 通知的类型（advice）
    前置通知：切入点方法执行之前
    后置通知：切入点方法正常执行之后执行
    异常通知：切入点方法异常的时候执行
    最终通知：无论怎样都会执行

    后置通知和异常通知只会执行一个</code></pre><p><img src="/2020/09/09/spring/advice_types.png" alt="通知类型"></p>
<pre><code>环绕通知：
    * 问题：
        在配置环绕通知之后，业务层方法没有执行，环绕通知执行了
    * 分析：
        没有对切入点的方法的明确调用
    * 解决：
        spring提供了一个接口，ProceedingJoinPoint的方法中proceed(),明确切入点方法的调用，该方法可以传入环绕通知参数，在程序执行期间，spring框架会为我们创建实现类。</code></pre><p><img src="/2020/09/09/spring/around_advice.png" alt="aroundadvice"></p>
<pre><code>* 环绕通知是spring框架为我们提供的一种方式：可以手动控制增强代码执行的方式</code></pre><h3 id="基于注解的AOP配置"><a href="#基于注解的AOP配置" class="headerlink" title="基于注解的AOP配置"></a>基于注解的AOP配置</h3><pre><code>1. 加入context扫描
2. 配置注解产生对象
3. 改变增强类的信息，切面的方法
4. 在bean.xml中增加开启注解配置AOP的标签
    &lt;aop:aspectj-autoproxy/&gt;:有这个标签才使用注解配置AOP</code></pre><p><img src="/2020/09/09/spring/AOP_anno.png" alt="通知和切面类注解"></p>
<h2 id="JdbcTemlate"><a href="#JdbcTemlate" class="headerlink" title="JdbcTemlate"></a>JdbcTemlate</h2><h3 id="spring中的JdbcTemplate"><a href="#spring中的JdbcTemplate" class="headerlink" title="spring中的JdbcTemplate"></a>spring中的JdbcTemplate</h3><pre><code>1. 概念    
    * spring框架的提供的一个对象，是对原始Java API的简单封装，spring为我们提供了很多操作模板类。
    * 操作关系型数据库：
    * 操作nosql数据库
    * 操作消息队列:

    使用的时候需要导入spring-jdbc-5.1.10.RELEASE.jar
                    spring-tx-5.1.10.RELEASE.jar(事务相关)

2. 作用
    * 用于和数据库进行交互的，实现数据的CRUD

3. 如果重复的代码过多
    可以抽取重复代码，形成父类，使AccountDaoImpl继承该父类，也可以实现Dao的实现类</code></pre><blockquote>
<p>   Dao的两种实现方式:<br><img src="/2020/09/09/spring/dao_xml.png" alt="dao的xml配置方式"><br><img src="/2020/09/09/spring/dao_anno.png" alt="dao的annotation配置方式"></p>
</blockquote>
<h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h2><h3 id="spring的事务"><a href="#spring的事务" class="headerlink" title="spring的事务"></a>spring的事务</h3><pre><code>1. 明确
    * Java EE体系进行开发，事务处理位于业务层，spring提供分层设计业务层的事务处理方法
    * spring框架为我们提供一组事务控制的接口，位于spring-tx-5.1.10.RELEASE.jar
    * spring的事务控制基于AOP的，可以使用配置的控制和编程，主要使用配置事务

2. 事务API
    * platformTransactionManager</code></pre><h3 id="基于xml的事务控制"><a href="#基于xml的事务控制" class="headerlink" title="基于xml的事务控制"></a>基于xml的事务控制</h3><pre><code>1. 使用
    1. 配置事务管理器（DataSourceTransactionManager）
    2. 配置事务通知(tx:advice)
          此时需要导入事务的约束,tx的名称约束，同时也需要aop的支持
          使用tx:advice配置事务通知 
            id:唯一标志 
            transaction-manager:提供事务管理器使用
    3. 配置aop的通用切入点表达式
    4. 建立事务通知和切入点表达式的关联
    5. 配置事务的属性：事务的通知tx:advice的内部
        * isolation: 指定事务的隔离级别，默认值式DEFAULT,可重复读
        * propagation: 事务的传播行为REQUESTED表示一定会有事务，增删改的选择，查询可以选择SUPPORTS
        * read-only: 事务是否只读，默认为false
        * time-out: 事务的超时时间,默认-1，表示永不超时，如果指定，以秒为单位
        * rollback-for: 指定一个异常，当产生该异常时，事务回滚，产生其他异常，事务不回滚，没有默认值，表示任何异常都会回滚
        * no-rollback-for：指定一个异常，当产生该异常时，事务不回滚，产生其他异常，事务回滚，没有默认值，表示任何异常都会回滚

2. 使用实例</code></pre><p><img src="/2020/09/09/spring/tran_xml.png" alt="基于xml的声明式事务"></p>
<h3 id="基于注解的事务配置"><a href="#基于注解的事务配置" class="headerlink" title="基于注解的事务配置"></a>基于注解的事务配置</h3><pre><code>1. 步骤
    1. 配置事务管理器（DataSourceTransactionManager）
    2. 开启spring对注解事务的支持（tx:annotation-driven）
    3. 使用注解@transactional对需要事务的地方进行定义
        xml中的事务属性，均可以在@Transactional的属性中配置

    如果查询和增删改的方法数量差不多，需要对增删改的方法单独配置事务支持

2. 实例</code></pre><p><img src="/2020/09/09/spring/tran_anno.png" alt="基于注解的声明式事务"></p>
<h3 id="使用纯注解的事务配置"><a href="#使用纯注解的事务配置" class="headerlink" title="使用纯注解的事务配置"></a>使用纯注解的事务配置</h3><p><img src="/2020/09/09/spring/tx_without_xml.png" alt="纯注解的声明式事务"></p>
]]></content>
      <categories>
        <category>SpringFramework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL 5.7.29</title>
    <url>/2020/06/18/mysql57/</url>
    <content><![CDATA[<h2 id="下载安装MySQL-5-7-29版本"><a href="#下载安装MySQL-5-7-29版本" class="headerlink" title="下载安装MySQL-5.7.29版本"></a>下载安装MySQL-5.7.29版本</h2><h3 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1.下载安装包"></a>1.下载安装包</h3><pre><code>官网下载安装包，离线安装方式</code></pre><ul>
<li><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">mysql数据库下载地址</a><blockquote>
</blockquote>
<img src="/2020/06/18/mysql57/0.png" alt></li>
</ul>
<h3 id="2-my-ini"><a href="#2-my-ini" class="headerlink" title="2.my.ini"></a>2.my.ini</h3><pre><code>下载的安装包解压后，安装目录如果没有*my.ini*文件，新建该文件，内容：
其中，文件安装和data目录可以自定义</code></pre><blockquote>
</blockquote>
<p><img src="/2020/06/18/mysql57/5.png" alt></p>
<h3 id="3-创建服务"><a href="#3-创建服务" class="headerlink" title="3.创建服务"></a>3.创建服务</h3><blockquote>
</blockquote>
<p><img src="/2020/06/18/mysql57/6.png" alt></p>
<pre><code>mysql57为服务名</code></pre><h3 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4.初始化"></a>4.初始化</h3><p><code>mysqld --initialize</code></p>
<h3 id="5-启动服务"><a href="#5-启动服务" class="headerlink" title="5.启动服务"></a>5.启动服务</h3><p><code>net start mysql</code></p>
<h3 id="6-连接数据库"><a href="#6-连接数据库" class="headerlink" title="6.连接数据库"></a>6.连接数据库</h3><ul>
<li>临时密码：在***.err下<blockquote>
</blockquote>
<img src="/2020/06/18/mysql57/4.png" alt><br><img src="/2020/06/18/mysql57/9.png" alt><br><img src="/2020/06/18/mysql57/11.png" alt></li>
</ul>
<h3 id="7-更改密码"><a href="#7-更改密码" class="headerlink" title="7.更改密码"></a>7.更改密码</h3><blockquote>
</blockquote>
<p><img src="/2020/06/18/mysql57/12.png" alt></p>
<h3 id="8-断开连接"><a href="#8-断开连接" class="headerlink" title="8.断开连接"></a>8.断开连接</h3><p><code>exit</code></p>
<h3 id="9-退出服务"><a href="#9-退出服务" class="headerlink" title="9.退出服务"></a>9.退出服务</h3><blockquote>
</blockquote>
<p><img src="/2020/06/18/mysql57/13.png" alt></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="1-存在data文件夹"><a href="#1-存在data文件夹" class="headerlink" title="1.存在data文件夹"></a>1.存在data文件夹</h3><ul>
<li>删除原本data，初始化命令自动生成新的data文件夹</li>
<li>data文件夹自己手动创建可能报错，最好还是由系统自动创建<blockquote>
</blockquote>
<img src="/2020/06/18/mysql57/7.png" alt></li>
</ul>
<h3 id="2-无法启动服务"><a href="#2-无法启动服务" class="headerlink" title="2.无法启动服务"></a>2.无法启动服务</h3><blockquote>
</blockquote>
<p><img src="/2020/06/18/mysql57/1.png" alt><br><img src="/2020/06/18/mysql57/8.png" alt></p>
<pre><code>更改注册表信息</code></pre><blockquote>
</blockquote>
<p><img src="/2020/06/18/mysql57/2.png" alt><br><img src="/2020/06/18/mysql57/3.png" alt></p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/2020/05/15/mybatis/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>1. 什么是框架（Framework）？
    系统中可重用的代码部分，包括一组构件以及构件之间的交互逻辑
    软件开发中的一种解决方案，不同的框架解决不同的问题
    框架封装了很多技术细节，使用者可以方便实现功能，提高开发效率

2. 三层架构
    * 表现层：
        展示数据
    * 业务层：
        处理业务需求
    * 持久层：
        数据库交互

3. 持久层技术解决问题和方案
    1. 问题
        数据库的连接和访问，数据查询效率，操作繁琐，不能将注意力聚焦到SQL处理上
        JDBC,Spring JDBCTemplate，传统的数据库连接方法，一组解决数据库连接的规范，接口

    2. MyBatis概述
        * 基于Java的持久层框架，DAO层
        * 内部封装了jdbc的细节,使用者只需要关注SQL语句，不用关心加载驱动，数据库连接，Statement对象等过程
        * 使用ORM(Object Relation Mapping)思想实现了结果集的封装
            PS: ORM
                数据库表和实体类以及实体类的属性对应起来，可以操作实体类实现操作数据表
                    user表        User类
                    id          userId</code></pre><h2 id="MyBatis入门"><a href="#MyBatis入门" class="headerlink" title="MyBatis入门"></a>MyBatis入门</h2><pre><code>1. 环境搭建
    1. new --&gt; project --&gt; maven 设置名称，导入坐标pom.xml
    2. 创建实体类和Dao的接口:Dao(data access object 数据访问对象)
    3. 创建mybatis的主配置文件
        * SqlMapConfig.xml ：&lt;property &gt; 标签名称需要匹配，ps:username 不是 user
    4. 创建映射配置文件
        * UserDao.xml :&lt;mapper namespace=&quot;UserDao的路径&quot;&gt;

    注意事项：
        1. 创建UserDao.xml UserDao.java，mybatis中将持久层的操作接口名称和映射文件也叫做：Mapper
            UserDao 和 UserMapper相同
        2. 在idea创建目录时，和包的创建不同
            包在创建时，com.mybatis_base_01.dao 三层结构
            目录：com.mybatis_base_01.dao 一级目录
        3. 映射配置文件位置必须和dao接口的包结构相同
        4. 映射配置文件的mapper标签的namespace属性取值为dao接口的全限定类名
        5. 映射配置文件的操作设置，id取值必须时dao接口的方法名

        在实现3，4，5后，dao的实现类由mybatis实现

2. 使用案例
    1. 配置文件
        * InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
    2. 创建SqlSessionFactory对象
        * SqlSessionFacotryBulider builder = new SqlSessionFacotryBuilder();
        * SqlSessionFacotry facotry = builder.build(in);
    3. 创建SqlSession对象
        * SqlSession session = facotry.openSession();
    4. 创建UserDao代理对象
        * UserDao userDao = session.getMapper(UserDao.class);
    5. 使用UserDao代理对象执行操作
        * List&lt;User&gt; userDao = userDao.findAll();
    6. 释放资源
        * session.close();
        * in.close();

3. 简单分析
    1. 配置文件
        Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); 
        * 使用类加载器，只能读取类路径的配置文件，src下的目录
        * 使用ServletContext对象的getRealPath()

    2. 创建SqlSessionFactory工厂
        * 使用了创建者模式：SqlSessionFacotryBuilder builder 构造者 builder.build(in) 建立工厂
        * 使用了工厂模式：SqlSessionFactory 降低类之间的依赖关系

    3. 创建SqlSeccion对象
    4. 创建接口实现类

4. 使用注解开发MyBatis
    1. 将UserDao.xml移除，在Dao接口的方法上使用@Select()注解，并且指定sql语句
    2. 在SqlMapConfig.xml中的Mapper配置时，使用class属性指定Dao接口的全限定类名

5. 自定义MyBatis分析
    Mybatis在使用代理Dao对象实现增删改查做了什么事？
        1. 创建代理对象
        2. 调用selectList()方法</code></pre><blockquote>
<pre><code>&lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis_test&quot;/&gt;
&lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
&lt;property name=&quot;password&quot; value=&quot;root2019&quot;/&gt;</code></pre></blockquote>
<pre><code>连接数据库的语句，可以产生Connnection对象</code></pre><blockquote>
<mappers>
<mapper resource="com/mybatis_base_03/dao/UserDao.xml">
</mapper></mappers>
</blockquote>
<p>​    </p>
<blockquote>
<pre><code>&lt;mapper namespace=&quot;com.mybatis_base_03.dao.UserDao&quot;&gt; 
&lt;!--配置查询所有--&gt;
&lt;select id=&quot;findAll&quot; resultType=&quot;com.mybatis_base_03.domain.User&quot;&gt;
   select * from user
&lt;/select&gt;</code></pre></blockquote>
<pre><code>映射配置信息 -&gt; 全限定类名，以及执行的SQL语句。
解析.xml配置文件 -&gt; 有了上面的三个信息
    1. 根据配置数据库的语句，可以创建Connection对象
        注册驱动，创建连接对象
    2. 获取预处理对象PreparedStatement
        获取SQL语句
    3. 对结果进行封装
        根据实体类的全限定类名</code></pre><p>​    6.自定义MyBatis中涉及的实体类和接口<br>​        1. class Resources<br>​        2. class SqlSessionFactoryBuilder<br>​        3. interface SqlSessionFacotry<br>​        4. interface SqlSession<br>​        这个过程完成了两件事：<br>​            创建接口代理对象，<br>​            实现查询语句</p>
<pre><code>MyBatis将JDBC的功能进行封装，形成功能调用。SqlMapConfig.xml,daoInterfaceClass.xml里面包含对数据库的连接与查询的语句以及返回的结果类型。

SqlMapConfig.xml中的&lt;property&gt;标签包含数据库的连接对象，&lt;mappers/mapper&gt;包含接口的文件位置。
daoInterfaceClass.xml包含数据库语句，返回数据类的全限定类名，以及方法的namespace(根据查查询语句以及namespace确定方法的唯一性)。

根据这两个配置文件，可以通过对.xml文件的解析，获取相应的配置文件信息，由此构建代理对象，g根据返回数据的类型获取数据，实现整个的查询过程。</code></pre><h2 id="MyBatis的CRUD"><a href="#MyBatis的CRUD" class="headerlink" title="MyBatis的CRUD"></a>MyBatis的CRUD</h2><h3 id="MyBatis的配置文件"><a href="#MyBatis的配置文件" class="headerlink" title="MyBatis的配置文件"></a>MyBatis的配置文件</h3><pre><code>1. pom.xml的配置信息
    * 坐标的导入
        1.mybatis的坐标导入
        2.mysql的驱动坐标导入
        3.log4j的坐标导入
            log4j.properties配置文件放在资源目录下
        4.junit单元测试的坐标导入

2. SqlMapConfig.xml的配置
    1. &lt;environments&gt;:配置数据库
        1. 数据库连接
        2. 数据库的事务类型
        3. 数据库的数据源
        4. 数据库的连接（driver url username password）</code></pre><blockquote>
<pre><code>&lt;!--配置环境--&gt;
&lt;environments default=&quot;mysql&quot;&gt;
 &lt;!--配置mysql的环境--&gt;
 &lt;environment id=&quot;mysql&quot;&gt;
  &lt;!--配置事务--&gt;
  &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
  &lt;!--配置连接池--&gt;
  &lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;!--mysql的连接信息--&gt;
    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis_test&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root2019&quot;/&gt;
  &lt;/dataSource&gt;
 &lt;/environment&gt;
&lt;/environments&gt;</code></pre></blockquote>
<pre><code>2. &lt;mappers&gt;:配置dao的数据接口
    1. recource:表示配置方式为.xml
    2. class:表示配置方式为注解
    &lt;!--配置映射文件的位置--&gt;</code></pre><blockquote>
<pre><code>&lt;mappers&gt;
    &lt;mapper resource=&quot;com/mybatis_base_04_crud/dao/IUserDao.xml&quot;&gt;&lt;/mapper&gt;
  &lt;/mappers&gt;</code></pre></blockquote>
<pre><code>3. DaoInterface.xml
    1.&lt;mapper&gt;中的namespase 与 &lt;select&gt;中的id构成方法的唯一标识
    2.&lt;select&gt;中的文本内容为要执行的语句
    3.&lt;select&gt;中的 resultType 返回值类型</code></pre><blockquote>
<pre><code>&lt;!--namespace 接口--&gt;
&lt;mapper namespace=&quot;com.mybatis_base_04_crud.dao.IUserDao&quot;&gt;

 &lt;select id=&quot;finaAll&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
       select * from user
  &lt;/select&gt;
&lt;/mapper&gt;</code></pre></blockquote>
<h3 id="MyBatis的数据操作"><a href="#MyBatis的数据操作" class="headerlink" title="MyBatis的数据操作"></a>MyBatis的数据操作</h3><h4 id="保存数据-Insert"><a href="#保存数据-Insert" class="headerlink" title="保存数据(Insert)"></a>保存数据(Insert)</h4><pre><code>1. Dao接口的方法
    在IUserDao.java中添加saveUser方法
2. daoInterace.xml中的配置
    在&lt;mapper&gt;中增加&lt;insert&gt;标签，选择参数化类型，对于数据填充，采用#{}方式</code></pre><blockquote>
<pre><code>&lt;!-- 保存用户 --&gt;
  &lt;!--参数类型 parameterType--&gt;
  &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
        insert into user(username,address,sex,birthday) value(#{username},#{address},#{sex},#{birthday})
 &lt;/insert&gt;
实体类的属性定义与数据库中的列名一致,setter和getter方法自动生成，可以直接使用属性名称来传递参数，否则可以使用.getUsername()来传递参数。    </code></pre></blockquote>
<pre><code>3. 调用方法
    在生成数据库的代理对象后，直接调用save方法就可以        

4. 注意事项
    在使用方法后，需要对数据进行提交，默认自动提交关闭，需要手动打开自动提交
    session.commit();</code></pre><h5 id="保存数据的同时返回id"><a href="#保存数据的同时返回id" class="headerlink" title="保存数据的同时返回id"></a>保存数据的同时返回id</h5><pre><code>1.daoInterface.xml
    在原本的&lt;insert&gt;标签内，增加&lt;selectKey&gt;标签</code></pre><blockquote>
<pre><code>&lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;
  select last_insert_id();
&lt;/selectKey&gt;
在执行结束之后，会将id返回到user的id属性之中
keyProperty=&quot;id&quot; 实体类的属性
keyColumn=&quot;id&quot; 数据表中的列名</code></pre></blockquote>
<h4 id="更新数据-Update"><a href="#更新数据-Update" class="headerlink" title="更新数据(Update)"></a>更新数据(Update)</h4><pre><code>1. Dao接口的方法
    void saveUser(User user);
2. daoInterace.xml</code></pre><blockquote>
<pre><code>&lt;!-- 更新 --&gt;
  &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
    update user set username = #{username},address=#{address},sex=#{sex},birthday=#{birthday} where id=#{id}
  &lt;/update&gt;</code></pre></blockquote>
<h4 id="删除数据-Delete"><a href="#删除数据-Delete" class="headerlink" title="删除数据(Delete)"></a>删除数据(Delete)</h4><pre><code>1. Dao接口的方法
    void deleteUser(Integer userId);
2. daoInterface.xml</code></pre><blockquote>
<pre><code>&lt;!-- 删除数据 --&gt;
  &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
    delete from user where id=#{uid}
  &lt;/delete&gt;</code></pre></blockquote>
<pre><code>3. 注意事项
    删除数据中只有一个元素，#{}中的元素只是起到一个占位符的作用，与名称无关</code></pre><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><h5 id="根据用户id"><a href="#根据用户id" class="headerlink" title="根据用户id"></a>根据用户id</h5><pre><code>1. dao接口的方法
    User finaById(Integer id);
2. daoInterface.xml
    需要传入参数，以及返回值类型</code></pre><blockquote>
<pre><code>   &lt;!-- 根据id查询一个 --&gt;
&lt;select id=&quot;findById&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
   select * from user where id=#{id}
&lt;/select&gt;</code></pre></blockquote>
<h5 id="根据用户name"><a href="#根据用户name" class="headerlink" title="根据用户name"></a>根据用户name</h5><pre><code>1. dao接口的方法
    List&lt;User&gt; findByName(String name);
2. daoInterface.xml</code></pre><blockquote>
<pre><code>&lt;!-- 根据名称模糊查询 --&gt;
&lt;select id=&quot;findByName&quot; parameterType=&quot;string&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
 select * from user where username like #{name}</code></pre>  
</blockquote>
<pre><code>3. 注意事项
    &apos;#{}中没有模糊查询的 “-” “%” 在调用传参数时，需要给出“%王%”,查询语句为预处理SQL语句
    &apos;%${value}%&apos;,参数为“王”，查询语句为拼接字符串,不会自动添加单引号，使用默认值value或者@Param()指定参数名</code></pre><h3 id="MyBatis中的参数-parameterType"><a href="#MyBatis中的参数-parameterType" class="headerlink" title="MyBatis中的参数(parameterType)"></a>MyBatis中的参数(parameterType)</h3><h4 id="参数的类型-parameterType"><a href="#参数的类型-parameterType" class="headerlink" title="参数的类型(parameterType)"></a>参数的类型(parameterType)</h4><pre><code>1. 简单数据类型
    int String ...

2. 传递pojo对象
    pojo对象：
        POJO简单理解为不包含业务逻辑的单纯用来存储数据的java类（实际就是普通JavaBean)

    OGNL表达式：</code></pre><p><em>Object Graphic Navigation Language</em><br>        (对象图形导航语言)</p>
<pre><code>    通过对象的取值方法来获取数据，在写法上，将get给忽略了
    比如：获取用户的名称
        类中的写法：user.getUsername()
        OGNL表达式：user.username()
    mybatis中可以直接使用username,不用书写user.
        因为在parameterType中已经提供属性所在的类

3. 传递pojo包装对象
    参数为被封装的数据，查询条件是综合的查询条件</code></pre><blockquote>
<pre><code>&lt;!-- 根据queryVo查询数据 --&gt;
&lt;select id=&quot;findByQueryVo&quot; parameterType=&quot;com.mybatis_base_04_crud.domain.QueryVo&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
  select * from user where username like #{user.username}
&lt;/select&gt;</code></pre></blockquote>
<pre><code>QueryVo内部封装user对象，在参数传递时#{}，中的参数为 QueryVo.user.username,可以写为 user.username,代表参数为QueryVo中数据对象user中的属性username</code></pre><h4 id="结果集的封装-resultType"><a href="#结果集的封装-resultType" class="headerlink" title="结果集的封装(resultType)"></a>结果集的封装(resultType)</h4><pre><code>实体类的属性名与数据库的列名不相同？
    1. 给数据库中的列名起别名
        将所有查询的数据字段的名称别名改为实体类对应的属性名称
        书写更为复杂，但是查询到的数据在数据库端被处理，效率更高
    select id as uesrId,username as userName, address as userAddress, sex as userSex,birthday as userBirthday from user;

    2. 使用resultMap进行字段对应</code></pre><blockquote>
<pre><code><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置 查询结果的列名和属性名一致 --&gt;</span><br><span class="line">&lt;resultMap id="userMap" type="com.mybatis_base_04_crud.domain.User"&gt;</span><br><span class="line">    &lt;!-- 主键字段的一致 --&gt;</span><br><span class="line">	&lt;id property="userId" column="id"/&gt;</span><br><span class="line">	&lt;!-- 非主键字段的一致 --&gt;</span><br><span class="line">	&lt;result property="userName" column="username"&gt;&lt;/result&gt;</span><br><span class="line">	&lt;result property="userAddress" column="address"&gt;&lt;/result&gt;</span><br><span class="line">	&lt;result property="userSex" column="sex"&gt;&lt;/result&gt;</span><br><span class="line">	&lt;result property="userBirthday" column="birthday"&gt;&lt;/result&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">	</span><br><span class="line">&lt;!--select id as uesrId,username as userName, address as userAddress, sex as userSex,birthday as userBirthday from user;--&gt;</span><br><span class="line">&lt;select id="finaAll" resultMap="userMap"&gt;</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></code></pre></blockquote>
<pre><code>resultMap中的id为映射标记，返回值必须更改为resultMap=&quot;userMap&quot;，进行绑定
id 数据库中的主键字段数据绑定
result 非主键字段的数据绑定
property 实体类中的属性名称
column 数据库中的字段名称

    3. 两种方法的不同    
        直接使用别名，运行效率更高，但编写效率较低
        使用resultMap，运行效率低，但是编写效率高</code></pre><h3 id="MyBatis实现DAO开发"><a href="#MyBatis实现DAO开发" class="headerlink" title="MyBatis实现DAO开发"></a>MyBatis实现DAO开发</h3><h4 id="使用Dao的实现类"><a href="#使用Dao的实现类" class="headerlink" title="使用Dao的实现类"></a>使用Dao的实现类</h4><pre><code>1. 创建IUserDaoImpl.java
2. 在实现类中实现方法
    创建Sqlsession对象，在方法中调用相应的查询语句</code></pre><figure class="highlight"><table><tr><td class="code"><pre><span class="line">public List&lt;UserfinaAll() &#123;</span><br><span class="line">    //生成SqlSession对象</span><br><span class="line">    SqlSession session = factory.openSession();</span><br><span class="line">    //调用session的selectList方法，实现查询列表</span><br><span class="line">    List&lt;Userusers = session.selectList("com.mybatis_base_04_DAO.dao.IUserDao.finaAll");</span><br><span class="line">    //方法中的参数 能获取到信息的key namespace + methodName</span><br><span class="line">    //释放资源</span><br><span class="line">    session.close();</span><br><span class="line">    return users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>* MyBatis实际上使用代理Dao的方式，将创建Dao实现类的过程给隐藏，用户无法感知到创建Dao实现类的过程。
* 自己使用Dao实现类实际上就是创建SqlSession对象，通过调用session.selectList()方法查询数据。
* 方法中的参数：（namaspace+methodName , 外部传入的参数）</code></pre><h3 id="执行过程分析"><a href="#执行过程分析" class="headerlink" title="执行过程分析"></a>执行过程分析</h3><h4 id="dao实现类的执行过程分析"><a href="#dao实现类的执行过程分析" class="headerlink" title="dao实现类的执行过程分析"></a>dao实现类的执行过程分析</h4><pre><code>1. selectList


2. insert update delete
    insert update delete最终调用的都是update方法

3. selectOne
    selectOne内部调用selectList方法，返回值为列表的第一个元素</code></pre><h4 id="代理Dao实现类的执行过程分析"><a href="#代理Dao实现类的执行过程分析" class="headerlink" title="代理Dao实现类的执行过程分析"></a>代理Dao实现类的执行过程分析</h4><p><em>暂时未进行书写</em></p>
<h3 id="SqlMapConfig-xml中的标签属性"><a href="#SqlMapConfig-xml中的标签属性" class="headerlink" title="SqlMapConfig.xml中的标签属性"></a>SqlMapConfig.xml中的标签属性</h3><pre><code>1. &lt;properties&gt;标签
    * 配置properties 可以在标签内部配置数据库的连接信息，也可以引用外部配置文件信息
    * 使用&lt;properties&gt;标签，在环境的数据源中的对应数据使用 ${名称} 可以引用
    * 可能会出现：未声明的文件，直接进行引用就可以了        

    resource属性：
          用于指定配置文件的位置，按照类路径的写法来写，必须存放于类路径下

    url属性：
          要求按照url的写法来书写地址
          url Uniform Resource Locator 统一资源定位符
          写法：
            http://localhost:8080/mybatisserver/demo1Serelet
            协议 主机 端口 URI
           URI Uniform Resource Identifier 统一资源标识符 应用中唯一定位的资源</code></pre><blockquote>
<pre><code>&lt;properties url=&quot;file:///D:/2017217796/java_program/MyCode/mybatis_base_04_crud/src/main/resources/jdbcConfig.properties&quot;&gt;

&lt;/properties&gt;

&lt;!--mysql的连接信息--&gt;
&lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
&lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
&lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
&lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;        </code></pre></blockquote>
<pre><code>2. &lt;typeAliases&gt;标签
    1). &lt;typeAlias&gt;标签
        * typeAlias配置别名，只能配置domain中的实体类
        * type指定全限定属性名 alias指定别名 不在区分大小写</code></pre><blockquote>
<pre><code>&lt;typeAlias type=&quot;com.mybatis_base_04_crud.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;</code></pre></blockquote>
<pre><code>2). &lt;package&gt;标签
    * 用于指定要配置别名的包，当指定后，该包中的所有实体类都会被注册别名，且类名就是别名，不再区分大小写</code></pre><blockquote>
<pre><code>&lt;package name=&quot;com.mybatis_base_04_crud.domain&quot;/&gt;</code></pre></blockquote>
<pre><code>3. &lt;mappers&gt;标签
    * package指定接口所在的包，一但指定，就不需要写resource和class以及mapper</code></pre><blockquote>
<pre><code>&lt;package name=&quot;com.mybatis_base_04_crud.dao&quot;/&gt;</code></pre></blockquote>
<h2 id="MyBatis的连接池"><a href="#MyBatis的连接池" class="headerlink" title="MyBatis的连接池"></a>MyBatis的连接池</h2><h3 id="连接池的使用与分析"><a href="#连接池的使用与分析" class="headerlink" title="连接池的使用与分析"></a>连接池的使用与分析</h3><h4 id="连接池的含义"><a href="#连接池的含义" class="headerlink" title="连接池的含义"></a>连接池的含义</h4><pre><code>连接池是用于存储连接的一个容器
容器其实就是一个集合对象，该集合必须是线程安全的，不能两个线程拿到同一个连接
该集合必须实现队列的特性：先进先出

使用连接池可以减少获取连接的时间</code></pre><h4 id="MyBatis的连接池-1"><a href="#MyBatis的连接池-1" class="headerlink" title="MyBatis的连接池"></a>MyBatis的连接池</h4><pre><code>1. SqlMqpConfig.xml中的datasource标签，type属性表示使用何种连接池方式
    type的取值：
        POOLED : 采用传统的javax.sql.DataSource规范的连接池
        UNPOOLED ：采用传统的获取连接的方式，虽然也实现了javax.sql.DataSource接口，但是没有池的概念，每次使用都获取新的连接
        JNDI ：采用服务器提供的JNDI实现，获取DataSource对象，不同的服务器拿到的对象不一样，如果不是web或者maven的war工程，不能使用
        使用tomcat服务器，使用的连接池dbcp连接池</code></pre><blockquote>
<pre><code>&lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;!--mysql的连接信息--&gt;
    &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
&lt;/dataSource&gt;</code></pre></blockquote>
<p><img src="/2020/05/15/mybatis/datasource_0.png" alt="POOLED"><br><img src="/2020/05/15/mybatis/pooled_datasource_1.png" alt="POOLED"><br><img src="/2020/05/15/mybatis/pooled_datasource_2.png" alt="POOLED"></p>
<h4 id="补充JNDI数据库连接池"><a href="#补充JNDI数据库连接池" class="headerlink" title="补充JNDI数据库连接池"></a>补充JNDI数据库连接池</h4><h4 id="MyBatis中的事务"><a href="#MyBatis中的事务" class="headerlink" title="MyBatis中的事务"></a>MyBatis中的事务</h4><pre><code>1. MyBatis通过commit以及rollback来进行事务控制
2. 一般不设置自动提交，因为一旦多个事务提交，难以控制</code></pre><h2 id="MyBatis基于XML配置的动态SQL语句使用"><a href="#MyBatis基于XML配置的动态SQL语句使用" class="headerlink" title="MyBatis基于XML配置的动态SQL语句使用"></a>MyBatis基于XML配置的动态SQL语句使用</h2><h3 id="if-标签"><a href="#if-标签" class="headerlink" title="if 标签"></a>if 标签</h3><pre><code>* 根据条件来进行查询，此时条件可能不全，有可能缺少某些项，会根据条件具体生成查询语句
SQL语句中的名称不区分大小写，但是查询条件需要根据实体类相关，一般来说实体类的属性名与数据库的列名相同。</code></pre><blockquote>
<pre><code>&lt;!-- 根据条件查询 --&gt;
&lt;select id=&quot;findUserByCondition&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;
 select * from user where 1=1
 &lt;if test=&quot;userName != null&quot;&gt;
   and username like #{userName}
 &lt;/if&gt;</code></pre>   
</blockquote>
<pre><code>* test：判断输入的条件，如果条件满足，查询条件会包含if标签内部的语句
* 可以多个if标签一起使用
* 条件同时满足的时候使用 and ，可以在数据库语句中使用</code></pre><h4 id="where标签"><a href="#where标签" class="headerlink" title="where标签"></a>where标签</h4><pre><code>* 使用where标签将if标签包裹起来，在查询条件中就不用书写 where 1 = 1</code></pre><blockquote>
<pre><code>  &lt;!-- 根据条件查询 --&gt;
&lt;select id=&quot;findUserByCondition&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;
select * from user
&lt;where&gt;
  &lt;if test=&quot;userName != null&quot;&gt;
    and username like #{userName}
  &lt;/if&gt;
  &lt;if test=&quot;userSex != null&quot;&gt;
    and sex = #{userSex}
  &lt;/if&gt;
&lt;/where&gt;</code></pre>  
</blockquote>
<h4 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h4><blockquote>
<pre><code>&lt;!-- 根据QueryVo中的ids进行查询，集合尽心查询列表 --&gt;

&lt;select id=&quot;findUserInIds&quot; parameterType=&quot;queryvo&quot; resultMap=&quot;userMap&quot;&gt;
select * from user
&lt;where&gt;
  &lt;if test=&quot;ids != null and ids.size() &gt; 0&quot;&gt;
    &lt;foreach collection=&quot;ids&quot; open=&quot;and id in (&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;
      #{id}
    &lt;/foreach&gt;
  &lt;/if&gt;
&lt;/where&gt;
&lt;/select&gt;</code></pre></blockquote>
<pre><code>* 查询满足条件的集合元素:select * from user where id in (?)
* foreach:
* collection:代表要遍历的集合元素
* open:语句的开始部分
* close:语句的结束部分
* item:遍历的每个元素，生成的变量名
* separtor:分割符

其中&lt;foreach&gt;中的语句 #{}中的名称，需要与item一致

在进行多个数据一起插入的时候，可以使用foreach进行 values()的赋值</code></pre><h4 id="sql标签"><a href="#sql标签" class="headerlink" title="sql标签"></a>sql标签</h4><pre><code>* 抽取重复的SQL语句，避免重复书写语句
* 然后在语句中使用&lt;include&gt;来引用抽取的语句
* 如果后面还有需要拼接的条件，不能 书写分号</code></pre><blockquote>
<pre><code>&lt;!-- 抽取重复的语句 --&gt;
&lt;sql id=&quot;defaultUser&quot;&gt;
  select * from user
&lt;/sql&gt;

&lt;!--select id as uesrId,username as userName, address as userAddress, sex as userSex,birthday as userBirthday from user;--&gt;
&lt;select id=&quot;finaAll&quot; resultMap=&quot;userMap&quot;&gt;
  &lt;include refid=&quot;defaultUser&quot;&gt;&lt;/include&gt;
&lt;/select&gt;</code></pre></blockquote>
<h2 id="Mybatis的多表操作"><a href="#Mybatis的多表操作" class="headerlink" title="Mybatis的多表操作"></a>Mybatis的多表操作</h2><pre><code>表之间的关系：
    一对一
    多对一
    一对多
    多对多

举例：
    用户对于订单：一对多
    订单对于用户：多对一
        一个用户可能有多个订单
        多个订单属于一个用户

    一对一：
        一个人只能有一身份证号
        一个身份证号属于一个人

    多对多：
        一个学生被多个老师教过
        一个老师教过多个学生

在MyBatis中，认为订单与用户之间的关系，每拿出一个订单，只能属于一个用户
所以，所有的多对一，全都为一对一

案例：
    使用用户与账户之间的关系
        一个用户可以有多个账户
        一个账户只能属于一个用户(多个账户也是一个用户)

步骤：
    1. 建立两张表：用户表 账户表
        用户与账户具有关系：使用外键
    2. 建立两个实体类：用户实体 账户实体
    3. 建立两个配置文件
        用户配置文件
        账户配置文件
    4. 实现配置
        当查询用户时，可以出现账户信息
        查询账户时，可以显示出对应的用户信息</code></pre><h3 id="一对一查询的结果封装《association》"><a href="#一对一查询的结果封装《association》" class="headerlink" title="一对一查询的结果封装《association》"></a>一对一查询的结果封装《association》</h3><pre><code>1. 通过书写子类来进行配置查询
    * 建立新的结果集的封装类，将查询到的结果进行封装
    * 每次查询不同的数据需要书写不同的字类，太过于麻烦

2. 建立实体类之间的关系来进行数据封装
    * 主表与从表之间存在联系，主表实体和从表实体之间也存在联系
    * 从表包含主表实体的引用
    * 据此，创建resultMap，进行结果封装
    * 使用 association 进行一对一的结果封装</code></pre><blockquote>
<pre><code> &lt;!-- 定义封装account和user的resultMap --&gt;
&lt;resultMap id=&quot;accountuser&quot; type=&quot;account&quot;&gt;
&lt;id property=&quot;id&quot; column=&quot;aid&quot;&gt;&lt;/id&gt;
&lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;
&lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt;
  &lt;!-- 一对一的关系映射:配置封装user的信息 --&gt;
  &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
  &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
  &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;
  &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;
  &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt;
&lt;/association&gt;</code></pre>  
</blockquote>
<pre><code>在association中，如果不写javaType,报错：空指针异常
javatype:将数据封装到实体对象中</code></pre><h3 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询<collection></collection></h3><pre><code>* 一对多连接，主表的实体类需要包含从表实体类的集合引用，在配置文件中，使用collection标签来封装数据集合</code></pre><p><img src="/2020/05/15/mybatis/one2manyxml.png" alt="主体的配置文件"><br>        数据查询结果<br><img src="/2020/05/15/mybatis/one2many.png" alt="主体的配置文件"></p>
<pre><code>* 数据查询结果显示，数据为一对多情况，MyBatis将属于同一个用户的账户，封装到了账户的集合之中</code></pre><h3 id="多对多查询"><a href="#多对多查询" class="headerlink" title="多对多查询"></a>多对多查询</h3><pre><code>示例：用户与角色之间的关系
    一个用户可以拥有多个角色
    一个角色可以赋予多个用户

    典型的多对多

    1. 建立两张表：用户表 角色表
    2. 两者具有多对多的关系
        建立中间表，主键为两者的联合主键，中间表中是外键
    3. 建立两个实体类
        让用户和角色实体类能体现出多对多的关系
        两者分别包含对象集合引用
    4. 建立两个配置文件
    5. 实现配置
        查询用户时，同时得到包含的角色信息
        查询角色时，同时得到包含的用户信息</code></pre><p><img src="/2020/05/15/mybatis/many2many.png" alt="many2many的配置文件"><br><img src="/2020/05/15/mybatis/many2many_1.png" alt="many2many的配置文件"></p>
<pre><code>* 一个用户包含的所有角色信息，因为要包括所有的用户，不能使用内连接，应该使用外连接，在使用user_role表的时候，有可能列名相同,需要别名，在写配置resultMap时，注意别名</code></pre><h2 id="MyBatis延迟加载"><a href="#MyBatis延迟加载" class="headerlink" title="MyBatis延迟加载"></a>MyBatis延迟加载</h2><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><pre><code>在一对多的数据查询的时候，一个用户，100个账户
    在查询用户信息的时候，要不要将账户的信息查询出来
    在查询账户信息的时候，要不要将用户的信息查询出来

    在查询账户的时侯，用户下的账户的信息应该是，什么时候使用，什么时候查询
    在查询用户的时候，账户下的用户的信息应该是，随着账户的信息一起查询出来

1. 延迟加载
    在真正使用数据的时侯，才将数据查询出来；不使用的时候，不进行查询

2. 立即加载
    无论数据是否使用，一旦调用方法，马上进行查询

3. 使用时机
    一对一，多对一：立即加载（一般需要立刻看到信息）
    一对多，多对多：延迟加载（一般不需要立刻看到信息）</code></pre><h4 id="实现延迟加载"><a href="#实现延迟加载" class="headerlink" title="实现延迟加载"></a>实现延迟加载</h4><pre><code>1. 在一对一的时候实现延迟加载
    * 更改查询语句
        在此时，不需要将所有的数据全都查询出来，只需要将所有的账户查询出来，不需要带着用户信息
    * 修改结果集
        由于不需要用户信息，结果集的封装可以删除
    * 修改级联查询语句
        在&lt;association&gt;语句中，增加select属性，指明查询的唯一标识</code></pre><blockquote>
<pre><code>&lt;!-- 定义封装account和user的resultMap --&gt;
&lt;resultMap id=&quot;accountuserMap&quot; type=&quot;account&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
  &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;
  &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt;

&lt;!-- 一对一的关系映射:配置封装user的信息,
select 查询用户的唯一标识,在接口文件中，根据id查询用户的方法
column 用户根据id查询时，所需要的参数的值，此地将查询出来的uid作为参数传入
 --&gt;
&lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot; select=&quot;com.mybatis_base_06_lazyload.dao.IUserDao.findById&quot;&gt;

&lt;/association&gt;</code></pre>  
</blockquote>
<pre><code>* 修改SqlMapConfig.xml,打开延迟加载开关
    打开延迟加载的开关，关闭立即加载的开关</code></pre><blockquote>
<pre><code>&lt;!-- 配置参数。延迟加载 --&gt;
&lt;settings&gt;
  &lt;!-- 开启延迟加载的全局开关 --&gt;
  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;!-- 立即加载 --&gt;
  &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;
&lt;/settings&gt;</code></pre></blockquote>
<p><img src="/2020/05/15/mybatis/lazyload1.png" alt="一对一的延迟加载"></p>
<pre><code>2. 什么是按需？
    1. 在进行单独数据查询，或者是数据遍历时，才会将所有数据显示出来
    2. 根据用户的id，或者其他的要求进行数据查询

3. 一对多的数据查询    
    与一对一的延迟加载相似,查询语句，结果集，以及账户实体类中的按照id查询</code></pre><p><img src="/2020/05/15/mybatis/lazyload2.png" alt></p>
<h2 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h2><h3 id="缓存基本概念"><a href="#缓存基本概念" class="headerlink" title="缓存基本概念"></a>缓存基本概念</h3><pre><code>存在内存中的临时数据

1. 为什么使用缓存？
    减少和数据库的交互次数，提高执行效率

2. 什么数据能使用缓存，什么数据不能使用？
    1. 适用于缓存：
        经常查询并且不经常改变的
        数据的正确性对最终结果影响不大的

    2. 不适用缓存：
        经常改变的数据
        数据的正确性对最终结果影响很大的
            （商品的库存，银行的汇率，股市的股价）</code></pre><h3 id="MyBatis的缓存-1"><a href="#MyBatis的缓存-1" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h3><pre><code>1. 一级缓存：
    它是指Mybatis中的SqlSession对象的缓存
    当我们执行查询的时候，查询的结果会同时存入到SqlSession为我们提供的一块区域内该区域的结构是一Map。当我们再次查询同样的数据，mybatis会先去SqlSession中查询是否存在，有的话，直接拿来使用
    当SqlSession对象消失时，一级缓存同时消失

    1. 缓存同步问题
        如果调用session的insert update delete close() commit() clearcache()方法，会自动放弃当前的一级缓存，直接从数据库中查询数据

2. 二级缓存
    由MyBatis中SqlSessionFactory对象的缓存，同一个SqlSessionFactory对象创建的SqlSession对象共享其缓存。

    1. 二级缓存的使用步骤
        1. 让MyBatis支持二级缓存 SqlMapConfig.xml配置
        2. 让当前的映射文件支持二级缓存，IUserDao.xml
        3. 让当前的操作支持二级缓存，select标签</code></pre><h2 id="MyBatis注解开发"><a href="#MyBatis注解开发" class="headerlink" title="MyBatis注解开发"></a>MyBatis注解开发</h2><h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><pre><code>1. 在SqlMapConfig.xml中的mapper中，使用class,导入接口资源文件
2. 在接口类上，使用注解进行开发
3. 其余步骤与使用xml开发一致

注意：
    如果在与接口类的相同路径下的资源路径下，建立IUserDao.xml文件，不管有没有使用.xml文件，都会产生错误。</code></pre><h3 id="名称不一致"><a href="#名称不一致" class="headerlink" title="名称不一致"></a>名称不一致</h3><pre><code>1. 实体类名与数据库列名不一致
    1. 使用别名，将数据库中查询出来的数据进行设置别名
    2. 使用@Results注解，进行配置</code></pre><blockquote>
<pre><code>/**
 * 查询所有,获取所有的账户信息
 */
@Select(&quot;select * from user&quot;)
@Results(id= &quot;userMap&quot;,value = {
        @Result(id=true,column = &quot;id&quot;,property = &quot;userId&quot;),
        @Result(column = &quot;username&quot;,property = &quot;userName&quot;),
        @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;),
        @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;),
        @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;)
})
List&lt;UserfindAll();

@Select(&quot;select * from user where id=#{id}&quot;)
@ResultMap(value = {&quot;userMap&quot;})
User findById(Integer id);</code></pre></blockquote>
<pre><code>    * @Results中id是唯一标识，定义之后，可以在别的位置使用
        values代表结果对应的封装数组

    * @Result中，id代表是否为唯一标识，默认为false
        column:数据库列名
        property:实体类属性名

2. 定义了@Results注解
    想在别的地方使用，使用@resultMap注解
            @ResultMap(value = {&quot;userMap&quot;}) //完整写法
    values已经定义好的结果集封装</code></pre><h3 id="一对多查询注解版"><a href="#一对多查询注解版" class="headerlink" title="一对多查询注解版"></a>一对多查询注解版</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre><code>结果集的封装，主要关注@Result中的属性：one many
一对一：使用one 
一对多：使用many</code></pre><p><img src="/2020/05/15/mybatis/anno_one2many.png" alt="注解配置"></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><pre><code>1. mybatis-config 的properties配置属性</code></pre><p><img src="/2020/05/15/mybatis/error_1.png" alt="配置文件无法找到"></p>
]]></content>
      <categories>
        <category>SpringFramework</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛云_Hexo</title>
    <url>/2020/05/12/%E4%B8%83%E7%89%9B%E4%BA%91-Hexo/</url>
    <content><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><pre><code>1. 注册七牛云,完成之后就可以进行创建空间，
2. 注意我们添加的资源为对象存储，访问控制为公开空间
3. 点击右上角进入密钥管理，复制当前使用的AK和SK，配置的时候会用得到</code></pre><h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h2><h3 id="2-1-安装插件，进入Hexo主目录，执行："><a href="#2-1-安装插件，进入Hexo主目录，执行：" class="headerlink" title="2.1. 安装插件，进入Hexo主目录，执行："></a>2.1. 安装插件，进入Hexo主目录，执行：</h3><p><code>npm install hexo-qiniu-sync --save</code></p>
<h3 id="2-2-配置站点文件-config-yml"><a href="#2-2-配置站点文件-config-yml" class="headerlink" title="2.2. 配置站点文件_config.yml:"></a>2.2. 配置站点文件_config.yml:</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#plugins:</span></span><br><span class="line"> 	<span class="comment">#- hexo-qiniu-sync</span></span><br><span class="line"><span class="attr">qiniu:</span></span><br><span class="line">  <span class="attr">offline:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">sync:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">bucket:</span> <span class="string">bucket_name</span></span><br><span class="line">  <span class="attr">access_key:</span> <span class="string">AccessKey</span></span><br><span class="line">  <span class="attr">secret_key:</span> <span class="string">SecretKey</span></span><br><span class="line">  <span class="attr">dirPrefix:</span></span><br><span class="line">  <span class="attr">urlPrefix:</span> <span class="string">http://7xqb0u.com1.z0.glb.clouddn.com</span></span><br><span class="line">  <span class="attr">local_dir:</span> <span class="string">cdn</span></span><br><span class="line">  <span class="attr">update_exist:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line">    <span class="attr">folder:</span> <span class="string">images</span></span><br><span class="line">    <span class="attr">extend:</span></span><br><span class="line">  <span class="attr">js:</span></span><br><span class="line">    <span class="attr">folder:</span> <span class="string">js</span></span><br><span class="line">  <span class="attr">css:</span></span><br><span class="line">    <span class="attr">folder:</span> <span class="string">css</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-参数"><a href="#2-3-参数" class="headerlink" title="2.3. 参数"></a>2.3. 参数</h3><ul>
<li><p>bucket ：修改为你刚才申请的七牛空间名称</p>
</li>
<li><p>access_key 、 secret_key : 上传密钥AccessKey、SecretKey。即3 第3步复制的AK和SK。</p>
</li>
<li><p>urlPrefix : 七牛空间地址的前缀。 重要！必填！ 因为现在七牛已经取消了二级域名，外链前缀类似设置中的 <a href="http://7xqb0u.com1.z0.glb.clouddn.com" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com</a> ，插件不能根据 bucket 自动生成外链前缀了。你可以进入自己创建的空间在域名设置中看到自己的七牛测试域名，也可以查看一个已上传的文件外链地址，确认前缀无误。这个参数的设置是保证解析成网页文件时，外链地址正确的关键之一！<br>  配置参数的说明：</p>
</li>
<li><p>offline ：是否离线。设置为 true 将在本地预览时使用本地地址渲染，省流量； false 将使用同步到七牛空间的静态资源渲染，方便检查资源链接是否正确。</p>
</li>
<li><p>sync ：是否同步到七牛，一般都是设置 true 啦</p>
</li>
<li><p>dirPrefix ：资源将上传到七牛空间的此目录下，可像我一样设置为空。该参数会影响外链的地址，如果设置为非空值，例如默认值 static ，则 urlPrefix 为保持一致需加上目录后缀 /static ，改为 <a href="http://7xqb0u.com1.z0.glb.clouddn.com/static" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com/static</a> 。</p>
</li>
<li><p>local_dir ：本地资源储存目录。在本例中，待上传的资源都储存在hexo主目录中的 cdn 文件夹（也就是与 source 目录平级）中。</p>
</li>
<li><p>update_exist ：设置为 true ，则会在文件更新之后重新上传并更新七牛空间上中的原有文件。</p>
</li>
<li><p>image/js/css ：子参数folder为不同静态资源种类的目录名称，一般不需要改动</p>
</li>
<li><p>image.extend ：使用 qnimg 标签引用图片的默认图片处理操作。可以使用 基本图片处理（imageView2）、高级图片处理（imageMogr2）、图片水印处理（watermark） 这三个图片处理接口，多个接口内容之间用 | 间隔。详见 七牛开发者中心-图片处理。</p>
</li>
</ul>
<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><pre><code>1.将图片上传到七牛云，查看照片获取照片的外链
2.在文章中引用照片外链，markdown格式:*![描述]（外链）*</code></pre><h2 id="4-感谢在使用七牛云时参考的大佬博客："><a href="#4-感谢在使用七牛云时参考的大佬博客：" class="headerlink" title="4. 感谢在使用七牛云时参考的大佬博客："></a>4. 感谢在使用七牛云时参考的大佬博客：</h2><ul>
<li><a href="http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/" target="_blank" rel="noopener">http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Load</title>
    <url>/2020/05/09/SpringLoad/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code>在下载Spring时，碰到很多问题，在此记录下载流程，方便以后再次下载！</code></pre><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-搜索Spring官网-https-spring-io"><a href="#1-搜索Spring官网-https-spring-io" class="headerlink" title="1. 搜索Spring官网: https://spring.io/"></a>1. 搜索Spring官网: <a href="https://spring.io/" target="_blank" rel="noopener">https://spring.io/</a></h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_1.png" alt></p>
<h3 id="2-点击Projects"><a href="#2-点击Projects" class="headerlink" title="2. 点击Projects"></a>2. 点击Projects</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_2.png" alt></p>
<h3 id="3-点击Spring-Framework"><a href="#3-点击Spring-Framework" class="headerlink" title="3. 点击Spring Framework"></a>3. 点击Spring Framework</h3><h3 id="4-下拉界面，找到并点击-Spring-Framework-Artifacts"><a href="#4-下拉界面，找到并点击-Spring-Framework-Artifacts" class="headerlink" title="4. 下拉界面，找到并点击 Spring Framework Artifacts"></a>4. 下拉界面，找到并点击 Spring Framework Artifacts</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_3.png" alt></p>
<h3 id="5-找到并点击，http-repo-spring-io"><a href="#5-找到并点击，http-repo-spring-io" class="headerlink" title="5. 找到并点击，http://repo.spring.io"></a>5. 找到并点击，<a href="http://repo.spring.io" target="_blank" rel="noopener">http://repo.spring.io</a></h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_4.png" alt></p>
<h3 id="6-左边第二个图标，依次点击"><a href="#6-左边第二个图标，依次点击" class="headerlink" title="6.左边第二个图标，依次点击"></a>6.左边第二个图标，依次点击</h3><pre><code>libs-release-local ---&gt; org ---&gt; springframework ---&gt; spring</code></pre><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_5.png" alt><br><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_6.png" alt></p>
<h3 id="7-鼠标右键-Nature-Browser"><a href="#7-鼠标右键-Nature-Browser" class="headerlink" title="7.鼠标右键 Nature Browser"></a>7.鼠标右键 Nature Browser</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_7.png" alt></p>
]]></content>
      <categories>
        <category>SpringFramework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Inject</title>
    <url>/2020/05/09/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="SQL注入问题"><a href="#SQL注入问题" class="headerlink" title="SQL注入问题"></a>SQL注入问题</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>在拼接sql语句时，有一些特殊的SQL关键字参于字符串的拼接，导致SQL语句的逻辑发生变化，可能会造成安全性问题</code></pre><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><pre><code>1. 输入 a&apos;or&apos;a&apos;=&apos;a,条件改变
2. sql:select * from db where name and password = &apos;a&apos;or&apos;a&apos;=&apos;a&apos;,查询所有数据

原SQL语句拼接为: 

    String sql = &quot;select id from db where username=&apos;&quot;+username+&quot;&apos; and password=&apos;&quot;+password+&quot;&apos;&quot;;

用户输入的帐号密码分别为:

请输入您的帐号:
11111
请输入您的密码:
a&apos;or&apos;a&apos;=&apos;a
组成的SQL语句: 
select id from db where username=&apos;1111&apos; and password=a&apos;or&apos;a&apos;=&apos;a；</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><pre><code>使用预编译SQL语句,进行参数的传递

更改执行环境：Statement
使用新的环境: PreparedStatement

在通过连接对象，获取一个预编译的SQL环境(PreparedStatement)时, 需要传递一个SQL语句 ! 
在这个语句中 可以出现? , ? 表示准备填充的参数值!

使用步骤: 
    1. 通过连接对象, 获得一个预编译的SQL执行环境

        PreparedStatement state = conn.prepareStatement(sql);
        例如: 
            String sql = &quot;select id from db where username=? and password=?&quot;;
            PreparedStatement state = conn.prepareStatement(sql);    

    2. 向预编译参数列表中传递值: 

        预编译的SQL语句中可以包含【多个问号】, 每一个问号表示一个需要传递的值 
        我们通过PreparedStatement它的setXxx方法,来完成参数的传递
            传递参数时, 需要指定问号的索引, 问号的索引从1开始            

        例如:
            state.setString(1,username);
            state.setString(2,password);

    3. 执行语句:
            ResultSet result = state.executeQuery();</code></pre><h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><pre><code>填充预编译的参数: 
    * setXxx（问号索引,值）
        向预编译的SQL的?中传递值 
        参数1. 问号的索引,从1开始
        参数2. 填充到? 中的值

    * execute()
    * executeUpdate();
    * executeQuery();        </code></pre>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>thread基础</title>
    <url>/2020/04/06/thread%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><pre><code>1.线程
        高可用
        高性能
        高并发    
    分类：
        用户线程
        守护线程（Daemon）

2.多线程的使用场景
    多线程：多条路径完成任务，多任务的要求促进了多线程的产生

3.进程和线程
    进程: 操作系统的资源分配单元
    线程：CPU的调度器进行调度

4.线程创建的三种方式
    1.继承Thread类
        重写run方法
        使用start()方法调用    

    2.实现Runnable接口
        重写run方法
        使用new Thread().start()调用

    3.实现Callable接口
        重写call方法，实现高并发，call()可以抛出异常和返回值

5.代理模式
    静态代理：记录日志
        一个公共接口，两个角色
                    真实角色，代理角色 
                    代理角色内含有真实角色，管理真实角色，具体行为由真实角色产生

    在使用时，可以谁使用，来谁产生具体内容

6.Lambda表达式
    实现函数式编程        

    实现接口，内部使用方法体
    只能推导一个方法

    只需要关注方法的内容 （）-&gt; {方法体}
    含有一个参数 a -&gt; {方法体}
    单行代码 可以省略{}
    含有返回值

7.线程的状态
    新生 ：创建线程对象时

    就绪 ：调用start()方法，只有获得CPU控制权，才能运行，处于就绪队列
        1.start()
        2.释放阻塞
        3.yield 让出CPU控制
        4.JVM线程调度

    运行 ：获得CPU控制权，run()

    阻塞 ：线程不在往下执行
        1.sleep()：当前线程阻塞的毫秒数，sleep不会释放锁
        2.wait()
        3.join()
        4.I/O

    死亡 ：run()方法结束,线程被强制退出
            外部干涉

        yield() 由运行状态直接转到就绪状态 CPU重新调度线程
        join() 合并线程 先执行join()的线程 在执行顺序的线程


8.线程优先级
    priority 优先级高的线程执行概率更大，但优先级低的线程也有执行的机会,优先级并不代表执行的次序
    setPriority()设置线程的优先级 1 - 10，设置必须在线程启动之前
        NOME_PRIORITY    1
        MIN_PRIORITY    5
        MAX_PRIORITY    10

9.守护线程
    守护线程(Daemon)
        JVM必须完成用户线程，可以不用等待守护线程结束

    默认状态下所有的线程都是守护线程，使用方法setDaemon(true)设置成守护线程

10.其他方法
    isAlive()线程是否存活
    Thread.currentThread()当前线程
    setName()设置线程名称

11.线程同步
    synchronized
    保证数据的准确性，线程的执行次序,又称为并发控制 -&gt; 线程安全

    并发控制：同一个对象多个线程同时进行操作，对共享资源的使用 

    实现线程同步：队列和锁

    锁机制（synchronized）: 锁住对象的资源,锁定所有者
        synchronized方法：使用关键字synchornized控制对方法的访问，使用private限定方法对变量的访问，将所有的变量对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程被阻塞
        缺陷：将一个大的方法声明为synchronized方法，会导致性能的降低

        synchronized块：
            synchronized(obj){},obj称为同步监视器
                obj可以为任何对象，但是推荐使用共享资源作为同步监视器
                同步方法中可以不指定同步监视器，同步方法的同步监视器默认为this即对象本身，或class类即类的模子

            同步监视器的执行过程：
                第一个线程访问，锁定同步监视器，执行代码
                第二个线程访问，同步监视器被锁定，无法执行
                第一个线程访问结束，解锁同步监视器</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java-SE</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2020/03/18/git/</url>
    <content><![CDATA[<h2 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h2><p>​    1.什么是Git<br>​        一种源代码管理工具（版本控制工具），方便对代码的管理</p>
<pre><code>2.初始化Git仓库
    在放置代码的文件夹下，
    右键“git bash here”,输入命令&apos;git init&apos;,
    所有的文件放置在‘.git’文件夹下

3.配置身份信息
    声明当前的用户，“git config --global ”
    每次备份会将用户名和邮箱存储起来

    1.声明用户
        &apos;git config --global user.name &quot;用户名&quot;&apos;

    2.声明邮箱
        &apos;git config --global user.mail &quot;邮箱名&quot;&apos;
        邮箱不要求为现实邮箱，只要符合邮箱格式

4.将文件放置到Git
    自动将文件备份到隐藏文件夹‘.git’

    1.将代码添加到‘.git’仓库中（门口）
        &apos;git add &quot;文件路径名&quot;&apos;

    2.代码提交到‘.git’仓库中（房间）
        &apos;git commit -m “对文件的说明”&apos;
            -m message:必须要有文件说明

5.工作区 暂存区 版本库
    工作区：正在使用的文件夹
    暂存区：第一次添加的文件
    版本库：提交的源代码版本

6.查看当前状态
    &apos;git status&apos;
    文件是否放入版本库

7.批处理文件
    git add ./     :当前文件夹的所有修改过的内容放入暂存区
    git commit --all -m &quot;&quot;    :将所有的文件放入版本库

8.查看提交记录（日志）
    &apos;git log&apos; 显示提交的用户和时间
    简化提交日志
    &apos;git log --oneline&apos; :将日志简化为一条记录

9.恢复代码
    &apos;git reset --hard Head~0&apos;    ：回退到上次代码提交时的状态

10.根据版本号来进行回退
    &apos;git reset --hard &quot;版本号&quot;&apos;    ：将代码回退到某一次的提交时的状态

11.查看版本切换日志
    &apos;git reflog&apos;

12.创建分支，合并分支
    master:主分支

    1.创建分支
        &apos;git branch &quot;分支名&quot;&apos; 创建分支
        与master分支内容一样

    2.切换分支
        &apos;git checkout &quot;分支名&quot;&apos;    

    3.合并分支
        &apos;git merge &quot;分支名&quot;&apos;,当前分支与指定分支的合并

    4.查看分支
        &apos;git branch&apos;

13.手动合并分支
    合并后删除不需要的文件，再次将其进行提交

14.将代码提交到Github服务器上
    &apos;git push &quot;地址&quot; master&apos;
    exp:git push https://github.com/print3306/test007.git master

15.将代码从Github上下载
    &apos;git pull &quot;地址&quot; master&apos;
    exp:git pull https://github.com/print3306/test007.git master

    注意：在下载之前必须初始化一个仓库，pull会对数据进行合并

16.对数据的clone
    &apos;git clone &quot;地址&quot;&apos;
    远程仓库数据的复制，如果多次执行会覆盖本地内容

17.通过SSH来上传代码
    公钥和私钥：通过两者之间的联系验证身份
    生成公钥和私钥
        ssh-keygen -t rsa -C &quot;邮箱&quot;
        生成的公钥添加到Github的SSH上

18.本地和远程文件的版本不一样
    先将服务器上的数据下载下来，在本地修改，解决冲突后，再将最新版上传至服务器

19.简化push和pull
    增加远程变量，在当前的项目目录有效，变量代替地址
    git remote add &quot;变量名&quot; &quot;地址&quot;

    上传：git push &quot;变量名&quot; -u master
        本地当前分支和远程指定分支进行相关联,
        下一次只需要写上git push进行上传

    下载：git pull &quot;变量名&quot; -u master</code></pre>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL JDBC</title>
    <url>/2019/12/09/SQLjdbc/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>1. 基本概念
    Java DataBase Connectivity
    - java数据库连接，java操作数据库，使用同一套java代码操作不同的数据库
    - 本质：官方定义的操作所有关系型数据库的规则--接口，实现类由各个数据库厂商实现，提供数据库驱动jar包，我们可以使用这套接口（JDBC）编程，但真正执行的是驱动jar包中的实现类。

2. 快速入门
    * 步骤：
        1. 导入驱动jar包
        2. 注册驱动
        3. 获取数据库的连接对象 Connection
        4. 定义SQL语句
        5. 获取执行SQL语句的对象 Statement = connection.statement()
        6. 处理SQL语句,接受返回结果 statememt.executeQuery(sql)
        7. 处理结果
        8. 释放资源

    * 代码：
        `
        //2.注册驱动 加载字节码文件
           Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);

           //3.获取数据库连接对象
        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/books?serverTimezone=UTC&quot;,&quot;uesrname&quot;,&quot;password&quot;);

        //4.定义SQL语句
        String sql = &quot;select * from admin&quot;;

        //5.获取执行SQL的对象
        Statement statement = connection.createStatement();

        //6.执行SQL
        boolean flag = statement.execute(sql);

        //7.处理
        System.out.println(flag);

        //8.释放资源
        statement.close();
        connection.close();</code></pre><h2 id="对象详解"><a href="#对象详解" class="headerlink" title="对象详解"></a>对象详解</h2><pre><code>1. 详解各个对象
    1. DriverManager
        * 驱动管理对象
        * 功能：
            1. 注册驱动
                static void registerDriver(Driver driver):注册给定的驱动程序
                写代码：Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;)
                com.mysql.cj.jdbc.Driver,使用静态代码块，调用registerDriver方</code></pre><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        注册驱动:</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		 	<span class="keyword">try</span> &#123;</span><br><span class="line">  					DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">   				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">         &#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<pre><code>            PS：mysql5后的驱动jar包可以省略注册驱动的步骤

        2. 连接数据库
            * 方法：static Connection getConnection(String url, String user, String password)
            * 参数:
                * url:指定连接的路径
                    * 语法
                        jdbc:mysql://ip地址(域名)：端口号/数据库名称
                    * 例子
                        jdbc:mysql://localhost:3306/books?serverTimezone=UTC
                    * 细节
                        如果连接本机的mysql服务器，端口号3306，可以简写为jdbc:mysql:///数据库名称
                * user:
                    数据库用户名
                * password
                    密码

2. Connection
    * 数据库连接对象
    * 功能：
        1. 获取执行SQL的对象,包括预处理对象
            * Statement createStatement()
            * PreparedStatement preparedStatement()

        2. 管理事务
            * 开启事务
                void setAutoCommit(boolean autoCommit) :参数为false,开启事务
            * 提交事务
                commit()
            * 回滚事务
                rollback()

3. Statement
    * 执行SQL对象
    * 功能：
        1. 执行SQL语句
            * int executeUpdate(String sql):执行DML(增删改)语句，DDL语句，返回值：影响的行数，判断是否执行成功（&gt;0）
            * ResultSet executeQuery(String sql):执行查询语句

4. ResultSet
    * 结果集对象，封装查询结果
    * 功能：
        * boolean next():游标向前移动一行,并判断是否是最后一行，如果是，返回False
        * getType(参数)：获取数据,一次只能获取一列数据
            * Type：数据类型，int getInt()
            * 参数：
                1. int 列的编号，getInt(1)
                2. String 列名, getString(name)
        * 使用时：
            1. 游标向下移动
            2. 判断是否存在数据
            3. 获取数据
            代码：
                 while(resultSet.next()){
                    //获取数据
                 }

5. PreparedStatement
    * 执行SQL的对象
    * SQL注入问题：在拼接sql语句时，有一些特殊的关键字参于字符串的拼接，会造成安全性问题
        1. 输入用户随便，输入密码：a&apos;or&apos;a&apos;=&apos;a,条件恒为真，
        2. sql:select * from db where name and password,所有的用户名全都查询出来

    * 解决SQL注入问题：使用PreparedStatemmet类
    * 预编译SQL:参数使用 ？作为占位符
    * 步骤：
        1. 导入驱动jar包
        2. 注册驱动
        3. 获取数据库的连接对象 Connection
        4. 定义SQL语句
        5. 获取执行SQL语句的对象 PreparedStatement = connection.preparedStatement(sql)
            * 注意：sql使用?作为占位符， select * from user where name = ? and password = ?;
        6. 给？赋值
            * 方法：
            * setType(参数1，参数2)
            * 参数1：传递参数的位置
            * 参数2: 值
        7. 处理SQL语句,接受返回结果，prearedStatement.executeQuery()
        8. 处理结果
        9. 释放资源

    * 使用PreparedStatement对象
        * 防止SQL注入问题
        * 效率更高</code></pre><h2 id="抽取JDBC工具类"><a href="#抽取JDBC工具类" class="headerlink" title="抽取JDBC工具类"></a>抽取JDBC工具类</h2><pre><code>- JDBCUtils
* 目的：简化书写
* 分析：
    1. 获取连接
        * 不传递参数，并保证工具类的通用性
        * 解决：属性配置文件
            jdbc.properties
                url=...

            1. 创建Properties类
            Properties properties = new Properties();
            2. 加载properties文件
            properties.load(new FileReader(&quot;jdbc.properties&quot;));
            3. 获取配置
            url = properties.getProperty(&quot;url&quot;);
    2. 释放资源</code></pre><h2 id="登陆验证实例"><a href="#登陆验证实例" class="headerlink" title="登陆验证实例"></a>登陆验证实例</h2><pre><code>1. 需求
    * 通过键盘输入用户名和密码
    * 判断用户是否合法
        根据查询结果判断是否合法

2. 实现
    * 创建表，存储用户名和密码
        CREATE TABLE IF NOT EXISTS USER (
            id INT PRIMARY KEY AUTO_INCREMENT,
            NAME VARCHAR(32) NOT NULL,
            PASSWORD VARCHAR(32) NOT NULL
        )engine = innodb default charset = utf8;

    * 查询数据表，
        sql = &quot;select * from db where name = &apos;name&apos; and password = &apos;password&apos;&quot;
        如果存在数据，用户合法

3. 注意
    为了预防SQL注入，导致安全性问题，使用PreparedStatement类，使用预编译SQL,不使用静态拼接SQL,Statement类，效率更高而且更安全。</code></pre><h2 id="JDBC事务控制"><a href="#JDBC事务控制" class="headerlink" title="JDBC事务控制"></a>JDBC事务控制</h2><pre><code>1. 事务：一个包含多个步骤的业务操作，如果业务被事务管理，要么全部成功，要么全部失败

2. 操作
    1. 开启事务 
    2. 提交事务
    3. 回滚事务

3. 使用Connection管理事务
    * 开启事务
        void setAutoCommit(boolean autoCommit) :参数为false,开启事务
        执行sql语句之前开启事务
    * 提交事务
        commit()
        SQL执行完毕时提交
    * 回滚事务
        rollback
        try catch中进行回滚，一旦发现异常，将数据回滚</code></pre><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：
    * 容器（集合），存放数据库连接的一个容器
    * 系统初始化后，容器被创建，会申请一些连接对象，在用户访问数据库时，从容器中获取连接对象，使用完毕归还容器资源

2. 优点：
    * 节约资源：访问时直接获取，不用重复申请资源
    * 用户访问高效：拿来即用

3. 实现：
    1. 标准接口：
        DataSourse javax.sql
        * 方法:
            * 获取连接：getConnnection()
            * 归还连接：如果Connection是从连接池获取的，调用connection.close()方法，不是关闭连接，而时归还连接

    2. 实现技术，由数据库厂商提供
        * C3P0: 数据库连接池技术
        * Druid: 阿里德鲁伊连接池技术

4. C3P0连接池技术
    * 步骤：
        1. 导入jar包，jdbc驱动和c3p0包
        2. 定义配置文件：
            * 名称：c3p0.properties 或者 c3p0-config.xml
            * 路径：src目录下
        3. 创建数据库连接池核心数据对象：ComboPoolDataSourse
        4. 获取连接对象：getConnection()

5. Druid连接池技术
    * 步骤：
        1. 导入jar包：druid-v.jar
        2. 定义配置文件：
            * .properties形式
            * 可以叫任意名称，放在任意目录下
        3. 加载配置文件
            Properties properties = new Properties();
            InputStream is = DruidDemo08.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
            properties.load(is);
        3. 创建连接池对象，使用工厂类 DruidDataSourseFactory
        4. 获取连接对象

    * 定义工具类
        1. 定义工具类
        2. 提供静态代码块加载配置文件，初始化连接池对象
        3. 提供方法
            1. 获取连接方法，获取连接对象
            2. 释放资源
            3. 获取连接池对象</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装，提供了JDBCTemplate对象
* 步骤：
    1. 导入jar包
    2. 创建JDBCTemplate对象，依赖与数据源DataSourse
        JDBCTemplate template = new JDBCTemplate(ds)
    3. 调用方法完成CRUD的操作</code></pre>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL_JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql基础</title>
    <url>/2019/09/06/mysql%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h2><pre><code>1.不区分大小写，但建议关键字大写，列名，表名小写
2.每条命令最好以分号区分
3.每条命令可以根据需要分割
4.注释
    单行注释：#，-- （双下划线加上空格）
    多行注释：/* 多行注释 */</code></pre><h2 id="数据查询语言（DQL）"><a href="#数据查询语言（DQL）" class="headerlink" title="数据查询语言（DQL）"></a>数据查询语言（DQL）</h2><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><pre><code>1.基础语法
    select 查询列表 【as】【别名】
    from 表名;

    查询列表：
        表中的字段：
            查询表中的单个字段
                SELECT Tname FROM teacher;

            查询表中的多个字段
                SELECT Tno,Tname FROM teacher;

            查询表中所有字段
                SELECT * FROM teacher WHERE Depart=&apos;电子工程系&apos;;

    常量值
    表达式
    函数

2.别名：
    1.提高查询结果可读性
    2.如果要查询的字段有重名的情况

    SELECT Tno 编号,Tname 姓名
        FROM teacher;

        SELECT Tno AS 编号 
        FROM teacher ;

        案例，别名为 out put
        SELECT Tno AS &quot;out put&quot;
        FROM teacher;    

3.结果去重：
    关键字：distinct
    在列名前加上关键字DINTINCT，对查询结果去重

4.+号的作用：
    只有运算符的功能
    1.两个操作数都为数值型，做加法运算
    2.其中一方是字符型，则试图将字符型转换为数值型，如果转换成功，做加法运算，如果转换失败，字符型数据转换成0
    3.只要其中一方为NULL,结果就是NULL</code></pre><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><pre><code>1.基础语法
    select 查询列表
    from  表名
    where 筛选条件；

2.分类
    1.按照条件表达式进行筛选
        条件运算符：&gt; &lt; = != &lt;&gt;

    2.按照逻辑表达式进行筛选
        逻辑运算符：AND OR NOT

    3.模糊查询
        like:字符串匹配
            %：任意个字符均可匹配
            -：单个字符匹配通配符

            字符的转义：
                \ , ESCAPE &apos;转义标识&apos;;

        between and：
            结果包含临界值
            临界值的顺序不可调换

        in：集合中的元素查询

        is null：空值的查询
            安全等于：&lt;=&gt;,可以查询空值，也可以查询普通的值</code></pre><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><pre><code>1.基础语法
    select 查询列表
    from 表名
    where 筛选条件
    order by 列表 asc|desc；//数据默认按照ASC排序，升序    

2.排序的列表类型
    按照数值进行排序
        属性列的值
    按照表达式（表达式的别名）
        可以使用数据的计算
    按照函数排序    

    按照多个字段排序
        主要字段在前，次要字段在后，主要字段数值相同的按照次要字段的排序顺序排序。

3.特点
    asc按照升序排序，desc按照降序排序
    子句后支持单个字段，多个字段，表达式，函数，别名
    子句一般是放在查询语句的最后面，limit子句除外</code></pre><h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h3><pre><code>1.函数的概念
    类似Java中函数的方法，将一组逻辑语句封装在方法体中，只要调用方法名

2.函数的调用
    select 函数名（实参列表）【from 表名】；

3.函数的分类
    单行函数：
        concat,length,ifnull等
    多行函数
        sum,avg,min,max,count

4.函数：函数可以嵌套调用
    一.字符函数
    length(str):字的长度
    concat(str1,str2....):字符串的连接
    upper(),lower():字符的大小写
    substr(),substring():截取指定 【字符长度】的字符串，函数有多个重载
    instr(str,substr):字串在字符串的【第一次出现的位置索引】，找不到，返回0
    trim():去除字符串的【前后指定的字符】
    lpad(),rpad():使用指定字符【左|右】填充
    replace():替换字符

    二.数学函数
    round():四舍五入
    ceil(),floor():向上，下取整
    truncate():截断
    mod():求余

    三.日期函数
    now():当前的日期和时间
    curdate(),curtime():当前的日期，时间
    year(date),mouth(date),day(date):指定的年月日
    str_to_date(date_str,format):将指定的日期字符串转化成相应格式的日期
    date_format():格式化日期为字符串

    四.其他函数
    select database();当前的数据库

    五.流程控制函数
    if();相当于三元运算符
    case():1.相当于switch case函数,【判断具体的值】
                case 变量或表达式 
                when 常量1 then 语句1
                ...
                else 
                语句n 
                end
           2.相当于多重选择结构,【判断取值区间】
                case 
                when 常量1 then 语句1
                    ...
                else 语句n 
                end

    六.分组函数：null值不参与运算
     参数的类型：
        sum(),avg()，数值型，null值不参与运算
        max(),min(),可比较的数据类型均可使用，null值不参与运算
        count(),非空类型的数据，null值不参与运算

     与分组函数一同查询的字段：是group by后的函数</code></pre><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><pre><code>1.基础语法
    select 查询列表【cloumn】,【出现在group by之后】
    from 表名
    where 筛选条件
    group by 分组条件（表达式）having 【筛选，分组后的条件筛选】
    order by cloumn;

2.查询列表
    要求是分组函数和group by之后的列

3.筛选条件的使用
    在分组之前的筛选条件：
        原始表中有的字段，使用where子句

    在分组之后的筛选条件:
        分组后的结果集，使用having子句

    能使用分组前筛选的就使用分组前筛选，提高性能

4.group by子句的使用
    按照表达式或函数分组</code></pre><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><pre><code>1.笛卡儿积的基础上对条件进行筛选，选择出来对应的结果

sql92标准:
    1.语法    
        select 查询列表
        from 表1，表2...表n
        where 连接条件；

    2.等值连接
        多表连接的结果是多个表的交集部分
        n表连接，至少需要n-1个连接条件
        一般需要为表起别名
        可以搭配其他子句使用

    3.非等值连接
        连接条件不是等号

    4.自连接
        连接的表是自己，在连接时对表起别名

sql99标准
    1.语法
        select 查询列表
        from 表1 别名 【连接类型】
        join 表2 别名
        on 连接条件
        【where 筛选条件】
        【group by 分组条件】
        【order by 排序条件】；

    2.连接类型
        内连接：
            inner

        外连接:查询结果是主表的所有值，匹配，显示匹配的值；不匹配，显示null
            左外连接：left [outer]
            全外连接：full [outer]

        交叉连接：
            cross </code></pre><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><pre><code>1.定义
    出现在其他语句中的查询语句，称为子查询或内查询
    外部的查询语句，称为主查询或外查询

2.分类
    位置：
        select后面：
            只支持标量子查询

        from后面：
            支持表子查询,【相当于虚拟的表】

        where，having后面：【新的筛选条件】
            标量子查询（单行）：
                使用小括号括起来
                使用单行操作符，&lt; &gt; =

            列子查询（多行）：
                使用小括号括起来
                使用多行操作符
                    in any all

            行子查询
                筛选条件都是【=】连接条件

        exists（相关子查询，返回0或1，逻辑值）：与in 类似
            表子查询

    结果集的行列数不同：
        标量子查询（结果集只有一行一列）
        列子查询（结果集只有一列多行）
        行子查询（一行多列或多行多列）
        表子查询（一般多行多列）</code></pre><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><pre><code>要显示的数据一页显示不全，分页提交sql请求

1.语法
    select 查询列表
    from 表
    【join type 表2
    on 连接条件
    where 筛选条件
    group by 分组条件
    order by 排序的字段】
    limit 【offset,】size;

    offset：要显示条目的起始索引（从0开始）
    size：要显示的条目个数

2.特点
    limit语句在查询语句的最后

    分页查询的请求:
    公式：
        要显示的页数page，每页的条目数size

        select 查询列表
        from 表
        limit （page-1）* size,size;</code></pre><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><pre><code>1.基本语法
    union

2.联合查询的特点
    要求多条查询语句的查询列数一致
    要求多条查询语句的每一行的类型和顺序一致
    联合查询的结果默认去重，追加all显示所有的结果</code></pre><h2 id="数据操纵语言（DML）"><a href="#数据操纵语言（DML）" class="headerlink" title="数据操纵语言（DML）"></a>数据操纵语言（DML）</h2><h3 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h3><pre><code>1.基本语法
    方式一：
    insert into 表名（字段名，，，） 
    values (与字段数据对应);

    支持一次插入多行，批量操作
    支持子查询

    方式二：
    insert into 表名
    values 列名=值，列名=值....

2.特点
    - 插入的数据类型要与列的类型一致或兼容
    - 不可以为null的列必须有值
    - 列的顺序可以调换，值的信息匹配
    - 列数与插入数据的列数一致
    - 省略列名默认全体元素</code></pre><h3 id="修改语句"><a href="#修改语句" class="headerlink" title="修改语句"></a>修改语句</h3><pre><code>1.修改单表的记录
    update 表名
    set 列=值，列2=值，...
    where 筛选条件；

2.修改多表的记录
    sql92:
        update 表1 as 别名，表2 as 别名
        set 列=值
        where 连接条件
        and 筛选条件;

    sql99:
        update 表1 别名
        inner|outer join 表2 别名
        on 连接条件
        set 列=值,...
        where 筛选条件;</code></pre><h3 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a>删除语句</h3><pre><code>1.delete语句
    删除满足条件的行的所有值

    delete from 表名
    where 筛选条件;

    多表的删除：【cascade:级联删除】
        sql92:
        delete 别名【要删除的表名的别名】
        from 表1 别名,表2 别名
        where 连接条件
        and 筛选条件;

        sql99：
        delete 别名【要删除的表名的别名】
        from 表1 别名
        inner|outer join 表2 别名 
        on 连接条件
        where 筛选条件;

2.truncate关键字：【清空】
    删除整个表

    truncate table 表名;

3.delete与truncate的区别
    -delete可以加筛选条件

    -truncate的效率稍高

    -加入要删除的表中有自增长列：
    使用delete删除，插入新的数据，自增长列的值从断点开始
    使用truncate删除，插入新的数据，自增长列的值从1开始

    -truncate删除没有返回值，delete删除有返回值
    -truncate删除不能回滚，delete删除能回滚</code></pre><h2 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h2><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><pre><code>1.库的创建
    create database 库名；

    容错性处理:如果库存在不创建，否则创建库
        create database if not exists 库名;

2.库的修改
    1.更改数据字符集
    alter database 库名 character set ();

3.库的删除
    drop database if exists 库名；</code></pre><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><pre><code>1.表的创建
    语法：
        create table if not exists 表名（
            列名 列的类型 【（长度）约束】，
            列名 列的类型 【（长度）约束】，
            列名 列的类型 【（长度）约束】
        ）；

2.表的修改
    修改列名
        alter table 表名 change column 旧列名 新列名 列类型；

    修改列的类型或约束
        alter table 表名 modify column 列名 列类型；

    添加新列
        alter table 表名 add column 新列名 类型；

    删除列
        alter table 表名 drop column 列名；

    修改表名
        alter table 表名 rename to 新表名；

3.表的删除
    drop table 【if exists】表名；

4.表的复制
    复制表的结构与数据

    -仅复制表的结构
        create table 新表名 like 旧表名;

    -复制表的所有数据与结构
        create table 新表名 select * from 旧表名;

    -仅复制部分数据
         create table 新表名 select 列表 from 旧表名 where 条件;

    -仅复制部分结构
        create table 新表名 select 列表 from 旧表名 where 0;</code></pre><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><pre><code>1.视图的含义
    虚拟表，和普通表一样使用，通过表动态生成的数据。（临时表）
    只保存逻辑，不保存查询结果。        

2.视图的创建
    语法：
        create view 视图名
        as
        select 查询列表
        from 表名；

    使用：
        select 查询列表 from 视图名；（将结果集看成新表）

3.视图的修改
    1.方式一
        视图存在则修改，不存在则创建
        create or replace view 视图名
        as
        查询语句；

    2.方式二
        alter view 视图名
        as
        查询语句;

4.视图的查看和删除
    drop view 视图名1，视图名2...;

    视图的查看:
        desc 视图名；
        show cteate view 视图名;(在命令行下，显示创建视图的细节)

5.视图的更新
    更新视图的数据，则原始表的数据也会发生改变。

    1.插入数据
        insert into view_name values();

    2.更新数据
        update view_name set () ;

    3.删除数据
        delete from view_name ();

    具备以下关键字的SQL语句不允许更新
        &gt; 分组函数，distinct,group by,having,union
        &gt; 常量视图
        &gt; select有子查询
        &gt; join（查询数据在多个表中，连接查询）
        &gt; from一个不能更新的视图
        &gt; where子句的子查询引用了from子句中的表（相关子查询）

6.视图的用处
    提高sql语句的重用
    简化查询的sql操作
    保护数据，提高了安全性（只能看到自己操作的部分，看不到原始表）</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><pre><code>1.整型数据
       tinyint 9-255 (一个字节)
       smallint 0-65535 (两个字节)
       mediumint
       int，integer
       bigint </code></pre><p>​<br>​<br>        特点:<br>            -数据默认是有符号的，显式使用unsigned，数据是无符号的</p>
<pre><code>        -如果数据插入超出范围，报异常，插入元素是临界值

        -如果不设置长度，会有默认长度，长度表示的是显示的宽度，与数据的范围无关。（zerofill进行填充，填充后默认是有符号的数据）

2.小数
    浮点型：
        float(m,d)  (四个字节)
        double(m,d)  (八个字节)

    定点数:
        dec(m,d)
        decimal(m,d) 省略（m,d）默认m=10,d=0

        m:整数部分+小数部分的长度
        d:小数部分的长度

        插入数据超出，插入临界值


3.字符型
    较短的文本：
        char(m)    m-----&gt;0-255 定长 
        varchar(m) m-----&gt;0-65535 可变

        m：保存的字符数

    较长的文本:
        text
        blob(较大的二进制)

    enum:插入的值必须是枚举中的一个
        1-255，一个字节
        255-65535，两个字节 
        不区分大小写

    set:插入的数据是任意的数据集合

    特点:
        char比较耗费空间，但是效率较高，m可以省略，默认值为1
        varchar节省空间，效率比较低

4.日期型
    类型:
        date 4个字节 只表示日期

        datetime 8 

        timestamp 4 范围较小，反映时区</code></pre><h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><pre><code>1.约束：
    一种限制，保证表中的数据的准确性和可靠性

2.约束分类:
    not null:非空
        保证该字段的值不能为空

    default:默认
        保证该字段的值具有默认值

    primary key:主键
        该字段的值具有唯一性，非空

    unique：唯一
        该字段的值具有唯一性，可以空

    check：【mysql不支持】

    foreign key:外键
        限制两个表的关系，用于保证该字段的值必须来自主表的关联列的值
        在从表中加外键约束，用于引用主表的值

3.添加约束:在数据添加之前
    -创建表时
    -修改表时

4.约束的添加分类:
    表级约束：
        default not null除外，都支持            

    列级约束：
        都可以写，语法支持，但【外键约束】没有效果

5.创建表时添加约束
    添加列级约束：
        CREATE TABLE stuinfo(
            id INT PRIMARY KEY,#主键
            stuName VARCHAR(20) NOT NULL,#非空
            gender CHAR(1) CHECK(gender IN (&apos;男&apos;,&apos;女&apos;)),
            seat INT UNIQUE,#唯一
            sge INT DEFAULT 18#默认
        );

    添加表级约束:
        CREATE TABLE stuinfo(
            id INT,
            stuName VARCHAR(20),
            gender CHAR,
            seat INT,
            age INT,

            [CONSTRAINT pk] PRIMARY KEY(id),#主键
            [CONSTRAINT uq] UNIQUE(seat),#唯一
            [CONSTRAINT ck] CHECK(gender IN (&apos;男&apos;,&apos;女&apos;))
        );

    外键:fk_表名_主表名

6.主键与唯一的对比
    主键只能有一个为null，主键可以组合（多个属性列共同组成）
    唯一可以有多个null，可以组合

7.外键（on delete cascade级联删除on set null级联置空）
    -要求在从表中设置外键关系
    -从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求
    -主表的关联列必须是一个key(一般是主键或唯一)
    -插入时，要求先插入主表再插入从表；删除数据时，先删除从表，再删除主表

8.修改表时添加约束
    添加列级约束:
        modify column
    添加表级约束:
        add 

    alter table 表名 modify column 列名 类型；

9.修改表时删除约束

10.标识列
    又称为自增长列
    不用手动的插入值，系统提供默认的序列值

    &gt; 标识列不需要一定与主键对应，但是必须是key
    &gt; 一个表中至多只能有一个自增长列
    &gt; 标识列的类型只能是数值型的
    &gt; 标识列可以通过 set auto_increment_increment设置步长</code></pre><h2 id="事务控制语言（TCL）"><a href="#事务控制语言（TCL）" class="headerlink" title="事务控制语言（TCL）"></a>事务控制语言（TCL）</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><pre><code>1.定义
    一个或一组sql语句组成一个执行单元，这个执行单元要么全执行，要么全不执行。
    每个sql语句是相互依赖的

2.mysql中的存储引擎
    show engines;来查看支持的引擎

    innoDB 支持事务
    myisam memory 不支持事务

3.事务的ACID属性
    A（Atomicity）:原子性
        事务是一个不可分割的工作单位，要么全发生，要么都不发生

    C（Consistency）:一致性
        事务会使数据库的一致性状态变换到另一个一致性状态

    I（Isolation）:隔离性
        一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能相互干扰

    D（Durability）:持久性
        事务一旦提交，对数据库的数据改变就是永久性的，接下来的其他操作和故障不应该对其有任何影响

4.事务的创建
    隐式事务:
        insert update delete

    显式的事务:
        事务具有明显的开启和结束

        前提：
            先设置自动提交功能禁用
            set autocommit=0;

    1.开启事务
        set autocommit = 0;
        【start trancsaction;】

    2.书写语句
        sql语句

    3.结束事务
        commit;事务提交
        rollback；事务回滚

5.事务的并发处理（访问数据库中相应的数据）
    脏读：（数据未被提交就被访问）
        两个事务T1,t2,t1读取了已经被t2更新但是还【没有被提交】的字段，若t2回滚，t1读取的数据就是临时且无效的。

    不可重复读:（数据被读取后值发生改变）
        两个事务T1,t2,t1读取了一个字段，然后t2【更新】了数据，t1再次读取的同一字段，值改变了。

    幻读:
        两个事务T1,t2,t1读取了一个字段，然后t2在该表【插入】一些新的行，t1再次读取时，就会多出几行。

6.事务的隔离级别
    read uncommited:会出现脏读，幻读，不可重复读

    read commited:幻读，不可重复读

    repeatable read：不可重复读，mysql默认的隔离级别

    serializable：均能解决

        查看当前的隔离级别:            
            select @@tx_isolation;

        设置当前的隔离级别:
            set transaction isolation level [隔离级别];

        设置数据库的全局的隔离级别:
            set global transaction isolation level 级别;

7.回滚点的设置
    savepoint 节点名；
    rollback to 节点名;
        在回滚点之间的数据不发生改变</code></pre><h2 id="函数与控制过程"><a href="#函数与控制过程" class="headerlink" title="函数与控制过程"></a>函数与控制过程</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code>1.分类
    系统变量：
        全局变量：
            服务器每次使用将为所有的全局变量赋初值，针对于所有的会话，但不能跨重启

        会话变量：
            仅仅对于当前的会话（连接）有效

    自定义变量：
        用户变量：
            针对当前会话的变量，类似会话变量

        局部变量：
            仅仅在局部有效，在定义的begin end范围内

2.系统变量：
    变量是由系统提供的，属于服务器层面

    使用的语法：
        查看全局变量和会话变量：
            show global|session varibles;

        查看满足条件的部分系统变量：
            show global|session variables like &apos;% %&apos;;

        查看某个确定的系统变量:
            select @@global|session.系统变量名；

        变量赋值：
            set global|session 系统变量 = value;
            set @@global|session.系统变量 = value;

        Ps:session可以不写，不写默认是会话变量

3.自定义变量
    使用步骤：
        声明，赋值，使用

    用户变量：
        1.声明并初始化：
            set @用户变量名 = 值；
            set @用户变量名 ：= 值；
            select @用户变量名 ：=值；

        2.赋值：
            方式一：
            set 或 select
            set @用户变量名 = 值；
            set @用户变量名 ：= 值；
            select @用户变量名 ：=值；

            方式二：
            select 字段 into 变量 from 表名；

        3.使用
            select @用户变量名；

    局部变量：
        1.声明
            declare 变量名 类型；
            declare 变量名 类型 default 值；

        2.赋值
            set 局部变量名 = 值；
            set 局部变量名 ：= 值；
            select @局部变量名 := 值；

            select 字段 into 局部变量名 from 表名；

        3.使用
            select 局部变量名；

        4.使用位置
            必须是在begin end 内，是第一句话

    用户变量与局部变量的区别：
             作用域     定义和使用的位置        语法
    用户变量  当前会话      会话的任何位置        一般加@

    局部变量  begin end  只能在begin end      一般不加@,限定类型</code></pre><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><pre><code>1.含义
    一组与先编译好的sql语句的集合，理解成批处理语句

2.好处
    &gt; 提高代码的重用性
    &gt; 简化操作
    &gt; 减少了编译次数，减少了和服务器的连接次数，提高了效率

3.语法
    1.创建存储过程
        create procedure 存储过程名(参数列表)
        begin
            存储过程体
        end 

        注意：
            1.参数列表包含三个部分：
                参数模式 参数名 参数类型

                参数模式：
                    in :输入，调用方将参数传入
                    out ：输出，返回值
                    inout ：既可以传入又可以输出

            2.如果存储过程体只有一句sql语句，begin end可以不写

            3.存储过程体的每条语句必须加上分号，在结尾加上 delimiter 设置结束标志
                delimiter 结束标志 

    2.调用存储过程
        带in的存储过程调用：
            call 存储过程名(实参列表);

        带out的存储过程调用：
            【首先需要定义参数接收返回值，将变量进行赋值】
            call 存储过程名（@参数）；

        带inout参数的存储过程：
            传入变量

4.存储过程的删除
    drop procedure 存储过程名；

5.查看存储过程
    show create procedure 存储过程名；</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code>1.语法
    一组预先编译好的sql语句集合，理解成批处理语句

2.函数与存储过程的区别
    函数有且仅有一个返回值

    存储过程：批量插入，批量更新
    函数：数据处理后返回一个结果

3.函数的创建和调用语法
    创建：
        create function 函数名(参数列表) returns 返回类型
        begin
            函数体
        end 

    注意:
        &gt; 返回列表：参数名 参数类型
        &gt; 函数体。肯定会有return语句，如果没有会报错，如果return语句没有放在最后也不会报错
        &gt; 函数体中只有一句话，可以省略begin end
        &gt; 使用delimiter设置结束标记

    调用：
        select 函数名();

4.函数的查看
    show create function 函数名;

5.函数的删除
    drop function 函数名;</code></pre><h3 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h3><pre><code>&gt; 顺序结构：程序从上到下依次执行

&gt; 循环结构：在满足一定条件的基础上，重复执行一段代码

&gt; 分支结构：程序从两条或多条路径之间选择一条执行

1.分支结构
    1.if函数
        if(表达式1，表达式2，表达式3)；

        如果表达式1为真，执行表达式2，否则执行表达式3

    2.case函数
        1.类似于switch语句，实现等值判断
            case 表达式|字段|变量
            when 值1 then 返回值1或语句1；
            else 语句n；
            end case;

        2.类似于多重if分支，实现区间判断
            case 
            when 值1 then 返回值1或语句1;
            else 语句n;
            end case;

        特点：
            &gt; 可以作为表达式，嵌套使用，在任何地方
            &gt; 可以作为独立的语句，只能在begin end中
            &gt; 条件满足执行语句并返回，不满足，执行else中语句
            &gt; 没有else语句，返回null

    3.if结构
        实现多重分支

        语法：
            if 条件1 then 语句1;
            elseif 条件2 then 语句2;
            【else 语句n】;
            end if;

2.循环结构
    1.分类
        while,loop,repeat

    2.循环控制语句
        &gt; iterate:继续，结束本次循环，进行下一次
        &gt; leave:退出循环

    3.while语法
        【标签:】while 循环条件 do
            循环体；
        end while 【标签】;

    4.loop语法------&gt;模拟死循环
        【标签:】loop
            循环体
        end loop 【标签】；

    5.repeat语法
        【标签:】repeat
            循环体；
        until 结束条件；
        end repeat 【标签】；</code></pre>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>

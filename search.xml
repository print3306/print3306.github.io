<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQLjdbc</title>
    <url>/2020/05/02/SQLjdbc/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>1. 基本概念
    Java DataBase Connectivity
    - java数据库连接，java操作数据库，使用同一套java代码操作不同的数据库
    - 本质：官方定义的操作所有关系型数据库的规则--接口，实现类由各个数据库厂商实现，提供数据库驱动jar包，我们可以使用这套接口（JDBC）编程，但真正执行的是驱动jar包中的实现类。
        Person接口   Worker类  Person p = new Worker();    p.eat();

2. 快速入门
    * 步骤：
        1. 导入驱动jar包
        2. 注册驱动
        3. 获取数据库的连接对象 Connection
        4. 定义SQL语句
        5. 获取执行SQL语句的对象 Statement = connection.statement()
        6. 处理SQL语句,接受返回结果 statememt.executeQuery(sql)
        7. 处理结果
        8. 释放资源

    * 代码：
        `
        //2.注册驱动
           Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);

           //3.获取数据库连接对象
        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/books?serverTimezone=UTC&quot;,&quot;uesrname&quot;,&quot;password&quot;);

        //4.定义SQL语句
        String sql = &quot;select * from admin&quot;;

        //5.获取执行SQL的对象
        Statement statement = connection.createStatement();

        //6.执行SQL
        boolean flag = statement.execute(sql);

        //7.处理
        System.out.println(flag);

        //8.释放资源
        statement.close();
        connection.close();
        `</code></pre><h2 id="对象详解"><a href="#对象详解" class="headerlink" title="对象详解"></a>对象详解</h2><pre><code>1. 详解各个对象
    1. DriverManager
        * 驱动管理对象
        * 功能：
            1. 注册驱动
                static void registerDriver(Driver driver):注册给定的驱动程序
                写代码：Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;)
                com.mysql.cj.jdbc.Driver,使用静态代码块，调用registerDriver方</code></pre><blockquote>
<pre><code>注册驱动:
 static {
      try {
            DriverManager.registerDriver(new Driver());
     } catch (SQLException var1) {
         throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);
     }
     }</code></pre></blockquote>
<pre><code>            PS：mysql5后的驱动jar包可以省略注册驱动的步骤

        2. 连接数据库
            * 方法：static Connection getConnection(String url, String user, String password)
            * 参数:
                * url:指定连接的路径
                    * 语法
                        jdbc:mysql://ip地址(域名)：端口号/数据库名称
                    * 例子
                        jdbc:mysql://localhost:3306/books?serverTimezone=UTC
                    * 细节
                        如果连接本机的mysql服务器，而且端口号3306，可以简写为jdbc:mysql:///数据库名称
                * user:
                    数据库用户名
                * password
                    密码

2. Connection
    * 数据库连接对象
    * 功能：
        1. 获取执行SQL的对象
            * Statement createStatement()
            * PreparedStatement preparedStatement()

        2. 管理事务
            * 开启事务
                void setAutoCommit(boolean autoCommit) :参数为false,开启事务
            * 提交事务
                commit()
            * 回滚事务
                rollback()

3. Statement
    * 执行SQL对象
    * 功能：
        1. 执行SQL语句
            * int executeUpdate(String sql):执行DML(增删改)语句，DDL语句，返回值：影响的行数，判断是否执行成功（&gt;0）
            * ResultSet executeQuery(String sql):执行查询语句

4. ResultSet
    * 结果集对象，封装查询结果
    * 功能：
        * boolean next():游标向前移动一行,并判断是否是最后一行，如果是，返回False
        * getType(参数)：获取数据,一次只能获取一列数据
            * Type：数据类型，int getInt()
            * 参数：
                1. int 列的编号，getInt(1)
                2. String 列名,getString(name)
        * 使用时：
            1. 游标向下移动
            2. 判断是否存在数据
            3. 获取数据
            代码：
                 while(resultSet.next()){
                    //获取数据
                 }

5. PreparedStatement
    * 执行SQL的对象
    * SQL注入问题：在拼接sql语句时，有一些特殊的关键字参于字符串的拼接，会造成安全性问题
        1. 输入用户随便，输入密码：a&apos;or&apos;a&apos;=&apos;a,条件恒为真，
        2. sql:select * from db where name and password,所有的用户名全都查询出来

    * 解决SQL注入问题：使用PreparedStatemmet类
    * 预编译SQL:参数使用 ？作为占位符
    * 步骤：
        1. 导入驱动jar包
        2. 注册驱动
        3. 获取数据库的连接对象 Connection
        4. 定义SQL语句
        5. 获取执行SQL语句的对象 PreparedStatement = connection.preparedStatement(sql)
            * 注意：sql使用?作为占位符， select * from user where name = ? and password = ?;
        6. 给？赋值
            * 方法：
            * setType(参数1，参数2)
            * 参数1：传递参数的位置
            * 参数2: 值
        7. 处理SQL语句,接受返回结果，prearedStatement.executeQuery()
        8. 处理结果
        9. 释放资源

    * 使用PreparedStatement对象
        * 防止SQL注入问题
        * 效率更高</code></pre><h2 id="抽取JDBC工具类"><a href="#抽取JDBC工具类" class="headerlink" title="抽取JDBC工具类"></a>抽取JDBC工具类</h2><pre><code>- JDBCUtils
* 目的：简化书写
* 分析：
    1. 获取连接
        * 不传递参数，并保证工具类的通用性
        * 解决：配置文件
            jdbc.properties
                url=...

            1. 创建Properties类
            Properties properties = new Properties();
            2. 加载properties文件
            properties.load(new FileReader(&quot;jdbc.properties&quot;));
            3. 获取配置
            url = properties.getProperty(&quot;url&quot;);
    2. 释放资源</code></pre><h2 id="登陆验证实例"><a href="#登陆验证实例" class="headerlink" title="登陆验证实例"></a>登陆验证实例</h2><pre><code>1. 需求
    * 通过键盘输入用户名和密码
    * 判断用户是否合法
        根据查询结果判断是否合法

2. 实现
    * 创建表，存储用户名和密码
        CREATE TABLE IF NOT EXISTS USER (
            id INT PRIMARY KEY AUTO_INCREMENT,
            NAME VARCHAR(32) NOT NULL,
            PASSWORD VARCHAR(32) NOT NULL
        );

    * 查询数据表，
        sql = &quot;select * from db where name = &apos;name&apos; and password = &apos;password&apos;&quot;
        如果存在数据，用户合法

3. 注意
    为了预防SQL注入，导致安全性问题，使用PreparedStatement类，使用预编译SQL,不使用静态拼接SQL,Statement类，效率更高而且更安全。</code></pre><h2 id="JDBC事务控制"><a href="#JDBC事务控制" class="headerlink" title="JDBC事务控制"></a>JDBC事务控制</h2><pre><code>1. 事务：一个包含多个步骤的业务操作，如果业务被事务管理，要么全部成功，要么全部失败

2. 操作
    1. 开启事务
    2. 提交事务
    3. 回滚事务

3. 使用Connection管理事务
    * 开启事务
        void setAutoCommit(boolean autoCommit) :参数为false,开启事务
        执行sql语句之前开启事务
    * 提交事务
        commit()
        SQL执行完毕时提交
    * 回滚事务
        rollback
        try catch中进行回滚，一旦发现异常，将数据回滚</code></pre><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：
    * 容器（集合），存放数据库连接的一个容器
    * 系统初始化后，容器被创建，会申请一些连接对象，在用户访问数据库时，从容器中获取连接对象，使用完毕归还容器资源

2. 优点：
    * 节约资源：访问时直接获取，不用重复申请资源
    * 用户访问高效：拿来即用

3. 实现：
    1. 标准接口：
        DataSourse javax.sql
        * 方法:
            * 获取连接：getConnnection()
            * 归还连接：如果Connection是从连接池获取的，调用connection.close()方法，不是关闭连接，而时归还连接

    2. 实现技术，由数据库厂商提供
        * C3P0: 数据库连接池技术
        * Druid: 

4. C3P0连接池技术
    * 步骤：
        1. 导入jar包，jdbc驱动和c3p0包
        2. 定义配置文件：
            * 名称：c3p0.properties 或者 c3p0-config.xml
            * 路径：src目录下
        3. 创建数据库连接池核心数据对象：ComboPoolDataSourse
        4. 获取连接对象：getConnection()

5. Druid连接池技术
    * 步骤：
        1. 导入jar包：druid-v.jar
        2. 定义配置文件：
            * properties形式
            * 可以叫任意名称，放在任意目录下
        3. 加载配置文件
            Properties properties = new Properties();
            InputStream is = DruidDemo08.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
            properties.load(is);
        3. 创建连接池对象，使用工厂类 DruidDataSourseFactory
        4. 获取连接对象

    * 定义工具类
        1. 定义工具类
        2. 提供静态代码块加载配置文件，初始化连接池对象
        3. 提供方法
            1. 获取连接方法，获取连接对象
            2. 释放资源
            3. 获取连接池对象</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装，提供了JDBCTemplate对象
* 步骤：
    1. 导入jar包
    2. 创建JDBCTemplate对象，依赖与数据源DataSourse
        JDBCTemplate template = new JDBCTemplate(ds)
    3. 调用方法完成CRUD的操作</code></pre>]]></content>
  </entry>
  <entry>
    <title>SQL注入</title>
    <url>/2020/05/08/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="SQL注入问题"><a href="#SQL注入问题" class="headerlink" title="SQL注入问题"></a>SQL注入问题</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>在拼接sql语句时，有一些特殊的SQL关键字参于字符串的拼接，导致SQL语句的逻辑发生变化，可能会造成安全性问题</code></pre><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><pre><code>1. 输入 a&apos;or&apos;a&apos;=&apos;a,条件改变
2. sql:select * from db where name and password = &apos;a&apos;or&apos;a&apos;=&apos;a&apos;,查询所有数据

原SQL语句拼接为: 

    String sql = &quot;select id from db where username=&apos;&quot;+username+&quot;&apos; and password=&apos;&quot;+password+&quot;&apos;&quot;;

用户输入的帐号密码分别为:

请输入您的帐号:
11111
请输入您的密码:
a&apos;or&apos;a&apos;=&apos;a
组成的SQL语句: 
select id from db where username=&apos;1111&apos; and password=a&apos;or&apos;a&apos;=&apos;a；</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><pre><code>使用预编译SQL语句,进行参数的传递

更改执行环境：Statement

使用新的环境: PreparedStatement

在通过连接对象，获取一个预编译的SQL环境(PreparedStatement)时, 需要传递一个SQL语句 ! 
在这个语句中 可以出现? , ? 表示准备填充的参数值!

使用步骤: 
    1. 通过连接对象, 获得一个预编译的SQL执行环境

        PreparedStatement state = conn.prepareStatement(sql);

        例如: 
            String sql = &quot;select id from db where username=? and password=?&quot;;

            PreparedStatement state = conn.prepareStatement(sql);    

    2. 向预编译参数列表中传递值: 

        预编译的SQL语句中可以包含【多个问号】, 每一个问号表示一个需要传递的值 
        我们通过PreparedStatement它的setXxx方法,来完成参数的传递
            传递参数时, 需要指定问号的索引, 问号的索引从1开始            

        例如:
            state.setString(1,username);
            state.setString(2,password);

    3. 执行语句:
            ResultSet result = state.executeQuery();</code></pre><h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><pre><code>填充预编译的参数: 
    * setXxx（问号索引,值）
        向预编译的SQL的?中传递值 
        参数1. 问号的索引,从1开始
        参数2. 填充到? 中的值

    * execute()
    * executeUpdate();
    * executeQuery();        </code></pre>]]></content>
  </entry>
  <entry>
    <title>Spring下载</title>
    <url>/2020/05/09/SpringLoad/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code>在下载Spring时，碰到很多问题，在此记录下载流程，方便以后再次下载！</code></pre><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-搜索Spring官网-https-spring-io"><a href="#1-搜索Spring官网-https-spring-io" class="headerlink" title="1. 搜索Spring官网: https://spring.io/"></a>1. 搜索Spring官网: <a href="https://spring.io/" target="_blank" rel="noopener">https://spring.io/</a></h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_1.png" alt></p>
<h3 id="2-点击Projects"><a href="#2-点击Projects" class="headerlink" title="2. 点击Projects"></a>2. 点击Projects</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_2.png" alt></p>
<h3 id="3-点击Spring-Framework"><a href="#3-点击Spring-Framework" class="headerlink" title="3. 点击Spring Framework"></a>3. 点击Spring Framework</h3><h3 id="4-下拉界面，找到并点击-Spring-Framework-Artifacts"><a href="#4-下拉界面，找到并点击-Spring-Framework-Artifacts" class="headerlink" title="4. 下拉界面，找到并点击 Spring Framework Artifacts"></a>4. 下拉界面，找到并点击 Spring Framework Artifacts</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_3.png" alt></p>
<h3 id="5-找到并点击，http-repo-spring-io"><a href="#5-找到并点击，http-repo-spring-io" class="headerlink" title="5. 找到并点击，http://repo.spring.io"></a>5. 找到并点击，<a href="http://repo.spring.io" target="_blank" rel="noopener">http://repo.spring.io</a></h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_4.png" alt></p>
<h3 id="6-左边第二个图标，依次点击"><a href="#6-左边第二个图标，依次点击" class="headerlink" title="6.左边第二个图标，依次点击"></a>6.左边第二个图标，依次点击</h3><pre><code>libs-release-local ---&gt; org ---&gt; springframework ---&gt; spring</code></pre><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_5.png" alt><br><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_6.png" alt></p>
<h3 id="7-鼠标右键-Nature-Browser"><a href="#7-鼠标右键-Nature-Browser" class="headerlink" title="7.鼠标右键 Nature Browser"></a>7.鼠标右键 Nature Browser</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_7.png" alt></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/2020/05/15/mybatis/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><pre><code>1. 什么是框架（Framework）？
    系统中可重用的代码部分，包括一组构件以及构件之间的交互逻辑
    软件开发中的一种解决方案，不同的框架解决不同的问题
    框架封装了很多技术细节，使用者可以方便实现功能，提高开发效率

2. 三层架构
    * 表现层：
        展示数据
    * 业务层：
        处理业务需求
    * 持久层：
        数据库交互

3. 持久层技术解决问题和方案
    1. 问题
        数据库的连接和访问，数据查询效率，操作繁琐，不能将注意力聚焦到SQL处理上
        JDBC,Spring JDBCTemplate，传统的数据库连接方法，一组解决数据库连接的规范

    2. MyBatis概述
        * 基于Java的持久层框架
        * 内部封装了jdbc的细节,使用者只需要关注SQL语句，不用关心加载驱动，数据库连接，Statement对象等过程
        * 使用ORM(Object Relation Mapping)思想实现了结果集的封装
            PS: ORM
                数据库表和实体类以及实体类的属性对应起来，可以操作实体类实现操作数据表
                    user表        User类
                    id          userId</code></pre><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="1-MyBatis入门"><a href="#1-MyBatis入门" class="headerlink" title="1. MyBatis入门"></a>1. MyBatis入门</h2><pre><code>1. 环境搭建
    1. new --&gt; project --&gt; maven 设置名称，导入坐标pom.xml
    2. 创建实体类和Dao的接口:Dao(data access object 数据访问对象)
    3. 创建mybatis的主配置文件
        * SqlMapConfig.xml ：&lt;property &gt; 标签名称需要匹配，ps:username 不是 user
    4. 创建映射配置文件
        * UserDao.xml :&lt;mapper namespace=&quot;UserDao的路径&quot;&gt;

    注意事项：
        1. 创建UserDao.xml UserDao.java，mybatis中将持久层的操作接口名称和映射文件也叫做：Mapper
            UserDao 和 UserMapper相同
        2. 在idea创建目录时，和包的创建不同
            包在创建时，com.mybatis_base_01.dao 三层结构
            目录：com.mybatis_base_01.dao 一级目录
        3. 映射配置文件位置必须和dao接口的包结构相同
        4. 映射配置文件的mapper标签的namespace属性取值为dao接口的全限定类名
        5. 映射配置文件的操作设置，id取值必须时dao接口的方法名

        在实现3，4，5后，dao的实现类由mybatis实现

2. 使用案例
    1. 配置文件
        * InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
    2. 创建SqlSessionFactory对象
        * SqlSessionFacotryBulider builder = new SqlSessionFacotryBuilder();
        * SqlSessionFacotry facotry = builder.build(in);
    3. 创建SqlSession对象
        * SqlSession session = facotry.openSession();
    4. 创建UserDao代理对象
        * UserDao userDao = session.getMapper(UserDao.class);
    5. 使用UserDao代理对象执行操作
        * List&lt;User&gt; userDao = userDao.findAll();
    6. 释放资源
        * session.close();
        * in.close();

3. 简单分析
    1. 配置文件
        Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); 
        * 使用类加载器，只能读取类路径的配置文件
        * 使用ServletContext对象的getRealPath()

    2. 创建SqlSessionFactory工厂
        * 使用了创建者模式：SqlSessionFacotryBuilder builder 构造者 builder.build(in) 建立工厂
        * 使用了工厂模式：SqlSessionFactory 降低类之间的依赖关系

    3. 创建SqlSeccion对象
    4. 创建接口实现类

4. 使用注解开发MyBatis
    1. 将UserDao.xml移除，在Dao接口的方法上使用@Select()注解，并且指定sql语句
    2. 在SqlMapConfig.xml中的Mapper配置时，使用class属性指定Dao接口的全限定类名

5. 自定义MyBatis分析
    Mybatis在使用代理Dao对象实现增删改查做了什么事？
        1. 创建代理对象
        2. 调用selectList()方法</code></pre><blockquote>
<pre><code>&lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis_test&quot;/&gt;
&lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
&lt;property name=&quot;password&quot; value=&quot;root2019&quot;/&gt;</code></pre></blockquote>
<pre><code>连接数据库的语句，可以产生Connnection对象</code></pre><blockquote>
<mappers>
<mapper resource="com/mybatis_base_03/dao/UserDao.xml">
</mapper></mappers>
</blockquote>
<blockquote>
<pre><code>&lt;mapper namespace=&quot;com.mybatis_base_03.dao.UserDao&quot;&gt; 
&lt;!--配置查询所有--&gt;
&lt;select id=&quot;findAll&quot; resultType=&quot;com.mybatis_base_03.domain.User&quot;&gt;
   select * from user
&lt;/select&gt;</code></pre></blockquote>
<pre><code>映射配置信息 -&gt; 全限定类名，以及执行的SQL语句。
解析.xml配置文件 -&gt; 有了上面的三个信息
    1. 根据配置数据库的语句，可以创建Connection对象
        注册驱动，创建连接对象
    2. 获取预处理对象PreparedStatement
        获取SQL语句
    3. 对结果进行封装
        根据实体类的全限定类名</code></pre><h3 id><a href="#" class="headerlink" title></a></h3><pre><code>6.自定义MyBatis中涉及的实体类和接口
    1. class Resources
    2. class SqlSessionBuilder
    3. interface SqlSessionfacotry
    4. interface SqlSession
    这个过程完成了两件事：
        创建接口代理对象，
        实现查询语句

MyBatis将JDBC的功能进行封装，形成功能调用。SqlMapConfig.xml,daoInterfaceClass.xml里面包含对数据库的连接与查询的语句以及返回的结果类型。

SqlMapConfig.xml中的&lt;property&gt;标签包含数据库的连接对象，&lt;mappers/mapper&gt;包含接口的文件位置。
daoInterfaceClass.xml包含数据库语句，返回数据类的全限定类名，以及方法的namespace(根据查查询语句以及namespace确定方法的唯一性)。

根据这两个配置文件，可以通过对.xml文件的解析，获取相应的配置文件信息，由此构建代理对象，g根据返回数据的类型获取数据，实现整个的查询过程。</code></pre><h2 id="MyBatis的CRUD"><a href="#MyBatis的CRUD" class="headerlink" title="MyBatis的CRUD"></a>MyBatis的CRUD</h2><h3 id="MyBatis的配置文件"><a href="#MyBatis的配置文件" class="headerlink" title="MyBatis的配置文件"></a>MyBatis的配置文件</h3><pre><code>1. pom.xml的配置信息
    * 坐标的导入
        1.mybatis的坐标导入
        2.mysql的驱动坐标导入
        3.log4j的坐标导入
            log4j.properties配置文件放在资源目录下
        4.junit单元测试的坐标导入

2. SqlMapConfig.xml的配置
    1. &lt;environments&gt;:配置数据库
        1. 数据库连接
        2. 数据库的事务类型
        3. 数据库的数据源
        4. 数据库的连接（driver url username password）</code></pre><blockquote>
<pre><code>&lt;!--配置环境--&gt;
&lt;environments default=&quot;mysql&quot;&gt;
 &lt;!--配置mysql的环境--&gt;
 &lt;environment id=&quot;mysql&quot;&gt;
  &lt;!--配置事务--&gt;
  &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
  &lt;!--配置连接池--&gt;
  &lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;!--mysql的连接信息--&gt;
    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis_test&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root2019&quot;/&gt;
  &lt;/dataSource&gt;
 &lt;/environment&gt;
&lt;/environments&gt;</code></pre></blockquote>
<pre><code>2. &lt;mappers&gt;:配置dao的数据接口
    1. recource:表示配置方式为.xml
    2. class:表示配置方式为注解
    &lt;!--配置映射文件的位置--&gt;</code></pre><blockquote>
<pre><code>&lt;mappers&gt;
    &lt;mapper resource=&quot;com/mybatis_base_04_crud/dao/IUserDao.xml&quot;&gt;&lt;/mapper&gt;
  &lt;/mappers&gt;</code></pre></blockquote>
<pre><code>3. DaoInterface.xml
    1.&lt;mapper&gt;中的namespase 与 &lt;select&gt;中的id构成方法的唯一标识
    2.&lt;select&gt;中的文本内容为要执行的语句
    3.&lt;select&gt;中的 resultType 返回值类型</code></pre><blockquote>
<pre><code>&lt;!--namespace 接口--&gt;
&lt;mapper namespace=&quot;com.mybatis_base_04_crud.dao.IUserDao&quot;&gt;

 &lt;select id=&quot;finaAll&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
       select * from user
  &lt;/select&gt;
&lt;/mapper&gt;</code></pre></blockquote>
<h3 id="MyBatis的数据操作"><a href="#MyBatis的数据操作" class="headerlink" title="MyBatis的数据操作"></a>MyBatis的数据操作</h3><h4 id="保存数据-Insert"><a href="#保存数据-Insert" class="headerlink" title="保存数据(Insert)"></a>保存数据(Insert)</h4><pre><code>1. Dao接口的方法
    在IUserDao.java中添加saveUser方法
2. daoInterace.xml中的配置
    在&lt;mapper&gt;中增加&lt;insert&gt;标签，选择参数化类型，对于数据填充，采用#{}方式</code></pre><blockquote>
<pre><code>&lt;!-- 保存用户 --&gt;
  &lt;!--参数类型 parameterType--&gt;
  &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
        insert into user(username,address,sex,birthday) value(#{username},#{address},#{sex},#{birthday})
 &lt;/insert&gt;
实体类的属性定义与数据库中的列名一致,setter和getter方法自动生成，可以直接使用属性名称来传递参数，否则可以使用.getUsername()来传递参数。    </code></pre></blockquote>
<pre><code>3. 调用方法
    在生成数据库的代理对象后，直接调用save方法就可以        

4. 注意事项
    在使用方法后，需要对数据进行提交，默认自动提交关闭，需要手动打开自动提交
    session.commit();</code></pre><h5 id="保存数据的同时返回id"><a href="#保存数据的同时返回id" class="headerlink" title="保存数据的同时返回id"></a>保存数据的同时返回id</h5><pre><code>1.daoInterface.xml
    在原本的&lt;insert&gt;标签内，增加&lt;selectKey&gt;标签</code></pre><blockquote>
<pre><code>&lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;
  select last_insert_id();
&lt;/selectKey&gt;
在执行结束之后，会将id返回到user的id属性之中
keyProperty=&quot;id&quot; 实体类的属性
keyColumn=&quot;id&quot; 数据表中的列名</code></pre></blockquote>
<h4 id="更新数据-Update"><a href="#更新数据-Update" class="headerlink" title="更新数据(Update)"></a>更新数据(Update)</h4><pre><code>1. Dao接口的方法
    void saveUser(User user);
2. daoInterace.xml</code></pre><blockquote>
<pre><code>&lt;!-- 更新 --&gt;
  &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
    update user set username = #{username},address=#{address},sex=#{sex},birthday=#{birthday} where id=#{id}
  &lt;/update&gt;</code></pre></blockquote>
<h4 id="删除数据-Delete"><a href="#删除数据-Delete" class="headerlink" title="删除数据(Delete)"></a>删除数据(Delete)</h4><pre><code>1. Dao接口的方法
    void deleteUser(Integer userId);
2. daoInterface.xml</code></pre><blockquote>
<pre><code>&lt;!-- 删除数据 --&gt;
  &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
    delete from user where id=#{uid}
  &lt;/delete&gt;</code></pre></blockquote>
<pre><code>3. 注意事项
    删除数据中只有一个元素，#{}中的元素只是起到一个占位符的作用，与名称无关</code></pre><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><h5 id="根据用户id"><a href="#根据用户id" class="headerlink" title="根据用户id"></a>根据用户id</h5><pre><code>1. dao接口的方法
    User finaById(Integer id);
2. daoInterface.xml
    需要传入参数，以及返回值类型</code></pre><blockquote>
<pre><code>   &lt;!-- 根据id查询一个 --&gt;
&lt;select id=&quot;findById&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
   select * from user where id=#{id}
&lt;/select&gt;</code></pre></blockquote>
<h5 id="根据用户name"><a href="#根据用户name" class="headerlink" title="根据用户name"></a>根据用户name</h5><pre><code>1. dao接口的方法
    List&lt;User&gt; findByName(String name);
2. daoInterface.xml</code></pre><blockquote>
<pre><code>&lt;!-- 根据名称模糊查询 --&gt;
&lt;select id=&quot;findByName&quot; parameterType=&quot;string&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
 select * from user where username like #{name}</code></pre>  
</blockquote>
<pre><code>3. 注意事项
    &apos;#{}中没有模糊查询的 “-” “%” 在调用传参数时，需要给出“%王%”,查询语句为预处理SQL语句
    &apos;%${value}%&apos;,参数为“王”，查询语句为拼接字符串</code></pre><h3 id="MyBatis中的参数-parameterType"><a href="#MyBatis中的参数-parameterType" class="headerlink" title="MyBatis中的参数(parameterType)"></a>MyBatis中的参数(parameterType)</h3><h4 id="参数的类型-parameterType"><a href="#参数的类型-parameterType" class="headerlink" title="参数的类型(parameterType)"></a>参数的类型(parameterType)</h4><pre><code>1. 简单数据类型
    int String ...

2. 传递pojo对象
    pojo对象：
        POJO简单理解为不包含业务逻辑的单纯用来存储数据的java类（实际就是普通JavaBean)

    OGNL表达式：</code></pre><p><em>Object Graphic Navigation Language</em><br>        (对象图形导航语言)</p>
<pre><code>    通过对象的取值方法来获取数据，在写法上，将get给忽略了
    比如：获取用户的名称
        类中的写法：user.getUsername()
        OGNL表达式：user.username()
    mybatis中可以直接使用username,不用书写user.
        因为在parameterType中已经提供属性所在的类

3. 传递pojo包装对象
    参数为被封装的数据，查询条件是综合的查询条件</code></pre><blockquote>
<pre><code>&lt;!-- 根据queryVo查询数据 --&gt;
&lt;select id=&quot;findByQueryVo&quot; parameterType=&quot;com.mybatis_base_04_crud.domain.QueryVo&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
  select * from user where username like #{user.username}
&lt;/select&gt;</code></pre></blockquote>
<pre><code>QueryVo内部封装user对象，在参数传递时#{}，中的参数为 QueryVo.user.username,可以写为 user.username,代表参数为QueryVo中数据对象user中的属性username</code></pre><h4 id="结果集的封装-resultType"><a href="#结果集的封装-resultType" class="headerlink" title="结果集的封装(resultType)"></a>结果集的封装(resultType)</h4><pre><code>实体类的属性名与数据库的列名不相同？
    1. 给数据库中的列名起别名
        将所有查询的数据字段的名称别名改为实体类对应的属性名称
        书写更为复杂，但是查询到的数据在数据库端被处理，效率更高
    select id as uesrId,username as userName, address as userAddress, sex as userSex,birthday as userBirthday from user;

    2. 使用resultMap进行字段对应</code></pre><blockquote>
<pre><code>&lt;!-- 配置 查询结果的列名和属性名一致 --&gt;
&lt;resultMap id=&quot;userMap&quot; type=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
    &lt;!-- 主键字段的一致 --&gt;
    &lt;id property=&quot;userId&quot; column=&quot;id&quot;/&gt;
    &lt;!-- 非主键字段的一致 --&gt;
    &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
    &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt;
    &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;
    &lt;result property=&quot;userBirthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;
&lt;/resultMap&gt;

&lt;!--select id as uesrId,username as userName, address as userAddress, sex as userSex,birthday as userBirthday from user;--&gt;
&lt;select id=&quot;finaAll&quot; resultMap=&quot;userMap&quot;&gt;
    select * from user;
&lt;/select&gt;</code></pre></blockquote>
<pre><code>resultMap中的id为映射标记，返回值必须更改为resultMap=&quot;userMap&quot;，进行绑定
id 数据库中的主键字段数据绑定
result 非主键字段的数据绑定
property 实体类中的属性名称
column 数据库中的字段名称

    3. 两种方法的不同    
        直接使用别名，运行效率更高，但编写效率较低
        使用resultMap，运行效率低，但是编写效率高</code></pre><h3 id="MyBatis实现DAO开发"><a href="#MyBatis实现DAO开发" class="headerlink" title="MyBatis实现DAO开发"></a>MyBatis实现DAO开发</h3><h4 id="使用Dao的实现类"><a href="#使用Dao的实现类" class="headerlink" title="使用Dao的实现类"></a>使用Dao的实现类</h4><pre><code>1. 创建IUserDaoImpl.java
2. 在实现类中实现方法
    创建Sqlsession对象，在方法中调用相应的查询语句</code></pre><blockquote>
<pre><code>@Override
public List&lt;UserfinaAll() {
    //生成SqlSession对象
    SqlSession session = factory.openSession();
    //调用session的selectList方法，实现查询列表
    List&lt;Userusers = session.selectList(&quot;com.mybatis_base_04_DAO.dao.IUserDao.finaAll&quot;);
    //方法中的参数 能获取到信息的key namespace + methodName
    //释放资源
    session.close();
    return users;
}    </code></pre></blockquote>
<pre><code>* MyBatis实际上使用代理Dao的方式，将创建Dao实现类的过程给隐藏，用户无法感知到创建Dao实现类的过程。
* 自己使用Dao实现类实际上就是创建SqlSession对象，通过调用session.selectList()方法查询数据。
* 方法中的参数：（namaspace+methodName , 外部传入的参数）</code></pre><h3 id="执行过程分析"><a href="#执行过程分析" class="headerlink" title="执行过程分析"></a>执行过程分析</h3><h4 id="dao实现类的执行过程分析"><a href="#dao实现类的执行过程分析" class="headerlink" title="dao实现类的执行过程分析"></a>dao实现类的执行过程分析</h4><pre><code>1. selectList


2. insert update delete
    insert update delete最终调用的都是update方法

3. selectOne
    selectOne内部调用selectList方法，返回值为列表的第一个元素</code></pre><h4 id="代理Dao实现类的执行过程分析"><a href="#代理Dao实现类的执行过程分析" class="headerlink" title="代理Dao实现类的执行过程分析"></a>代理Dao实现类的执行过程分析</h4><h3 id="SqlMapConfig-xml中的标签属性"><a href="#SqlMapConfig-xml中的标签属性" class="headerlink" title="SqlMapConfig.xml中的标签属性"></a>SqlMapConfig.xml中的标签属性</h3><pre><code>1. &lt;properties&gt;标签
    * 配置properties 可以在标签内部配置数据库的连接信息，也可以引用外部配置文件信息
    * 使用&lt;properties&gt;标签，在环境的数据源中的对应数据使用 ${名称} 可以引用

    resource属性：
          用于指定配置文件的位置，按照类路径的写法来写，必须存放于类路径下

    url属性：
          要求按照url的写法来书写地址
          url Uniform Resource Locator 统一资源定位符
          写法：
            http://localhost:8080/mybatisserver/demo1Serelet
            协议 主机 端口 URI
           URI Uniform Resource Identifier 统一资源标识符 应用中唯一定位的资源</code></pre><blockquote>
<pre><code>&lt;properties url=&quot;file:///D:/2017217796/java_program/MyCode/mybatis_base_04_crud/src/main/resources/jdbcConfig.properties&quot;&gt;

&lt;/properties&gt;

&lt;!--mysql的连接信息--&gt;
&lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
&lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
&lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
&lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;        </code></pre></blockquote>
<pre><code>2. &lt;typeAliases&gt;标签
    1). &lt;typeAlias&gt;标签
        * typeAlias配置别名，只能配置domain中的实体类
        * type指定全限定属性名 alias指定别名 不在区分大小写</code></pre><blockquote>
<pre><code>&lt;typeAlias type=&quot;com.mybatis_base_04_crud.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;</code></pre></blockquote>
<pre><code>2). &lt;package&gt;标签
    * 用于指定要配置别名的包，当指定后，该包中的所有实体类都会被注册别名，且类名就是别名，不再区分大小写</code></pre><blockquote>
<pre><code>&lt;package name=&quot;com.mybatis_base_04_crud.domain&quot;/&gt;</code></pre></blockquote>
<pre><code>3. &lt;mappers&gt;标签
    * package指定接口所在的包，一但指定，就不需要写resource和class以及mapper</code></pre><blockquote>
<pre><code>&lt;package name=&quot;com.mybatis_base_04_crud.dao&quot;/&gt;</code></pre></blockquote>
<h2 id="MyBatis的连接池"><a href="#MyBatis的连接池" class="headerlink" title="MyBatis的连接池"></a>MyBatis的连接池</h2><h3 id="连接池的使用与分析"><a href="#连接池的使用与分析" class="headerlink" title="连接池的使用与分析"></a>连接池的使用与分析</h3><h4 id="连接池的含义"><a href="#连接池的含义" class="headerlink" title="连接池的含义"></a>连接池的含义</h4><pre><code>连接池是用于存储连接的一个容器
容器其实就是一个集合对象，该集合必须是线程安全的，不能两个线程拿到同一个连接
该集合必须实现队列的特性：先进先出

使用连接池可以减少获取连接的时间</code></pre><h4 id="MyBatis的连接池-1"><a href="#MyBatis的连接池-1" class="headerlink" title="MyBatis的连接池"></a>MyBatis的连接池</h4><pre><code>1. SqlMqpConfig.xml中的datasource标签，type属性表示使用何种连接池方式
    type的取值：
        POOLED : 采用传统的javax.sql.DataSource规范的连接池
        UNPOOLED ：采用传统的获取连接的方式，虽然也实现了javax.sql.DataSource接口，但是没有池的概念，每次使用都获取新的连接
        JNDI ：采用服务器提供的JNDI实现，获取DataSource对象，不同的服务器拿到的对象不一样，如果不是web或者maven的war工程，不能使用
        使用tomcat服务器，使用的连接池dbcp连接池</code></pre><blockquote>
<pre><code>&lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;!--mysql的连接信息--&gt;
    &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
&lt;/dataSource&gt;</code></pre></blockquote>
<p><img src="/2020/05/15/mybatis/datasource_0.png" alt="POOLED"><br><img src="/2020/05/15/mybatis/pooled_datasource_1.png" alt="POOLED"><br><img src="/2020/05/15/mybatis/pooled_datasource_2.png" alt="POOLED"></p>
<h4 id="补充JNDI数据库连接池"><a href="#补充JNDI数据库连接池" class="headerlink" title="补充JNDI数据库连接池"></a>补充JNDI数据库连接池</h4><h4 id="MyBatis中的事务"><a href="#MyBatis中的事务" class="headerlink" title="MyBatis中的事务"></a>MyBatis中的事务</h4><pre><code>1. MyBatis通过commit以及rollback来进行事务控制
2. 一般不设置自动提交，因为一旦多个事务提交，难以控制</code></pre><h2 id="MyBatis基于XML配置的动态SQL语句使用"><a href="#MyBatis基于XML配置的动态SQL语句使用" class="headerlink" title="MyBatis基于XML配置的动态SQL语句使用"></a>MyBatis基于XML配置的动态SQL语句使用</h2><h4 id="if-标签"><a href="#if-标签" class="headerlink" title="if 标签"></a>if 标签</h4><pre><code>* 根据条件来进行查询，此时条件可能不全，有可能缺少某些项，会根据条件具体生成查询语句
SQL语句中的名称不区分大小写，但是查询条件需要根据实体类相关，一般来说实体类的属性名与数据库的列名相同。</code></pre><blockquote>
<pre><code>&lt;!-- 根据条件查询 --&gt;
&lt;select id=&quot;findUserByCondition&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;
 select * from user where 1=1
 &lt;if test=&quot;userName != null&quot;&gt;
   and username like #{userName}
 &lt;/if&gt;</code></pre>   
</blockquote>
<pre><code>* test：判断输入的条件，如果条件满足，查询条件会包含if标签内部的语句
* 可以多个if标签一起使用
* 条件同时满足的时候使用 and ，可以在数据库语句中使用</code></pre><h4 id="where标签"><a href="#where标签" class="headerlink" title="where标签"></a>where标签</h4><pre><code>* 使用where标签将if标签包裹起来，在查询条件中就不用书写 where 1 = 1</code></pre><blockquote>
<pre><code>  &lt;!-- 根据条件查询 --&gt;
&lt;select id=&quot;findUserByCondition&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;
select * from user
&lt;where&gt;
  &lt;if test=&quot;userName != null&quot;&gt;
    and username like #{userName}
  &lt;/if&gt;
  &lt;if test=&quot;userSex != null&quot;&gt;
    and sex = #{userSex}
  &lt;/if&gt;
&lt;/where&gt;</code></pre>  
</blockquote>
<h4 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h4><blockquote>
<pre><code>&lt;!-- 根据QueryVo中的ids进行查询，集合尽心查询列表 --&gt;
&lt;select id=&quot;findUserInIds&quot; parameterType=&quot;queryvo&quot; resultMap=&quot;userMap&quot;&gt;
select * from user
&lt;where&gt;
  &lt;if test=&quot;ids != null and ids.size() 0&quot;&gt;
    &lt;foreach collection=&quot;ids&quot; open=&quot;and id in (&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;
      #{id}
    &lt;/foreach&gt;
  &lt;/if&gt;
&lt;/where&gt;</code></pre>  
</blockquote>
<pre><code>* 查询满足条件的集合元素:select * from user where id in (?)
* foreach:
* collection:代表要遍历的集合元素
* open:语句的开始部分
* close:语句的结束部分
* item:遍历的每个元素，生成的变量名
* separtor:分割符

其中&lt;foreach&gt;中的语句 #{}中的名称，需要与item一致

在进行多个数据一起插入的时候，可以使用foreach进行 values()的赋值</code></pre><h4 id="sql标签"><a href="#sql标签" class="headerlink" title="sql标签"></a>sql标签</h4><pre><code>* 抽取重复的SQL语句，避免重复书写语句
* 然后在语句中使用&lt;include&gt;来引用抽取的语句
* 如果后面还有需要拼接的条件，不能 书写分号</code></pre><blockquote>
<pre><code>&lt;!-- 抽取重复的语句 --&gt;
&lt;sql id=&quot;defaultUser&quot;&gt;
  select * from user
&lt;/sql&gt;

&lt;!--select id as uesrId,username as userName, address as userAddress, sex as userSex,birthday as userBirthday from user;--&gt;
&lt;select id=&quot;finaAll&quot; resultMap=&quot;userMap&quot;&gt;
  &lt;include refid=&quot;defaultUser&quot;&gt;&lt;/include&gt;
&lt;/select&gt;</code></pre></blockquote>
<h2 id="Mybatis的多表操作"><a href="#Mybatis的多表操作" class="headerlink" title="Mybatis的多表操作"></a>Mybatis的多表操作</h2><pre><code>表之间的关系：
    一对一
    多对一
    一对多
    多对多

举例：
    用户对于订单：一对多
    订单对于用户：多对一
        一个用户可能有多个订单
        多个订单属于一个用户

    一对一：
        一个人只能有一身份证号
        一个身份证号属于一个人

    多对多：
        一个学生被多个老师交过
        一个老师交过多个学生

在MyBatis中，认为订单与用户之间的关系，每拿出一个订单，只能属于一个用户
所以，所有的多对一，全都为一对一

案例：
    使用用户与账户之间的关系
        一个用户可以有多个账户
        一个账户只能属于一个用户(多个账户也是一个用户)

步骤：
    1. 建立两张表：用户表 账户表
        用户与账户具有关系：使用外键
    2. 建立两个实体类：用户实体 账户实体
    3. 建立两个配置文件
        用户配置文件
        账户配置文件
    4. 实现配置
        当查询用户时，可以出现账户信息
        查询账户时，可以显示出对应的用户信息</code></pre><h3 id="一对一查询的结果封装《association》"><a href="#一对一查询的结果封装《association》" class="headerlink" title="一对一查询的结果封装《association》"></a>一对一查询的结果封装《association》</h3><pre><code>1. 通过书写子类来进行配置查询
    * 建立新的结果集的封装类，将查询到的结果进行封装
    * 每次查询不同的数据需要书写不同的字类，太过于麻烦

2. 建立实体类之间的关系来进行数据封装
    * 主表与从表之间存在联系，主表实体和从表实体之间也存在联系
    * 从表包含主表实体的引用
    * 据此，创建resultMap，进行结果封装
    * 使用 association 进行一对一的结果封装</code></pre><blockquote>
<pre><code> &lt;!-- 定义封装account和user的resultMap --&gt;
&lt;resultMap id=&quot;accountuser&quot; type=&quot;account&quot;&gt;
&lt;id property=&quot;id&quot; column=&quot;aid&quot;&gt;&lt;/id&gt;
&lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;
&lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt;
  &lt;!-- 一对一的关系映射:配置封装user的信息 --&gt;
  &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
  &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
  &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;
  &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;
  &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt;
&lt;/association&gt;</code></pre>  
</blockquote>
<pre><code>在association中，如果不写javaType,报错：空指针异常
javatype:将数据封装到实体对象中</code></pre><h3 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询<collection></collection></h3><pre><code>* 一对多连接，主表的实体类需要包含从表实体类的集合引用，在配置文件中，使用collection标签来封装数据集合</code></pre><p><img src="/2020/05/15/mybatis/one2manyxml.png" alt="主体的配置文件"><br>        数据查询结果<br><img src="/2020/05/15/mybatis/one2many.png" alt="主体的配置文件"></p>
<pre><code>* 数据查询结果显示，数据为一对多情况，MyBatis将属于同一个用户的账户，封装到了账户的集合之中</code></pre><h3 id="多对多查询"><a href="#多对多查询" class="headerlink" title="多对多查询"></a>多对多查询</h3><pre><code>示例：用户与角色之间的关系
    一个用户可以拥有多个角色
    一个角色可以赋予多个用户

    典型的多对多

    1. 建立两张表：用户表 角色表
    2. 两者具有多对多的关系
        建立中间表，主键为两者的联合主键，中间表中是外键
    3. 建立两个实体类
        让用户和角色实体类能体现出多对多的关系
        两者分别包含对象集合引用
    4. 建立两个配置文件
    5. 实现配置
        查询用户时，同时得到包含的角色信息
        查询角色时，同时得到包含的用户信息</code></pre><p><img src="/2020/05/15/mybatis/many2many.png" alt="many2many的配置文件"><br><img src="/2020/05/15/mybatis/many2many_1.png" alt="many2many的配置文件"></p>
<pre><code>* 一个用户包含的所有角色信息，因为要包括所有的用户，不能使用内连接，应该使用外连接，在使用user_role表的时候，有可能列名相同,需要别名，在写配置resultMap时，注意别名</code></pre><h2 id="MyBatis延迟加载"><a href="#MyBatis延迟加载" class="headerlink" title="MyBatis延迟加载"></a>MyBatis延迟加载</h2><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><pre><code>在一对多的数据查询的时候，一个用户，100个账户
    在查询用户信息的时候，要不要将账户的信息查询出来
    在查询账户信息的时候，要不要将用户的信息查询出来

    在查询账户的时侯，用户下的账户的信息应该是，什么时候使用，什么时候查询
    在查询用户的时候，账户下的用户的信息应该是，随着账户的信息一起查询出来

1. 延迟加载
    在真正使用数据的时侯，才将数据查询出来；不使用的时候，不进行查询

2. 立即加载
    无论数据是否使用，一旦调用方法，马上进行查询

3. 使用时机
    一对一，多对一：立即加载（一般需要立刻看到信息）
    一对多，多对多：延迟加载（一般不需要立刻看到信息）</code></pre><h4 id="实现延迟加载"><a href="#实现延迟加载" class="headerlink" title="实现延迟加载"></a>实现延迟加载</h4><pre><code>1. 在一对一的时候实现延迟加载
    * 更改查询语句
        在此时，不需要将所有的数据全都查询出来，只需要将所有的账户查询出来，不需要带着用户信息
    * 修改结果集
        由于不需要用户信息，结果集的封装可以删除
    * 修改级联查询语句
        在&lt;association&gt;语句中，增加select属性，指明查询的唯一标识</code></pre><blockquote>
<pre><code>&lt;!-- 定义封装account和user的resultMap --&gt;
&lt;resultMap id=&quot;accountuserMap&quot; type=&quot;account&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
  &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;
  &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt;

&lt;!-- 一对一的关系映射:配置封装user的信息,
select 查询用户的唯一标识,在接口文件中，根据id查询用户的方法
column 用户根据id查询时，所需要的参数的值，此地将查询出来的uid作为参数传入
 --&gt;
&lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot; select=&quot;com.mybatis_base_06_lazyload.dao.IUserDao.findById&quot;&gt;

&lt;/association&gt;</code></pre>  
</blockquote>
<pre><code>* 修改SqlMapConfig.xml,打开延迟加载开关
    打开延迟加载的开关，关闭立即加载的开关</code></pre><blockquote>
<pre><code>&lt;!-- 配置参数。延迟加载 --&gt;
&lt;settings&gt;
  &lt;!-- 开启延迟加载的全局开关 --&gt;
  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;!-- 立即加载 --&gt;
  &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;
&lt;/settings&gt;</code></pre></blockquote>
<p><img src="/2020/05/15/mybatis/lazyload1.png" alt="一对一的延迟加载"></p>
<pre><code>2. 什么是按需？
    1. 在进行单独数据查询，或者是数据遍历时，才会将所有数据显示出来
    2. 根据用户的id，或者其他的要求进行数据查询

3. 一对多的数据查询    
    与一对一的延迟加载相似,查询语句，结果集，以及账户实体类中的按照id查询</code></pre><p><img src="/2020/05/15/mybatis/lazyload2.png" alt></p>
<h2 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h2><h3 id="缓存基本概念"><a href="#缓存基本概念" class="headerlink" title="缓存基本概念"></a>缓存基本概念</h3><pre><code>存在内存中的临时数据

1. 为什么使用缓存？
    减少和数据库的交互次数，提高执行效率

2. 什么数据能使用缓存，什么数据不能使用？
    1. 适用于缓存：
        经常查询并且不经常改变的
        数据的正确性对最终结果影响不大的

    2. 不适用缓存：
        经常改变的数据
        数据的正确性对最终结果影响很大的
            （商品的库存，银行的汇率，股市的股价）</code></pre><h3 id="MyBatis的缓存-1"><a href="#MyBatis的缓存-1" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h3><pre><code>1. 一级缓存：
    它是指Mybatis中的SqlSession对象的缓存
    当我们执行查询的时候，查询的结果会同时存入到SqlSession为我们提供的一块区域内
    该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去SqlSession中查询是否存在，有的话，直接拿来使用
    当SqlSession对象消失时，一级缓存同时消失

    1. 缓存同步问题
        如果调用session的insert update delete close() commit() clearcache()方法，会自动放弃当前的一级缓存，直接从数据库中查询数据

2. 二级缓存
    由MyBatis中SqlSessionFactory对象的缓存，同一个SqlSessionFactory对象创建的SqlSession对象共享其缓存。

    1. 二级缓存的使用步骤
        1. 让MyBatis支持二级缓存 SqlMapConfig.xml配置
        2. 让当前的映射文件支持二级缓存，IUserDao.xml
        3. 让当前的操作支持二级缓存，select标签</code></pre><h2 id="MyBatis注解开发"><a href="#MyBatis注解开发" class="headerlink" title="MyBatis注解开发"></a>MyBatis注解开发</h2><h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><pre><code>1. 在SqlMapConfig.xml中的mapper中，使用class,导入接口资源文件
2. 在接口类上，使用注解进行开发
3. 其余步骤与使用xml开发一致

注意：
    如果在与接口类的相同路径下的资源路径下，建立IUserDao.xml文件，不管有没有使用.xml文件，都会产生错误。</code></pre><h3 id="名称不一致"><a href="#名称不一致" class="headerlink" title="名称不一致"></a>名称不一致</h3><pre><code>1. 实体类名与数据库列名不一致
    1. 使用别名，将数据库中查询出来的数据进行设置别名
    2. 使用@Results注解，进行配置</code></pre><blockquote>
<pre><code>/**
 * 查询所有,获取所有的账户信息
 */
@Select(&quot;select * from user&quot;)
@Results(id= &quot;userMap&quot;,value = {
        @Result(id=true,column = &quot;id&quot;,property = &quot;userId&quot;),
        @Result(column = &quot;username&quot;,property = &quot;userName&quot;),
        @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;),
        @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;),
        @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;)
})
List&lt;UserfindAll();

@Select(&quot;select * from user where id=#{id}&quot;)
@ResultMap(value = {&quot;userMap&quot;})
User findById(Integer id);</code></pre></blockquote>
<pre><code>    * @Results中id是唯一标识，定义之后，可以在别的位置使用
        values代表结果对应的封装数组

    * @Result中，id代表是否为唯一标识，默认为false
        column:数据库列名
        property:实体类属性名

2. 定义了@Results注解
    想在别的地方使用，使用@resultMap注解
            @ResultMap(value = {&quot;userMap&quot;}) //完整写法
    values已经定义好的结果集封装</code></pre><h3 id="一对多查询注解版"><a href="#一对多查询注解版" class="headerlink" title="一对多查询注解版"></a>一对多查询注解版</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre><code>结果集的封装，主要关注@Result中的属性：one many
一对一：使用one 
一对多：使用many</code></pre><p><img src="/2020/05/15/mybatis/anno_one2many.png" alt="注解配置"></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Reflection（java反射机制）</title>
    <url>/2020/09/10/reflection/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><pre><code>1. 反射（reflection）：动态语言的关键
    * 反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性和方法
    * 加载完类之后，在堆内存的方法区产生一个Class对象（一个类只有一个Class对象），这个对象就包含完整的类的信息，可以通过这个Class对象看到类的结构，通过对象看到类的结构的过程，叫做反射

2. 使用反射的应用
    * 在运行时判断一个对象所属的类
    * 在运行时构造任意一个类的对象
    * 在运行时获取泛型的信息
    * 在运行时获取私有属性，私有方法
    * 在运行时父类的信息，父类上的泛型
    * 在运行时获取接口
    * 在运行时获取所在包，注解
    * 。。。

3. 相干的API
    * java.lang.Class
    * java.lang.reflect.Method    //方法
    * java.lang.reflect.Filed    //成员变量    
    * java.lang.reflect.Constructor        //构造器

4. 反射和封装性
    * 通过直接new对象，或反射的方式都可以调用公共的结构，具体使用位置？
        1. 建议直接使用new方式，编译的时候可以确定创建哪个对象
        2. 编译的时候无法确定创建哪个对象，根据传入的参数进行对象的创建，使用反射的方式：
            反射机制具有动态性

    * 有了反射机制，与对象的封装性，如何看待两种技术？
        1. 不矛盾
        2. 封装性：将对象的属性和方法进行权限限定，暴露出的接口表现用户可以使用的方法，建议用户使用的方法和属性，不建议使用私有方法[建不建议]
        3. 反射：可以使用的方法，用户强制使用私有的属性和方法[能不能]</code></pre><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><h3 id="java-lang-Class的理解"><a href="#java-lang-Class的理解" class="headerlink" title="java.lang.Class的理解"></a>java.lang.Class的理解</h3><pre><code>1. 类的加载过程
    程序在经过javac.exe命令之后，会生成一个或多个字节码文件（.class）文件，
    接着使用java.exe命令对某个字节码文件进行解释运行。相当于将字节码文件加载到内存，此过程叫做类的加载。
    加载到内存中的类，我们称为运行时类，此运行时类，就作为Class类的一个实例。

2. 换句话说，Class的实例就是一个运行时类的对象
3. 加载到内存的运行时类，会缓存一定的时间。在此时间之内，可以通过不同的方法获取运行时类</code></pre><h3 id="获取Class的实例方式"><a href="#获取Class的实例方式" class="headerlink" title="获取Class的实例方式"></a>获取Class的实例方式</h3><pre><code>1. 方式一：通过运行时类的.class属性获取Class实例
    Class clazz1 = Person.class();
    System.Out.Println(clazz1);

2. 方式二：通过运行时类的对象的.getClass()方法获取实例
    Person person = new Person();
    Class clazz2 = person.getClass();

3. 方式三：通过Class的.forName(&quot;运行时类的全限定类名&quot;)获取实例
    Class clazz3 = Class.forName(&quot;全限定类名&quot;)；

4. 方式四：通过类的加载器获取实例
     ClassLoader classLoader = Reflection.class.getClassLoader();
    Class clazz4 = classLoader.loadClass(&quot;全限定类名&quot;);

上述的四种Class实例的获取方式，方式一和方式二，都与具体的实现类绑定，在开发中一般使用Class类的.forName()方法获取Class实例对象。</code></pre><h3 id="Class对象的范围"><a href="#Class对象的范围" class="headerlink" title="Class对象的范围"></a>Class对象的范围</h3><pre><code>1. class:各种类对象
2. interface
3. []:数组 只要数组的类型和维度相同，就是一个Class对象
4. enum:枚举
5. annotation
6. 基本数据类型
7. void</code></pre><h2 id="ClassLoader-类加载器"><a href="#ClassLoader-类加载器" class="headerlink" title="ClassLoader(类加载器)"></a>ClassLoader(类加载器)</h2><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><pre><code>1. 加载：将类的字节码文件读入内存，并为其创建一个java.lang.Class对象，实现类的加载过程
2. 链接：静态变量初始化为默认值
3. 初始化：JVM使用构造器方法完成类变量的赋值和静态代码块的语句顺序合并产生数据</code></pre><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><pre><code>1. 将.class加载到内存，将这些静态数据转换成方法区运行时的数据结构，生成Class对象，作为方法区中类数据的访问入口
2. 类缓存：一旦某个类被加载到类加载器，会在类加载器中维持一段时间，JVM的垃圾回收机制可以回收Class对象

3. 分类
    * 引导类加载器：C++编写的，主要加载Java的核心类库，用户无法获取到该加载器
    * 扩展类加载器：加载java/lib/ect中的jar包
    * 系统类加载器：加载当前程序中的类</code></pre><blockquote>
<pre><code>//1.对于自定义类，使用系统级类加载器
ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
System.out.println(classLoader);

//2.调用系统类加载器的getParent()，获取扩展类加载器
ClassLoader classLoader1 = classLoader.getParent();
System.out.println(classLoader1);

//3.调用扩展类加载器getParent()，无法获取引导类加载器
//引导类加载器加载java的核心类库
ClassLoader classLoader2 = classLoader1.getParent();
System.out.println(classLoader2);</code></pre></blockquote>
<h2 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h2><h3 id="反射创建运行时类的对象"><a href="#反射创建运行时类的对象" class="headerlink" title="反射创建运行时类的对象"></a>反射创建运行时类的对象</h3><pre><code>1. 使用.newInstance()方法创建运行时类的对象
    newInstance:
        * 调用此方法，创建运行时类的方法
        * 内部调用运行时类的空参构造器
        * 如果没有空参构造器，产生异常

2. 满足两个条件
    * 运行时类必须提供空参的构造器
    * 访问权限不能为private,通常设置为public</code></pre><h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><pre><code>修饰符 返回类型 变量名；

1. 获取所有属性
    1. 获取当前运行时类的所有属性（getDeclaredFileds）
        * 不考虑权限问题，不会获取父类的属性</code></pre><blockquote>
<pre><code>Field[] fields1 = clazz.getDeclaredFields();
for(Field field:fields1){
    System.out.println(field);
}</code></pre></blockquote>
<pre><code>2. 获取属性包含父类的属性（getFileds）
    * 获取当前运行时类以及父类的所有权限为public的属性</code></pre><blockquote>
<pre><code>Field[] fields = clazz.getFields();
for(Field field:fields){
    System.out.println(field);
}        </code></pre></blockquote>
<pre><code>2. 获取属性的修饰符,数据类型，变量名</code></pre><blockquote>
<pre><code>Class clazz = Person.class;

//获取当前运行时类的所有属性
Field[] fields = clazz.getDeclaredFields();

for(Field field:fields){
//修饰符
//权限被分配了 整型数据,使用Modifier的方法可以翻译为字符串
int modifiers = field.getModifiers();
System.out.print(Modifier.toString(modifiers)+&quot;\t&quot;);
//数据类型
Class&lt;?type = field.getType();
System.out.print(type.getName()+&quot;\t&quot;);
//属性名
System.out.println(field.getName());
}</code></pre></blockquote>
<p><img src="/2020/09/10/reflection/fields.png" alt="运行时类的属性"></p>
<h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><pre><code>1. 获取当前运行类声明的所有方法</code></pre><blockquote>
<pre><code>Method[] methods = clazz.getMethods();
for(Method method:methods){
    System.out.println(method);
}</code></pre></blockquote>
<pre><code>2. 获取当前运行时类以及所有父类的声明为public权限的方法</code></pre><blockquote>
<pre><code>Method[] declaredMethods = clazz.getDeclaredMethods();
for(Method method:declaredMethods){
    System.out.println(method);
}</code></pre></blockquote>
<pre><code>3. 获取方法的修饰符，数据类型，方法名
    * @Anno
    * 权限修饰符 返回值类型 方法名(形参列表) Throws Exception{}

    Method[] declaredMethods = clazz.getDeclaredMethods();
    for(Method method:declaredMethods){
        System.out.println(&quot;-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&quot;);
        //1.注解获取
        Annotation[] methodAnnotations = method.getAnnotations();
        for(Annotation anno:methodAnnotations){
            System.out.print(anno+&quot;\t&quot;);
        }

        //2.权限修饰符
        System.out.print(Modifier.toString(method.getModifiers())+&quot;\t&quot;);
        //3.返回值类型
        System.out.print(method.getReturnType()+&quot;\t&quot;);
        //4.方法名
        System.out.print(method.getName());
        System.out.print(&quot;(&quot;);
        //5.形参列表参数
        Class[] parameterTypes = method.getParameterTypes();
        if(parameterTypes.length 0){
            for(int i = 0;i &lt; parameterTypes.length;i++){
                if(i == parameterTypes.length-1){
                    System.out.print(parameterTypes[i].getName()+&quot; args_&quot;+i);
                    break;
                }
                System.out.print(parameterTypes[i].getName()+&quot; args_&quot;+i+&quot; , &quot;);
            }
        }
        System.out.print(&quot;)&quot;);
        //6.获取抛出的异常
        Class[] exceptionTypes = method.getExceptionTypes();
        if(exceptionTypes.length 0){
            System.out.print(&quot; throws &quot;);
            for(int i = 0;i &lt; exceptionTypes.length;i++){
                if(i == exceptionTypes.length-1){
                    System.out.print(exceptionTypes[i].getName());
                    break;
                }
                System.out.print(exceptionTypes[i].getName()+&quot; , &quot;);
            }
        }
        System.out.println(&quot;{&quot;+&quot;\n&quot;+&quot;}&quot;);
    }</code></pre><h3 id="获取构造器的结构"><a href="#获取构造器的结构" class="headerlink" title="获取构造器的结构"></a>获取构造器的结构</h3><pre><code>1. 当前运行时类的所有的构造器</code></pre><blockquote>
<pre><code>Constructor&lt;?&gt;[] constructors = clazz.getConstructors();
for(Constructor c:constructors){
    System.out.println(c);
}</code></pre></blockquote>
<pre><code>2. 当前运行时类的所有public的构造器</code></pre><blockquote>
<pre><code>Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();
for(Constructor c:constructors){
    System.out.println(c);
}</code></pre></blockquote>
<h3 id="获取运行时类的父类"><a href="#获取运行时类的父类" class="headerlink" title="获取运行时类的父类"></a>获取运行时类的父类</h3><pre><code>1. getSuperClass():获取父类
2. getGenericSuperClass()：获取带有泛型的父类</code></pre><h2 id="调用运行时类的指定结构（方法和属性）"><a href="#调用运行时类的指定结构（方法和属性）" class="headerlink" title="调用运行时类的指定结构（方法和属性）"></a>调用运行时类的指定结构（方法和属性）</h2><pre><code>1. 获取指定的属性
    方法：
        getFiled():
            属性声明必须为public
        getDeclaredFiled()
            可以访问，但是如果想要访问私有属性，必须显式
            &lt;属性名&gt;.setAccessible(true);                

    1. 步骤
        * 获取Class对象
        * 创建Class对象的实例
        * 获取指定的属性
        * set方法
            * set(obj,value):obj：指明设置哪个对象的属性 value:设置的值
        * get方法
            * get(obj):obj：指明获取那个对象的属性

    2. 实例
        Class clazz = Person.class;
        Person p = (Person)clazz.newInstance();
        Filed filed = clazz.getDeclaredFiled(&quot;age&quot;);
        filed.setAccessible(true);
        filed.set(p,&quot;11111&quot;);

2. 获取指定的方法
    方法：
        getDeclaredMethod(name,param): 参数1：获取的方法的名称，参数2：获取的方法的形参列表
            可以访问，但是如果想要访问私有属性，必须显式
            &lt;方法名&gt;.setAccessible(true);

        &lt;方法名&gt;.invoke(obj,value):参数1:方法的调用者，参数2(可变形参)：赋值的实参
            invoke()方法的返回值为类中调用方法的返回值，
                如果调用的方法没有返回值，那么返回值为null

    1. 实例</code></pre><blockquote>
<pre><code>//1.获取指定的方法名
Method method = clazz.getDeclaredMethod(&quot;compareTo&quot;, String.class);
//2.确定当前方法是可以访问的
method.setAccessible(true);
//3.调用方法
method.invoke(p,&quot;HHHHH&quot;);   //p.show(&quot;HHHHH&quot;)</code></pre></blockquote>
<pre><code>2. 调用静态方法
    invoke(null)
    invoke(Person.class)</code></pre>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2020/09/09/spring/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-什么是spring："><a href="#1-什么是spring：" class="headerlink" title="1. 什么是spring："></a>1. 什么是spring：</h3><pre><code>1. 分层的Java SE/EE的轻量级开源框架
2. 提供了展现层Spring MVC 和持久层Spring JDBC以及业务层事务管理的众多技术
3. 展现层和持久层的中间部分，业务层</code></pre><h3 id="2-spring的核心："><a href="#2-spring的核心：" class="headerlink" title="2. spring的核心："></a>2. spring的核心：</h3><pre><code>1. IoC（Inversion of Control）: 控制反转
2. AOP（Aspect Oriented Programming）: 面向切面编程</code></pre><h3 id="3-发展历程和优势"><a href="#3-发展历程和优势" class="headerlink" title="3.发展历程和优势"></a>3.发展历程和优势</h3><pre><code>spring优势：
    1. 方便解耦，简化开发
    2. AOP编程的支持
    3. 声明式事务的支持
    4. 方便程序的测试
    5. 方便集成各种优秀的框架</code></pre><h2 id="程序的耦合和解耦"><a href="#程序的耦合和解耦" class="headerlink" title="程序的耦合和解耦"></a>程序的耦合和解耦</h2><h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><pre><code>1. 什么是耦合：
    程序之间的依赖关系：
        * 类之间的依赖关系
        * 方法之间的依赖关系

2. 开发中的做法：
    编译期不依赖，运行时依赖

3. 方法：
    1. 使用读取配置文件来获取要创建的对象的全限定名称
        使用类加载器，获取配置文件的输入流
    2. 使用反射（reflection）来创建对象，而不是使用new关键字
        * 使用反射，如果字符串写死，以后无法再次使用别的数据库配置</code></pre><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><pre><code>1. 什么是解耦：
    降低程序之间的依赖关系

2. 解耦的方式：使用工厂模式创建Bean对象
      * bean: 可重用组件
      * javaBean &gt; 实体类
      * javaBean 用java语言编写的可重用组件
      * beanfactory：创建bean对象的工厂

3. 如何创建工厂模式
    1. 读取配置文件来反射bean对象
    2. 配置文件来创建service和dao
        唯一标识=全限定类名，key = value，根据对应的value创建实例对象</code></pre><h2 id="IoC（Inversion-of-Control）"><a href="#IoC（Inversion-of-Control）" class="headerlink" title="IoC（Inversion of Control）"></a>IoC（Inversion of Control）</h2><pre><code>1. 概念：
    把创建对象的权力交给框架，是框架的重要特征，包括依赖注入（Dependency Injection,DI）和依赖查找（Dependency Lookup）

2. 作用
    * 降低程序之间的耦合度
    * 将类中的对象创建工作交给spring框架来完成，只要获取该对象就可以了
    * 使用依赖注入进行属性值的填充，在创建对象的同时完成赋值</code></pre><h3 id="基于XML的IoC配置"><a href="#基于XML的IoC配置" class="headerlink" title="基于XML的IoC配置"></a>基于XML的IoC配置</h3><h4 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h4><pre><code>1. 步骤
    * 读取配置文件创建IoC容器（ApplicationContext）
    * 根据id，获取容器中的文件

2. 配置文件的内容
    * 主要是&lt;bean&gt;标签，id:查找对象的唯一标识符，class:要创建的对象的全限定类名

3. 读取配置文件创建容器
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    根据类路径下的xml配置文件创建容器，配置文件需要放置在类路径下

    ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;bean.xml&quot;);
    可以加载磁盘任意路径下的配置文件

    ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class);
    根据类上有@Configuration的类创建容器

4. 根据id获取对象
    as.getBean(&quot;id&quot;);</code></pre><h4 id="BeanFactory和ApplicationContext"><a href="#BeanFactory和ApplicationContext" class="headerlink" title="BeanFactory和ApplicationContext"></a>BeanFactory和ApplicationContext</h4><pre><code>1. Beanfactory接口
    * 创建核心容器时，创建对象的方式采用延迟加载的方式，什么时候根据ID获取对象的时候，什么时候开始创建真正的对象
     * 多例模式适用

2. ApplicationContext接口
    * 创建核心容器时，创建对象的方式采用立即加载的方式，只要一读取完配置文件马上创建配置文件中的对象
     * 单例模式时适用：只创建一个对象

3. 具体的使用
    BeanFactory是顶层接口，功能不如ApplicationContext，实际使用的接口为ApplicationContext接口

    ApplicationContext可以根据配置文件的不同，选择合适的加载方式
    可以感知到对象的单例还是多例，从而选择不同的方式创建对象</code></pre><h4 id="spring对bean对象的管理细节"><a href="#spring对bean对象的管理细节" class="headerlink" title="spring对bean对象的管理细节"></a>spring对bean对象的管理细节</h4><h5 id="1-创建bean的三种方式"><a href="#1-创建bean的三种方式" class="headerlink" title="1. 创建bean的三种方式"></a>1. 创建bean的三种方式</h5><pre><code>1. 使用默认构造函数创建：
   在spring的配置文件中使用bean标签，配以id 和 class属性，且没有其他的属性和标签时
   采用的就是默认构造函数创建bean对象(Class类的实例反射)，如果此时没有默认构造函数，则无法创建</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_IoC_bean.service.impl.AccountServiceImpl&quot;/&gt;</code></pre></blockquote>
<pre><code>2. 使用普通工厂中的方法创建对象
    使用某个类中的方法创建对象，并存入spring容器中</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.spring_03_IoC_bean.factory.InstanceFactory&quot;/&gt;
&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;/&gt;</code></pre></blockquote>
<pre><code>3. 使用工厂的静态方法创建对象（
    使用某个类的静态方法创建对象(可以不创建该对象)，并将其存入spring容器</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_IoC_bean.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;/&gt;</code></pre></blockquote>
<h5 id="2-bean对象的作用范围"><a href="#2-bean对象的作用范围" class="headerlink" title="2. bean对象的作用范围"></a>2. bean对象的作用范围</h5><pre><code>1. bean标签的scope属性规定bean对象的范围
2. 类型
    * singleton: 单例模式（默认）
    * prototype：多例模式
    * requset:web应用的一次请求
    * session：web应用中的一次会话
    * global-session：web应用中的全局会话</code></pre><h5 id="3-bean对象的生命周期"><a href="#3-bean对象的生命周期" class="headerlink" title="3. bean对象的生命周期"></a>3. bean对象的生命周期</h5><pre><code>1. 单例对象：singleton
  出生：当容器创建时，对象出生
  活着：只要容器还在，对象活着
  死亡：容器销毁，对象死亡
2. 多例对象：prototype
  出生：当使用对象时，spring框架创建
  活着：只要在使用的时候一直存在
  死亡：只有在对象长时间不用，且没有其他的对象引用的时候，由垃圾回收机制回收</code></pre><h4 id="依赖注入（dependency-injection-DI）"><a href="#依赖注入（dependency-injection-DI）" class="headerlink" title="依赖注入（dependency injection:DI）"></a>依赖注入（dependency injection:DI）</h4><pre><code>1. 什么是依赖？    
    当前类中引用到其他类的对象，叫做依赖。
    在spring框架中，依赖对象由框架提供，我们只需要提供配置文件的说明（IoC方式）

2. spring降低程序之间的依赖关系?
    IoC控制反转
    依赖注入

3. 依赖注入的数据类型：
    1. 基本数据类型和String类型
    2. 其他bean对象
    3. 复杂类型（集合类型）

4. 依赖注入的方式：
    1. 通过默认构造函数注入依赖
    2. 使用set方法注入 ***
    3. 通过注解注入</code></pre><h5 id="1-通过默认构造函数注入"><a href="#1-通过默认构造函数注入" class="headerlink" title="1. 通过默认构造函数注入"></a>1. 通过默认构造函数注入</h5><pre><code>标签：constructor-arg
位置：bean中的内部
属性含义：
    type: 指定要注入的数据类型，该数据类型是构造函数的某个或者某些参数的类型
    index: 指定要注入数据给构造函数的参数指定索引的位置的赋值
    name: 用于指定给构造函数的指定名称的参数赋值（主要方式）
    ===================指定给构造函数的那个参数赋值=======================

    value: 提供基本类型和String类型的数据
    ref: 指定其他的bean类型的数据，在spring的IoC的核心容器中的bean对象

优势：
    在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功
缺点：
    改变了bean对象的实例化方式，在我们创建对象时，即使用不到这些数据，也必须提供数据</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;李某&quot;/&gt;
    &lt;constructor-arg name=&quot;age&quot; value=&quot;23&quot;/&gt;
    &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;
&lt;/bean&gt;</code></pre></blockquote>
<blockquote>
<pre><code>&lt;!-- 配置一个日期对象 --&gt;
&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;/&gt;</code></pre></blockquote>
<h5 id="2-使用set进行依赖注入"><a href="#2-使用set进行依赖注入" class="headerlink" title="2. 使用set进行依赖注入"></a>2. 使用set进行依赖注入</h5><pre><code>标签：property
位置：bean标签内部
参数：
    name:    指定注入的时候的方法的名称
    value:     指定基本数据类型和String类型
    ref:     指定其他的bean类型的数据，只要是在spring核心容器中的bean对象都可以

优势：创建bean对象的时候，可以直接使用默认构造函数
   缺点：
      如果某个成员必须有值，获取对象的set方法可能没有执行</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService2&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl2&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;22&quot;/&gt;
    &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;
&lt;/bean&gt;</code></pre></blockquote>
<blockquote>
<pre><code>&lt;!-- 配置一个日期对象 --&gt;
&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;/&gt;</code></pre></blockquote>
<h5 id="3-使用注解进行依赖注入"><a href="#3-使用注解进行依赖注入" class="headerlink" title="3. 使用注解进行依赖注入"></a>3. 使用注解进行依赖注入</h5><pre><code>@Autowired
@Qualifier
@Resource
@Value
进行依赖注入</code></pre><h5 id="4-注入复杂数据类型"><a href="#4-注入复杂数据类型" class="headerlink" title="4. 注入复杂数据类型"></a>4. 注入复杂数据类型</h5><pre><code>List Set      
Map Properties

标签：property
位置：property内部
其中：只要数据集合的结构相同，可以使用同一种标签进行依赖注入
    list set arrsy: 都可以使用&lt;list&gt;,&lt;array&gt;,&lt;set&gt;，序列格式
    map property:&lt;map&gt;,&lt;pros&gt;，键值对格式</code></pre><blockquote>
<pre><code>private String[] myStr;
private List&lt;StringmyList;
private Set&lt;StringmySet;
private Map&lt;String,StringmyMap;
private Properties myProp;</code></pre></blockquote>
<pre><code>具体的调用方法</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService3&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl3&quot;&gt;
&lt;property name=&quot;myStr&quot;&gt;
  &lt;array&gt;
    &lt;value&gt;AAA&lt;/value&gt;
    &lt;value&gt;VVVDDD&lt;/value&gt;
    &lt;value&gt;SS&lt;/value&gt;
    &lt;value&gt;SSDDD&lt;/value&gt;
  &lt;/array&gt;
&lt;/property&gt;
&lt;!-- map --&gt;
&lt;property name=&quot;myMap&quot;&gt;
  &lt;map&gt;
    &lt;entry key=&quot;1&quot; value=&quot;11111&quot;/&gt;
    &lt;entry key=&quot;2&quot; value=&quot;22222&quot;/&gt;
  &lt;/map&gt;
&lt;/property&gt;</code></pre>  
</blockquote>
<h3 id="基于注解的IoC配置"><a href="#基于注解的IoC配置" class="headerlink" title="基于注解的IoC配置"></a>基于注解的IoC配置</h3><pre><code>使用注解和xml开发要实现的功能都是一致的：降低程序之间的耦合，将xml中对应的功能交由注解来实现</code></pre><h4 id="1-用于创建bean对象的注解"><a href="#1-用于创建bean对象的注解" class="headerlink" title="1. 用于创建bean对象的注解"></a>1. 用于创建bean对象的注解</h4><pre><code>* 与xml配置文件中的&lt;bean&gt;标签的作用相同：创建一个bean对象，将其放置在容器中
* 如果想让spring知道存在组件，需要使用spring中的包扫描，将需要创建bean对象的包传入&lt;context&gt;标签中

1. @Component:组件注解
    * 作用：将当前对象存入spring容器中(写在类名上)
    * 属性：value:
            用于指定获取容器中bean的id，当我们不写时，默认是当前类名，首字母小写    

2. @Controller:一般用于表现层
3. @Service：一般用于业务层
4. @Repository:一般用于持久层
以上的三个注解和@Component的作用和属性完全一致，是spring框架为我们明确提供的三层注解，让我们的三层结构更加清晰</code></pre><h4 id="2-用于数据注入的注解"><a href="#2-用于数据注入的注解" class="headerlink" title="2. 用于数据注入的注解"></a>2. 用于数据注入的注解</h4><pre><code>* 与xml配置文件的&lt;property&gt;作用一致：进行数据注入

1. @Autowired:自动按照类型注入
     * 只要IoC容器中有唯一的bean对象和要注入的变量类型相同，就可以自动注入
     * 如果IoC容器中没有任何bean对象和要注入的变量类型相同，无法自动注入
     * 如果IoC容器中有多个bean对象和要注入的变量类型相同，
     * 首先圈定类型相同的bean对象的范围，然后会在进行变量名称的比对,如果名称相同，就可以注入数据</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/autowired.png" alt="autowired注解">         </p>
<pre><code>2. @Qualifier
    * 先按照类型自动注入，如果包含有多个相同类型的bean对象，会按照名称进行数据注入
    * 在按照类型注入的基础上，再按照名称注入，在给类成员的注入的时候不能单独使用，但是在给方法注入的时候可以，，将@Qualifier()中的名称所对应的Bean对象注入到方法中
    * 参数：
        value:用于指定注入的bean的id

3. @Resource
    * 直接按照bean的id进行注入，可以单独使用
    * 参数：
        name:用于指定注入的bean的id

注意：
     以上的三种注入方式只能注入其他的bean类型的数据，基本类型和String类型无法通过上述方法注入
          集合类型只能通过xml方式注入

4. @Value
    * 注入基本数据类型和String类型
    * 参数：    
        value:用于指定数据的值，可以使用SpEL（spring的El表达式）                      SpEL的写法：${表达式}</code></pre><h4 id="3-用于改变作用范围的注解"><a href="#3-用于改变作用范围的注解" class="headerlink" title="3. 用于改变作用范围的注解"></a>3. 用于改变作用范围的注解</h4><pre><code>* 与xml文件中的&lt;bean&gt;标签的scope属性作用相同

1. @Scope
    * 参数：
        value:singleton prototype</code></pre><h4 id="4-用于改变生命周期的注解"><a href="#4-用于改变生命周期的注解" class="headerlink" title="4. 用于改变生命周期的注解"></a>4. 用于改变生命周期的注解</h4><pre><code>1. @PreDestroy
    * 销毁容器
2. @PostConstruct
    * 初始化容器</code></pre><h3 id="使用IoC的一个简单案例"><a href="#使用IoC的一个简单案例" class="headerlink" title="使用IoC的一个简单案例"></a>使用IoC的一个简单案例</h3><pre><code>1. 环境配置
    使用DBUtils进行Dao数据交互
    spring框架
    mybatis进行JDBC连接
    c3p0作为数据源</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/IoC_exp_pom.png" alt="pom.xml"></p>
<pre><code>2. bean文件结构
    1. xml配置</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/Ioc_xml_exp.png" alt="xml配置的bean"></p>
<pre><code>2. annotation配置</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/IoC_anno_exp.png" alt="annotation配置的bean"></p>
<blockquote>
<p>注解的形式以及文件结构<br><img src="/2020/09/09/spring/Ioc_structure.png" alt="annotation的结构"></p>
</blockquote>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><pre><code>在案例中，配置文件存在annotation和xml同时存在，下面将其改造为纯注解方式

1. 改变xml中的组件扫描
    @Configurtion:
        * 作用：用于指定当前类是配置类
         * 当配置类作为AnnotationConfigApplicationContext()的参数时可以不写@Configuration，由扫描器直接扫描该配置类
         * 如果是子配置类，而且子配置类的字节码没有作为参数传入，必须写@Configuration

    @ComponentScan
        * 作用：用于指定spring在创建容器是需要扫描的包
        * 参数：value basePackages作用一样（@Alisafor）    
                类似&lt;context:component-scan base-package=&quot;com.spring_04_exp&quot;/&gt;

    一旦这个类上写了@Configuration 和@ComponentScan ,spring就会自动扫描配置包，并且创建对象将其放入容器，只需要拿到这个bean对象就可以了。

2. 根据方法的返回值创建Bean对象
    @Bean
        * 作用：把当前方法的返回值作为Bean对象存入spring容器中
        * 参数：name:
            用于指定bean的id,当不写时，方法名作为默认值
        * 使用注解配置方法时，spring框架会在容器中查找相对于的bean容器，查找方法与@AutoWired相同

3. 配置文件的读取
    @PropetySource
        * 作用：读取配置文件，用于指定properties文件的位置
        * 参数：value
            文件的名称:文件的路径
        * classpath关键字，表示在类路径下

4. 导入其他的配置类
    @Import
        * 作用：用于导入其他的配置类
        * 参数：value
            用于指定其他配置类的的字节码
        * 当我们使用Import注解时，拥有Import的配置类就是父配置类，写在value中的就是子配置类</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/anno_withoutxml_1.png" alt="配置类"><br><img src="/2020/09/09/spring/anno_withoutxml_2.png" alt="配置类"></p>
<pre><code>5. spring整合junit
    1. 程序的入口
        main方法
    2. JUnit单元测试
        没有main方法也能执行，其实junit中集成了main方法
        该方法就会判断当前测试类中有哪些方法上由@Test方法
        junit就会让Test注解执行该方法
    3. junit不知道spring框架
        在执行测试方法的时候，junit根本不知道由spring框架
        所以不会读取配置文件/创建spring容器

    4. 当测试方法执行时，没有IoC容器，就算写了@Autowired注解，也无法注入

    5. 解决方式    
        1. 导入spring整合test的jar包
        2. 使用junit的main方法替换为spring提供的main方法
            1. @Runwith
                * 作用：改变junit的main方法，使用spring框架提供的main方法，可以创建容器
                * 替换的方法的类的字节码
        3. 告诉spring运行器，spring和IoC容器的创建基于xml还是注解
            2. @ContextConfiguration
                * 作用：指定spring和IoC容器的创建基于xml还是注解
                * 参数：
                    locations : 指定xml文件的位置，加上classpath关键字，表示在类路径下
                    classes: 指定配置类位置，字节码文件

    6. 出现问题
        1. spring框架的5.x版本整合junit必须在4.12版本以上
        2. spring-context以及spring-test的版本号要一致
        3. 如果一直无法导入jar包，可以先将本地maven仓库对应的jar包删除，重新导入坐标</code></pre><h2 id="spring的AOP"><a href="#spring的AOP" class="headerlink" title="spring的AOP"></a>spring的AOP</h2><h3 id="完善account的案例"><a href="#完善account的案例" class="headerlink" title="完善account的案例"></a>完善account的案例</h3><h4 id="进行账户之间的转账"><a href="#进行账户之间的转账" class="headerlink" title="进行账户之间的转账"></a>进行账户之间的转账</h4><pre><code>1. 增加新的转账方法
2. 防止转账异常，应该在持久层增加事务控制
3. 将事务控制放在业务层控制
4. 增加数据库连接工具类
5. 为了保证每次连接都只有一个事务控制，将连接和线程绑定
6. 增加事务管理工具类 
7. 改变连接池对象，增加数据注入

增加很多冗余代码，配置文件变得更为复杂</code></pre><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><pre><code>1. 优势
    * 字节码随用随创建，随用随代理
    * 在不改变源码的时候对方法进行增强</code></pre><h4 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><pre><code>1. 涉及的类
    * Proxy类
    * JDK官方

2. 创建代理对象的方法
    * Proxy.newProxyInstance()

3. 要求
    * 被代理对象至少要实现一个接口，如果没有，不能使用

4. newProxyInstance()的参数
    * ClassLoader:类加载器
        用于加载代理对象的字节码，和被代理对象使用相同的类加载器：固定写法

    * Class[]:字节码数组
        用于指定代理和被代理对象实现相同的方法，代理谁就写谁的接口：固定写法

    * InvacationHandler
        用于指定增强的代码
        让我们写任何实现代理，一般在某个实现方法上进行改变
        一般情况下，为匿名内部类，但是不是必须的
        此接口的实现类，都是谁用谁写

5. InvacationHandler的实现方法的参数</code></pre><blockquote>
<pre><code>实现类中需要重写invoke方法,执行被代理对象的任何方法都会经过该方法
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
   return null;
 }
    * proxy : 被代理对象的引用
    * method : 当前执行的方法
    * args : 当前方法执行的参数
    * 返回类型：和被代理对象的相同方法有相同的返回值类型</code></pre></blockquote>
<h4 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h4><pre><code>1. 导入jar包
    cglib包

2. 涉及的类
    * Enhancer类
    * 第三方cglib库

3. 创建代理对象的方法
    * Enhancer.create()方法

4. create方法的参数
    * Class:被代理对象的字节码
    * Callback:
        * 用于提供增强的方法
         * 如何代理对象，该接口的实现类，通常情况下为匿名内部类，但不是必须的
         * 此接口的方法都是谁用谁写
         * 实现该接口的子接口的实现类，MethodInterceptor方法拦截器

5. MethodInterceptor方法的参数</code></pre><blockquote>
<pre><code>方法的重写
@Override
public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
    return null;
}
参数：
    * 执行被代理对象的方法都经过该方法
    * @param o 被代理对象
    * @param method 当前执行的方法
    * @param objects 当前方法执行的对象
    *                和基于接口的方法的invoke参数相同
    * @param methodProxy 当前执行方法的代理对象
    * @return 和当前方法的返回值类型相同
    * @throws Throwable    </code></pre></blockquote>
<h4 id="动态代理在案例中的使用"><a href="#动态代理在案例中的使用" class="headerlink" title="动态代理在案例中的使用"></a>动态代理在案例中的使用</h4><pre><code>1. 创建代理工厂类，在获取AccountService的基础上，对原有的方法进行增强，增加事务控制</code></pre><blockquote>
<pre><code>public class BeanFactory {
    private IAccountService accountService;
    private TransactionManager transactionManager;</code></pre></blockquote>
<pre><code>public void setTransactionManager(TransactionManager transactionManager) {
    this.transactionManager = transactionManager;
}</code></pre><blockquote>
</blockquote>
<pre><code>public final void setAccountService(IAccountService accountService) {
    this.accountService = accountService;
}</code></pre><blockquote>
</blockquote>
<pre><code>/**
 * 获取代理对象的返回方法
 * @return
 */
public IAccountService getAccountService(){
    return (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(),
            accountService.getClass().getInterfaces(), new InvocationHandler() {
                /**
                 * 增强方法,对事务进行增强
                 */
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    Object rtValue = null;
                    try {
                        //1.开启事务
                        transactionManager.beginTransaction();
                        //2.执行操作
                        rtValue = method.invoke(accountService,args);
                        //3.提交事务
                        transactionManager.commitTransaction();
                        //4.返回结果
                        return rtValue;
                    } catch (Exception e) {
                        //5.回滚事务
                        transactionManager.rollbackTransaction();
                        throw new RuntimeException(e);
                    } finally {
                        //6.释放资源
                        transactionManager.releaseTransaction();
                    }
                }
           });
     }
  }

2. bean.xml的配置
    * 增加新的bean对象，beanFactory
    * 使用工厂的方法，创建代理类对象，由于代理类对象的数据类型和被代理对象的数据类型相同，在测试的时候需要对注入的数据进行指定</code></pre><p><img src="/2020/09/09/spring/proxy.png" alt="代理类对象的配置文件"></p>
<pre><code>3. 测试类</code></pre><p><img src="/2020/09/09/spring/proxy_test.png" alt="动态代理的测试类"></p>
<h3 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h3><pre><code>1. Aspect Oriented Programming:面向切面编程
    通过预编译和运行期动态代理的方式，实现程序功能的统一维护的一种技术。AOP是OOP编程的延续，是函数式编程的一种衍生泛型，可以使用AOP对业务逻辑进行隔离，降低程序之间的耦合性，提高代码的可重用率。

    简单来说，将重复的代码抽取出来，在需要使用的时候，通过动态代理的方式，在不修改源码的基础上，对已有的方法进行增强。

2. AOP的优势
    1. 作用
        * 在程序的运行期间不改变源码的基础上，对已有的方法进行增强

    2. 优势
        * 减少重复代码
        * 提高开发效率
        * 方便维护

3. 实现方式
    动态代理
    spring会根据是否实现了接口，动态的选择实现代理的方式

4. AOP的相关术语
    * Joinpoint(连接点)：
        所谓连接点是指那些被拦截到的点，在spring中，只支持对方法类型的连接点。
        （业务层接口中的所有方法），连接业务和增强方法的点

    * Pointcut(切入点)：
        被增强的方法，叫做切入点，我们对于哪些joinpoint方法进行增强的定义

    切入点都是连接点，但不是所有的连接点都是切入点

    * Advice(通知/增强):
        拦截到Joinpoint之后所作的事情叫做通知。
        通知的类型：
            前置通知，后置通知，异常通知，最后通知，环绕通知</code></pre><p><img src="/2020/09/09/spring/advice.png" alt="advice_types"></p>
<pre><code>    * Target(目标对象)：
        代理的目标对象，即被代理对象

    * Weaving(织入)：
        把增强应用到目标对象来创建新的代理对象的过程。
        spring采用动态代理技术进行织入

    * Proxy(代理)：
        一个类被AOP织入后，产生一个代理对象

    * Aspect(切面)：
        切入点和通知的结合，切入点和通知的有序组合
5. 明确
    1. 开发阶段：
        核心业务代码，大部分程序员
        把公共代码抽取出来，制作成通知（最后才做）
        在配置文件中，声明切入点和通知的关系，即切面，

    2. 运行阶段：
        spring框架监控切入点的执行，一旦检测到切入点方法正在执行，则立即使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理的对应位置，将通知的功能织入，完成代码的逻辑运行。</code></pre><h3 id="基于XML的AOP配置"><a href="#基于XML的AOP配置" class="headerlink" title="基于XML的AOP配置"></a>基于XML的AOP配置</h3><pre><code>1. 配置步骤
    1. 把通知的bean交给spring来管理（由spring来统一控制）
    2. 使用aop:config标签表明开始aop配置,开始配置
    3. 使用aop:aspect:配置切面
          id：给切面提供唯一属性
          ref:通知类的bean的id

    4. 在aop:aspect标签的内部使用对应的标签配置通知的类型
         现在的示例的通知类型是printlog方法在切入点的执行，为前置类型
            aop:before表示配置前置通知
                  method属性用于指定那个方法是前置通知

    5. pointcut属性：指定切入点表达式，该表达式的含义：对业务层的那些方法增强
        写法；关键字：execution(表达式)
          表达式：
              访问修饰符 返回值 包名.包名...类名.方法名（参数列表）
          标准表达式：
              execution(public void com.spring_AOP_xml.service.impl.AccountServiceImpl.saveAccount())</code></pre><p><img src="/2020/09/09/spring/xml_AOP.png" alt="XML配置AOP"></p>
<pre><code>2. 切入点表达式的化简
    1. 通配表达式写法：* *..*.*(..),所有包下的方法都被增强
    * 步骤
        public void com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        1. 访问修饰符可以省略：
            void com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        2. 返回值类型可以使用通配符*代替：
            * 
    com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        3. 包名可以使用*.来代替，有几级包，需要写几个 
            * *.*.*.*.IAccountServiceImpl.saveAccount()
            使用*..可以表示当前包和子包，代表所有的包
        4. 类名和方法名可以使用*来表示
            * *..*.*()
        5. 参数：
            基本数据类型：直接写类型  int
            引用数据类型: 包名.类名  java.lang.String
            可以使用*来代表有无参数
                * *..*.*()和* *..*.*(*)不一样
            可以使用 ..来表示有无参数
        所以：
            * *..*.*(..):表示对所有类上的所有方法都进行增强

    2. 开发中：对业务层上的所有方法都进行增强
        * com.spring_AOP_xml.service.impl.*.*(..)

    3. 通用切入点表达式简化最终版：
        aop:pointcut标签：写在&lt;aop:aspect&gt;标签内部，但只能在当前标签内部使用，也可以写在外部，所有切面都可以使用，此时必须出现在切面之前
            id 切入点的唯一表示 
            expression：指定表达式内容
          &lt;aop:pointcut id=&quot;pc1&quot; expression=&quot;execution(* com.spring_AOP_xml.service.impl.*.*(..))&quot;/&gt;

        使用方式：
            &lt;aop:after method=&quot;printLog&quot; pointcut-ref=&quot;pc1&quot;/&gt;

3. 通知的类型（advice）
    前置通知：切入点方法执行之前
    后置通知：切入点方法正常执行之后执行
    异常通知：切入点方法异常的时候执行
    最终通知：无论怎样都会执行

    后置通知和异常通知只会执行一个</code></pre><p><img src="/2020/09/09/spring/advice_types.png" alt="通知类型"></p>
<pre><code>环绕通知：
    * 问题：
        在配置环绕通知之后，业务层方法没有执行，环绕通知执行了
    * 分析：
        没有对切入点的方法的明确调用
    * 解决：
        spring提供了一个接口，ProceedingJoinPoint的方法中proceed(),明确切入点方法的调用，该方法可以传入环绕通知参数，在程序执行期间，spring框架会为我们创建实现类。</code></pre><p><img src="/2020/09/09/spring/around_advice.png" alt="aroundadvice"></p>
<pre><code>* 环绕通知是spring框架为我们提供的一种方式：可以手动控制增强代码执行的方式</code></pre><h3 id="基于注解的AOP配置"><a href="#基于注解的AOP配置" class="headerlink" title="基于注解的AOP配置"></a>基于注解的AOP配置</h3><pre><code>1. 加入context扫描
2. 配置注解产生对象
3. 改变增强类的信息，切面的方法
4. 在bean.xml中增加开启注解配置AOP的标签
    &lt;aop:aspectj-autoproxy/&gt;:有这个标签才使用注解配置AOP</code></pre><p><img src="/2020/09/09/spring/AOP_anno.png" alt="通知和切面类注解">    </p>
<h2 id="JdbcTemlate"><a href="#JdbcTemlate" class="headerlink" title="JdbcTemlate"></a>JdbcTemlate</h2><h3 id="spring中的JdbcTemplate"><a href="#spring中的JdbcTemplate" class="headerlink" title="spring中的JdbcTemplate"></a>spring中的JdbcTemplate</h3><pre><code>1. 概念    
    * spring框架的提供的一个对象，是对原始Java API的简单封装，spring为我们提供了很多操作模板类。
    * 操作关系型数据库：
    * 操作nosql数据库
    * 操作消息队列:

    使用的时候需要导入spring-jdbc-5.1.10.RELEASE.jar
                    spring-tx-5.1.10.RELEASE.jar(事务相关)

2. 作用
    * 用于和数据库进行交互的，实现数据的CRUD

3. 如果重复的代码过多
    可以抽取重复代码，形成父类，使AccountDaoImpl继承该父类，也可以实现Dao的实现类</code></pre><blockquote>
<p>   Dao的两种实现方式:<br><img src="/2020/09/09/spring/dao_xml.png" alt="dao的xml配置方式"><br><img src="/2020/09/09/spring/dao_anno.png" alt="dao的annotation配置方式"></p>
</blockquote>
<h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h2><h3 id="spring的事务"><a href="#spring的事务" class="headerlink" title="spring的事务"></a>spring的事务</h3><pre><code>1. 明确
    * Java EE体系进行开发，事务处理位于业务层，spring提供分层设计业务层的事务处理方法
    * spring框架为我们提供一组事务控制的接口，位于spring-tx-5.1.10.RELEASE.jar
    * spring的事务控制基于AOP的，可以使用配置的控制和编程，主要使用配置事务

2. 事务API
    * platformTransactionManager</code></pre><h3 id="基于xml的事务控制"><a href="#基于xml的事务控制" class="headerlink" title="基于xml的事务控制"></a>基于xml的事务控制</h3><pre><code>1. 使用
    1. 配置事务管理器（DataSourceTransactionManager）
    2. 配置事务通知(tx:advice)
          此时需要导入事务的约束,tx的名称约束，同时也需要aop的支持
          使用tx:advice配置事务通知 
            id:唯一标志 
            transaction-manager:提供事务管理器使用
    3. 配置aop的通用切入点表达式
    4. 建立事务通知和切入点表达式的关联
    5. 配置事务的属性：事务的通知tx:advice的内部
        * isolation: 指定事务的隔离级别，默认值式DEFAULT,
        * propagation: 事务的传播行为REQUESTED 表示一定会有事务，增删改的选择，查询可以选择SUPPORTS
        * read-only: 事务是否只读，默认为false
        * time-out: 事务的超时时间,默认-1，表示永不超时，如果指定，以秒为单位
        * rollback-for: 指定一个异常，当产生该异常时，事务回滚，产生其他异常，事务不回滚，没有默认值，表示任何异常都会回滚
        * no-rollback-for：指定一个异常，当产生该异常时，事务不回滚，产生其他异常，事务回滚，没有默认值，表示任何异常都会回滚

2. 使用实例</code></pre><p><img src="/2020/09/09/spring/tran_xml.png" alt="基于xml的声明式事务"></p>
<h3 id="基于注解的事务配置"><a href="#基于注解的事务配置" class="headerlink" title="基于注解的事务配置"></a>基于注解的事务配置</h3><pre><code>1. 步骤
    1. 配置事务管理器（DataSourceTransactionManager）
    2. 开启spring对注解事务的支持（tx:annotation-driven）
    3. 使用注解@transactional对需要事务的地方进行定义
        xml中的事务属性，均可以在@Transactional的属性中配置

    如果查询和增删改的方法数量差不多，需要对增删改的方法单独配置事务支持

2. 实例</code></pre><p><img src="/2020/09/09/spring/tran_anno.png" alt="基于注解的声明式事务"></p>
<h3 id="使用纯注解的事务配置"><a href="#使用纯注解的事务配置" class="headerlink" title="使用纯注解的事务配置"></a>使用纯注解的事务配置</h3><p><img src="/2020/09/09/spring/tx_without_xml.png" alt="纯注解的声明式事务"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springMVC</title>
    <url>/2020/09/18/springMVC/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛云_Hexo</title>
    <url>/2020/05/12/%E4%B8%83%E7%89%9B%E4%BA%91-Hexo/</url>
    <content><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><pre><code>1. 注册七牛云,完成之后就可以进行创建空间，
2. 注意我们添加的资源为对象存储，访问控制为公开空间
3. 点击右上角进入密钥管理，复制当前使用的AK和SK，配置的时候会用得到</code></pre><h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h2><h3 id="2-1-安装插件，进入Hexo主目录，执行："><a href="#2-1-安装插件，进入Hexo主目录，执行：" class="headerlink" title="2.1. 安装插件，进入Hexo主目录，执行："></a>2.1. 安装插件，进入Hexo主目录，执行：</h3><pre><code>`npm install hexo-qiniu-sync --save`</code></pre><h3 id="2-2-配置站点文件-config-yml"><a href="#2-2-配置站点文件-config-yml" class="headerlink" title="2.2. 配置站点文件_config.yml:"></a>2.2. 配置站点文件_config.yml:</h3><blockquote>
<p>  #plugins:<br>      #- hexo-qiniu-sync<br>    qiniu:<br>      offline: false<br>      sync: true<br>      bucket: bucket_name<br>      access_key: AccessKey<br>      secret_key: SecretKey<br>      dirPrefix:<br>      urlPrefix: <a href="http://7xqb0u.com1.z0.glb.clouddn.com" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com</a><br>      local_dir: cdn<br>      update_exist: true<br>      image:<br>        folder: images<br>        extend:<br>      js:<br>        folder: js<br>      css:<br>        folder: css</p>
</blockquote>
<h3 id="2-3-参数"><a href="#2-3-参数" class="headerlink" title="2.3. 参数"></a>2.3. 参数</h3><ul>
<li><p>bucket ：修改为你刚才申请的七牛空间名称</p>
</li>
<li><p>access_key 、 secret_key : 上传密钥AccessKey、SecretKey。即3 第3步复制的AK和SK。</p>
</li>
<li><p>urlPrefix : 七牛空间地址的前缀。 重要！必填！ 因为现在七牛已经取消了二级域名，外链前缀类似设置中的 <a href="http://7xqb0u.com1.z0.glb.clouddn.com" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com</a> ，插件不能根据 bucket 自动生成外链前缀了。你可以进入自己创建的空间在域名设置中看到自己的七牛测试域名，也可以查看一个已上传的文件外链地址，确认前缀无误。这个参数的设置是保证解析成网页文件时，外链地址正确的关键之一！<br>  配置参数的说明：</p>
</li>
<li><p>offline ：是否离线。设置为 true 将在本地预览时使用本地地址渲染，省流量； false 将使用同步到七牛空间的静态资源渲染，方便检查资源链接是否正确。</p>
</li>
<li><p>sync ：是否同步到七牛，一般都是设置 true 啦</p>
</li>
<li><p>dirPrefix ：资源将上传到七牛空间的此目录下，可像我一样设置为空。该参数会影响外链的地址，如果设置为非空值，例如默认值 static ，则 urlPrefix 为保持一致需加上目录后缀 /static ，改为 <a href="http://7xqb0u.com1.z0.glb.clouddn.com/static" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com/static</a> 。</p>
</li>
<li><p>local_dir ：本地资源储存目录。在本例中，待上传的资源都储存在hexo主目录中的 cdn 文件夹（也就是与 source 目录平级）中。</p>
</li>
<li><p>update_exist ：设置为 true ，则会在文件更新之后重新上传并更新七牛空间上中的原有文件。</p>
</li>
<li><p>image/js/css ：子参数folder为不同静态资源种类的目录名称，一般不需要改动</p>
</li>
<li><p>image.extend ：使用 qnimg 标签引用图片的默认图片处理操作。可以使用 基本图片处理（imageView2）、高级图片处理（imageMogr2）、图片水印处理（watermark） 这三个图片处理接口，多个接口内容之间用 | 间隔。详见 七牛开发者中心-图片处理。</p>
</li>
</ul>
<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><pre><code>1.将图片上传到七牛云，查看照片获取照片的外链
2.在文章中引用照片外链，markdown格式:*![描述]（外链）*</code></pre><h2 id="4-感谢在使用七牛云时参考的大佬博客："><a href="#4-感谢在使用七牛云时参考的大佬博客：" class="headerlink" title="4. 感谢在使用七牛云时参考的大佬博客："></a>4. 感谢在使用七牛云时参考的大佬博客：</h2><ul>
<li><a href="http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/" target="_blank" rel="noopener">http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>序/README</title>
    <url>/2020/10/12/readme/</url>
    <content><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><h3 id="个人经历"><a href="#个人经历" class="headerlink" title="个人经历"></a>个人经历</h3><pre><code>大学四年，碌碌无为，回首大学四年的学习生涯，一无是处。
人生最美好的四年，没有找到自己的人生方向，随风摇摆，没有方向
在大学的最后一段时间，找到了的自己的人生方向，可以算是人生目标
知道了不是每个人都有各自的使命与责任，方向最重要，认清自己

提升自己，找到一份工作，孝顺父母，相信自己，可以活得更好
2020/10/12 20:53:03 </code></pre><h3 id="学习历程"><a href="#学习历程" class="headerlink" title="学习历程"></a>学习历程</h3><pre><code>1. 2020-9-1 2020-10-12，学习java的框架使用</code></pre>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>ssm_error</title>
    <url>/2020/10/16/ssm-error/</url>
    <content><![CDATA[<h3 id="dao接口不匹配"><a href="#dao接口不匹配" class="headerlink" title="dao接口不匹配"></a>dao接口不匹配</h3><p><code>BindingException: Invalid bound statement (not found): com.maven.dao.ItemsDao.findAll</code></p>
<pre><code>1. 问题
    dao的接口与映射配置文件的绑定失败

2. 解决思路
    1. 检查dao的方法名与mapper.xml的方法id是否一致
    2. 检查mapper.xml的namaspace是否为dao接口的全限定类名
    3. 检查mapper.xml的resultMapper,parameterType是否正确
    4. 检查是否出现拼写错误
    5. 检查mapper.xml的路径是否出现错误
    6. 检查dao的类名和mapper.xml的名称是否一致，不一致，也有可能导致错误</code></pre><p><em>接口名和映射配置文件名称应该一致，在ssm框架中</em></p>
<pre><code>3. 对applicationContext.xml进行改变
    * 在sqlSessionFactoryBean的prperty属性
    * 找到mapperLocations的标签内部
    * 增加list标签
    * 增加value标签，将mapper.xml配置文件全部加入</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/16/ssm-error/error_1_1.png" alt></p>
<pre><code>4. 检查target文件夹下是否有.xml文件
    没有文件</code></pre><p><code>&lt;build&gt;
&lt;resources&gt;
&lt;resource&gt;
&lt;directory&gt;src/main/java&lt;/directory&gt;
&lt;includes&gt;
&lt;include&gt;**/*.xml&lt;/include&gt;
&lt;/includes&gt;
&lt;filtering&gt;true&lt;/filtering&gt;
&lt;/resource&gt;
&lt;/resources&gt;
&lt;/build&gt;</code></p>
<pre><code>5. 解决</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/16/ssm-error/error_1.png" alt></p>
<pre><code>6. 总结
    1. 如果在applicationContext.xml文件中没有指定具体的配置文件位置，应该回到对应的资源目录下的对应路径下寻找和dao名称相同的.xml文件，将.xml的文件名指定为dao的接口名称就可以进行绑定
    2. 如果在核心配置文件中指定了配置文件的位置，不需要dao的接口名称和mapper配置文件的名称相匹配，也可以扫描的具体的配置文件，完成代理对象的创建
    3. 如果.xml文件不是存放在资源路径下，需要对其进行设置，在pom.xml文件中进行设置</code></pre>]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2020/10/12/mysql/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>* 针对数据库查询的延伸学习
* 强化数据库操作
* 学习更好的使用MySQL数据库，提高效率</code></pre><ul>
<li><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">mysql官网下载</a></li>
<li><a href="https://print3306.github.io/2020/06/18/mysql57/">Windows版下载安装</a></li>
<li><a href="https://jingyan.baidu.com/article/48b558e382811d3f39c09a77.html" target="_blank" rel="noopener">Linux版安装</a></li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="Index说明"><a href="#Index说明" class="headerlink" title="Index说明"></a>Index说明</h3><pre><code>1. 索引的含义
    索引（Index）是帮助MySQL高效获取数据（查询）的一种数据结构。
    在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向（或引用）数据，这样就可以在这些数据结构上使用高级查找算法，提高查询效率，这种数据结构就是索引。

2. 特点
    * 用来提高查询效率的指向数据的数据结构
    * 满足特定查找算法
    * 可以使用高级查找算法进行数据查询

3. 索引的使用
    1. 没有索引
        查询数据需要全表扫描，最差的情况扫描n次，效率极低

    2. 使用索引
        根据查找数据的特点，建立数据结构，可以使用顺序表，二叉树等，来查询数值型数据</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/index.png" alt></p>
<h3 id="Index的优势和劣势"><a href="#Index的优势和劣势" class="headerlink" title="Index的优势和劣势"></a>Index的优势和劣势</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><pre><code>1. 类似于书籍的目录索引，提高数据的检索效率，降低数据库的IO成本
2. 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</code></pre><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><pre><code>1. 索引本身需要开销，索引本身也是一张表，该表保存了主键和索引字段，并指向实体类的记录（一般保存在磁盘文件）
2. 索引降低了数据更新表的速度（Update，Delete,Insert）,在数据更新之后，索引表也需要进行维护，需要调整因为更新带来的键值变化后的索引信息</code></pre><h3 id="Index的结构"><a href="#Index的结构" class="headerlink" title="Index的结构"></a>Index的结构</h3><pre><code>索引是在MySQL的存储引擎层中实现的，不是在服务器层实现的，所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持索引。</code></pre><h4 id="主流的索引（4种）"><a href="#主流的索引（4种）" class="headerlink" title="主流的索引（4种）"></a>主流的索引（4种）</h4><pre><code>1. BTree (B+树) : 最常见的索引类型，大部分的索引引擎都支持BTree类型的索引
2. Hash ：只有Memory引擎支持，使用场景简单
3. R-tree(空间索引) ：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型
4. Full-text(全文索引) ：全文索引也是MyISAM引擎的一个特殊索引类型，
主要用于全文索引，InnoBD引擎从MySQL5.6版本开始支持Full-text索引</code></pre><blockquote>
<p><strong>MyISAM,InnoDB,Memory三种存储引擎对于各种索引类型的支持</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">索引</th>
<th align="center">InnoDB引擎</th>
<th align="center">Memery引擎</th>
<th align="center">MyISAM引擎</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BTree</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">Hash</td>
<td align="center">不支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">R-tree</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">Full-text</td>
<td align="center">5.6以后支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<pre><code>我们平常所说的索引一般都是指B+树，多路搜索树，其中聚集索引，复合索引，前缀索引，
唯一索引默认使用的都是B+树，统称为索引    </code></pre><h4 id="BTree结构"><a href="#BTree结构" class="headerlink" title="BTree结构"></a>BTree结构</h4><pre><code>默认InnoDB存储引擎所支持的索引结构主要就是：BTree

1. BTree的特点
    BTree又叫做多路平衡搜索树，一颗m叉的BTree特性如下:
        * 树的每个节点的最多包含m个孩子
        * 除根结点与叶子节点之外，每个节点至少有[ceil(m / 2)]个孩子:ceil向上取整
        * 若根节点不是叶子节点，至少有两个孩子
        * 所有的叶子节点都在同一层
        * 每个非叶子节点有n个key与n+1个指针组成，其中[ceil(m / 2) - 1] &lt;= n &lt;= m-1

2. BTree实例
    以一个5叉的b树为例，可以由公式推导出，key的取值，ceil(5 / 2 - 1) = 2 &lt;= n 
    &lt;= 5-1 = 4,所以每个非叶子节点的key的取值为[2,4],
    当n&gt;4时，中间节点分裂到父结点，两边节点分裂

1. 以插入CNGA HEKQ MFWL TZDP RXYS字符串为例</code></pre><ul>
<li>插入前四个字母:CNGA</li>
</ul>
<p><img src="/2020/10/12/mysql/BTree_5_1.png" alt="CNGA">    </p>
<ul>
<li>插入H， n &gt; 4</li>
</ul>
<p><img src="/2020/10/12/mysql/BTree_5_2.png" alt="CNGAH"></p>
<ul>
<li>插入E,K,Q，此时没有节点的key到达4，整体结构不变</li>
</ul>
<p><img src="/2020/10/12/mysql/BTree_5_3_2.png" alt="CNGAHEKQ"></p>
<ul>
<li>插入M,M分裂到父结点</li>
</ul>
<p><img src="/2020/10/12/mysql/BTree_5_4.png" alt="CNGAHEKQM"></p>
<ul>
<li>插入F,W,L,T,结构不变</li>
</ul>
<p><img src="/2020/10/12/mysql/BTree_5_5.png" alt="CNGAHEKQMFWLT"></p>
<ul>
<li>插入Z,T变为父结点</li>
</ul>
<p><img src="/2020/10/12/mysql/BTree_5_6.png" alt="CNGAHEKQMFWLTZ"></p>
<ul>
<li>插入D,D变为父结点</li>
</ul>
<p><img src="/2020/10/12/mysql/BTree_5_7.png" alt="CNGAHEKQMFWLTZD"></p>
<ul>
<li>插入P，R，X，Y结构不变</li>
</ul>
<p><img src="/2020/10/12/mysql/BTree_5_8.png" alt="CNGAHEKQMFWLTZDPRXY"></p>
<ul>
<li>插入S,需要分隔两次父结点</li>
</ul>
<p><img src="/2020/10/12/mysql/BTree_5_9.png" alt="CNGAHEKQMFWLTZDPRXYS"></p>
<h4 id="B-Tree的结构"><a href="#B-Tree的结构" class="headerlink" title="B+Tree的结构"></a>B+Tree的结构</h4><pre><code>B+Tree是BTree的变种，B+Tree和BTree的区别：
    * n叉B+Tree最多有n个key，而BTree最多有n-1个key
    * B+Tree的叶子节点保存所有的key信息，根据key的大小排序
    * 所有非叶子节点都可以看做key的索引部分

1. 由于B+Tree的所有key信息保存在叶子节点中,查询任何数据都需要经过root到叶子节点，B+Tree的查询效率更加稳定
2. 为了减少磁盘I/O操作，磁盘并不是每次需要才去读取，而是会进行预读取。在预读取的过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。
3. 数据库系统将索引的一个节点的大小，使得一次I/O就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能被预先载入

使用B+Tree的好处，可以充分利用操作系统的文件系统，减少磁盘IO操作</code></pre><h4 id="MySQL中的BTree"><a href="#MySQL中的BTree" class="headerlink" title="MySQL中的BTree"></a>MySQL中的BTree</h4><pre><code>MySQL中的BTree实际上指的是B+Tree，但是在B+Tree树的基础上进行了优化，增加了一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高了区间访问的性能。

1. 为什么改进的B+Tree能提高区间访问的能力？
    由于在叶子节点上增加了指向相邻节点的链表指针，数据区间查询的时候，可以通过指针查找到所有数据，不需要通过root节点向下进行查找</code></pre><h3 id="Index的分类"><a href="#Index的分类" class="headerlink" title="Index的分类"></a>Index的分类</h3><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><pre><code>1. 单值索引：索引只包含单个列，一个表可以包括多个单值索引
2. 唯一索引：索引列的值必须唯一，但允许有空值（包括多个空值）
3. 复合索引：一个索引包含多个列</code></pre><h4 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h4><pre><code>索引可以在创建表的时候创建，也可以随时增加新的索引。</code></pre><h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><pre><code>1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>|fulltext|spatial] <span class="keyword">index</span> index_name</span><br><span class="line">[<span class="keyword">using</span> index_type]</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">table</span>(index_col_name...);</span><br><span class="line">index_col_name : column_name[(length)][desc|asc]</span><br><span class="line">案例：在名称上建立索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_city_name <span class="keyword">on</span> city(city_name);</span><br></pre></td></tr></table></figure>

<h5 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h5><pre><code>1. 语法</code></pre><p><code>show index from city;</code></p>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/index_show.png" alt></p>
<pre><code>没有指定建立索引的类型，InnoDB引擎默认使用BTree索引类型</code></pre><h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><pre><code>1. 语法</code></pre><p><code>drop index idx_city_name on city;</code></p>
<h5 id="ALTER命令"><a href="#ALTER命令" class="headerlink" title="ALTER命令"></a>ALTER命令</h5><pre><code>1. 使用
    可以在使用ALter修改表结构的时候，修改索引</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> primary <span class="keyword">key</span>(column_list); </span><br><span class="line">添加主键，索引值唯一，不能为null,自动添加索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> <span class="keyword">unique</span> index_name(column_list);</span><br><span class="line">添加唯一索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> <span class="keyword">index</span> index_name(column_list);</span><br><span class="line">添加普通索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_name <span class="keyword">add</span> fulltext index_name(column_list);</span><br><span class="line">添加全文索引</span><br></pre></td></tr></table></figure>

<h3 id="Index设计原则"><a href="#Index设计原则" class="headerlink" title="Index设计原则"></a>Index设计原则</h3><pre><code>1. 设计原则
    * 查询频次高，而且数据量比较大的表
    * 查询条件，索引字段的选择，最佳候选列应该从where子句中出现的条件选择
    * 使用唯一索引，区分度高，使用索引的效率越高
    * 索引的数量不是越多越好，在更新的时候，需要维护索引
    * 尽量使用短索引，索引创建完成之后，需要保存在磁盘文件中，使用短索引可以提升磁盘IO
    的效率，给定大小的存储块中可以存储更多的索引值
    * 利用最左前缀，N个列组合而成的组合索引，相当于创建了N个索引，如果查询时where使用
    了组合索引的某个前缀，这个查询条件可以利用组合索引来提高效率</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">创建复合索引</span><br><span class="line">	<span class="keyword">create</span> <span class="keyword">index</span> idx_name_email_status <span class="keyword">on</span> city(<span class="keyword">name</span>,email,<span class="keyword">status</span>);</span><br><span class="line">就相当于：</span><br><span class="line">	对name 创建索引</span><br><span class="line">	对name email 创建索引</span><br><span class="line">	对name email status 创建索引</span><br></pre></td></tr></table></figure>

<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="视图概述"><a href="#视图概述" class="headerlink" title="视图概述"></a>视图概述</h3><pre><code>1. 什么是视图？
    视图（View）是一种虚拟存在的表，视图并不真实的存在于数据库中，行和列的数据来自于
定义视图的语句动态生成。通俗的讲，视图就是一条select语句执行后返回的结果集，所以创建
视图的时候，主要工作就在于创建这一条SQL语句。

2. 使用视图的优势
    * 简单：使用视图的用户不需要关注表的关联条件，筛选条件，是过滤好的值
    * 安全：使用视图的用户看到的值是允许访问的部分，将表的权限锁定在某一行某一列
    * 数据独立：一旦视图的结构确定，用户无法感知到实体表的变化情况，屏蔽了表的变化</code></pre><h3 id="创建或修改视图"><a href="#创建或修改视图" class="headerlink" title="创建或修改视图"></a>创建或修改视图</h3><pre><code>1. 创建视图的语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> <span class="keyword">replace</span>] [algorithm = &#123;undefined,<span class="keyword">merge</span>,temptable&#125;]</span><br><span class="line"><span class="keyword">view</span> view_name</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line">[<span class="keyword">with</span> [<span class="keyword">cascade</span> | <span class="keyword">local</span>] <span class="keyword">check</span> <span class="keyword">option</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/view_create.png" alt></p>
<pre><code>2. 更新视图
    可以按照使用实体表的方法使用视图，在更新视图的时候，实际上是更新的实体表</code></pre><p><code>update view_city_country set city_name=&#39;gg&#39; where country_name=&#39;中国&#39;</code>    </p>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/view_update.png" alt></p>
<pre><code>是否可以更新视图还取决于，
    [with [cascade | local] check option]

    * local: 只要满足本视图的条件就可以更新
    * cascade: 必须满足针对该视图的所有条件才能进行更新（默认值）

虽然可以更新视图，但是不建议更新，需要更新，可以直接更新实体表    

3. 修改视图</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> [algorithm = &#123;undefined,<span class="keyword">merge</span>,temptable&#125;]</span><br><span class="line"><span class="keyword">view</span> view_name</span><br><span class="line"><span class="keyword">as</span> select_statement</span><br><span class="line">[<span class="keyword">with</span> [<span class="keyword">cascade</span> | <span class="keyword">local</span>] <span class="keyword">check</span> <span class="keyword">option</span>]</span><br></pre></td></tr></table></figure>

<h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><pre><code>1. 查看视图</code></pre><p>在MySQL中，视图也是表的一种，可以使用<code>show tables;</code>进行查看</p>
<pre><code>2. 查看创建视图的语句</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> view_city_country;</span><br></pre></td></tr></table></figure>

<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> [<span class="keyword">if</span> <span class="keyword">exists</span>] view_name [,view_name] ... [restrict | <span class="keyword">cascade</span>];</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> view_city_country;</span><br></pre></td></tr></table></figure>

<h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><h3 id="存储过程和函数概述"><a href="#存储过程和函数概述" class="headerlink" title="存储过程和函数概述"></a>存储过程和函数概述</h3><pre><code> 存储过程和函数是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程和函数可
以简化开发人员的工作，减少数据在数据库和应用之间的传输，有利于提高数据处理的效率

存储过程和函数的区别：函数必须要有返回值，存储过程没有返回值
    函数：有返回值的过程
    过程：没有返回值的函数</code></pre><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><pre><code>1. 语法
    SQL语句默认的分隔符为分号，使用存储过程需要改变默认分隔符
    DELIMITER:声明分割符，默认为分号</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $;	声明$为分隔符</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> procedure_name([params])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">-- sql语句</span></span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure>
<pre><code>2. 案例</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER ^</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pro_test4()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> country;</span><br><span class="line"><span class="keyword">END</span>^</span><br></pre></td></tr></table></figure>

<h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><pre><code>语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> procedure_name() ;</span><br></pre></td></tr></table></figure>

<h3 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h3><pre><code>1. 使用数据库查询语句</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">form</span> mysql.proc <span class="keyword">where</span> db = <span class="string">'db_name'</span>;</span><br><span class="line">db_name : 查询的数据库的名称</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/pro_1.png" alt></p>
<pre><code>2. 查询存储过程的状态</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查询存储过程，以格式化的方式进行展示</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> <span class="keyword">status</span>\G;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/pro_2.png" alt></p>
<pre><code>3. 查询某个存储过程的定义</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> test.pro\G;</span><br></pre></td></tr></table></figure>

<h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> pro_name;</span><br></pre></td></tr></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>declare: 声明</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> var_name[,...] <span class="keyword">type</span> [<span class="keyword">default</span> <span class="keyword">value</span>];</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">sum</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">sum</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<ul>
<li>set : 赋值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> var_name = <span class="keyword">exp</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>select .. into …</p>
<p>  将查询的结果赋值给变量</p>
</li>
<li><p>ps:</p>
<ol>
<li>使用@修饰的变量，叫做会话变量，连接关闭，变量失效，类似于全局变量</li>
<li>使用@@修饰的变量，叫做系统变量</li>
<li>在存储过程中的变量，不需要修饰符进行修饰，普通变量；在外部使用的变量，一般使用@修饰，全局变量</li>
</ol>
</li>
</ul>
<h4 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h4><pre><code>1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 条件判断语句</span><br><span class="line">if serach_condition then statement_list</span><br><span class="line">[,elseif search_condition then statement_list]</span><br><span class="line">[else statement_list]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br></pre></td></tr></table></figure>

<pre><code>2. 使用案例</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/pro_3.png" alt="案例if"></p>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><pre><code>1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> proc_name(<span class="keyword">in</span>/<span class="keyword">out</span>/inout 参数名 参数类型)</span><br><span class="line"><span class="keyword">in</span> ： 该参数作为输入参数，在调用的时候传入，默认</span><br><span class="line"><span class="keyword">out</span> : 输出参数，该参数可以作为返回值</span><br><span class="line">inout : 可以作为输入参数，也可以作为输出参数</span><br></pre></td></tr></table></figure>

<h4 id="case语法"><a href="#case语法" class="headerlink" title="case语法"></a>case语法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 方式一 : 表达式满足某种条件</span><br><span class="line">case</span><br><span class="line">	when exp1 then state1;</span><br><span class="line">	when exp2 then state2;</span><br><span class="line">	else staten;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line">// 方式二 ：情况匹配</span><br><span class="line">case exp</span><br><span class="line">	when wnen_1 then state1;</span><br><span class="line">	when when_2 then state2;</span><br><span class="line">	else staten;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure>

<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><pre><code>1. 语法
    先判断，条件成立，循环开始执行，最少执行了0次</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">while search_condition <span class="keyword">do</span></span><br><span class="line">	statement_list</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br></pre></td></tr></table></figure>

<pre><code>2. 案例</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_while2(n <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">num</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">	while num&lt;=n do</span><br><span class="line">		<span class="keyword">set</span> total = total + <span class="keyword">num</span>;</span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">num</span> = <span class="keyword">num</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">	<span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure>

<h5 id="repeat循环"><a href="#repeat循环" class="headerlink" title="repeat循环"></a>repeat循环</h5><pre><code>1. 语法
    满足条件，退出循环, 条件之后不需要增加分号</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 执行循环体，直到条件满足，退出循环</span><br><span class="line">repeat </span><br><span class="line">	statement_list</span><br><span class="line">until search_condition</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">repeat</span>$</span><br></pre></td></tr></table></figure>

<pre><code>2. 案例</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_repeat(n <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	repeat</span><br><span class="line">		<span class="keyword">set</span> total = total + n;</span><br><span class="line">		<span class="keyword">set</span> n = n - <span class="number">1</span>;</span><br><span class="line">	until n = 0</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line">	<span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure>

<h5 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h5><pre><code>1. 语法
    一般退出语句需要使用leave语句来进行实现，如果不退出，直接死循环</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">start_label loop</span><br><span class="line">	statement_condition</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span> [start_label];</span><br></pre></td></tr></table></figure>

<h4 id="leave语句"><a href="#leave语句" class="headerlink" title="leave语句"></a>leave语句</h4><pre><code>在loop语句执行的时候，可以使用leave进行退出循环</code></pre><h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><pre><code>游标是用来存储查询结果集的数据类型，在存储过程和函数中使用游标对结果集进行循环的处理，游标的使用包括游标的声明，open，fetch, close

1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 声明游标，游标的位置在查询结果集的第一行数据</span><br><span class="line"><span class="keyword">declare</span> cursor_name <span class="keyword">cursor</span> <span class="keyword">for</span> select_statement;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// open : 打开游标</span><br><span class="line">open cursor_name;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// fetch : 游标推进一次</span><br><span class="line">fetch cursor_name into var_name[,var_name];</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// colse</span><br><span class="line">close cuesor_name;</span><br></pre></td></tr></table></figure>

<pre><code>2. 使用循环退出
    * MySQL提供了句柄机制，一旦触发句柄，可以改变变量的值，在循环中判断变量的值，可以完成循环
    * 使用句柄，可以方便的控制结果集的输出，只需要在声明游标的时候同时声明handler</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> cursor_name <span class="keyword">cursor</span> <span class="keyword">for</span> select_statement;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">exit</span> <span class="keyword">handler</span> <span class="keyword">for</span> <span class="keyword">not</span> <span class="keyword">found</span> <span class="keyword">set</span> <span class="keyword">var</span> = var_value;</span><br><span class="line">// 句柄的定义和游标的定义在一起</span><br></pre></td></tr></table></figure>

<pre><code>3. 游标使用案例</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro10()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">-- 声明变量</span></span><br><span class="line">	<span class="keyword">declare</span> flag <span class="built_in">int</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="keyword">declare</span> cid <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line">	<span class="comment">-- 声明游标和句柄</span></span><br><span class="line">    <span class="keyword">declare</span> city_result <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> city;</span><br><span class="line">    <span class="keyword">declare</span> continue <span class="keyword">handler</span> <span class="keyword">for</span> <span class="keyword">not</span> <span class="keyword">found</span> <span class="keyword">set</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">-- 打开游标</span></span><br><span class="line">    open city_result;</span><br><span class="line">	<span class="comment">-- 推进游标</span></span><br><span class="line">    fetch city_result into id,name,cid;</span><br><span class="line">	<span class="comment">-- 循环推进游标</span></span><br><span class="line">    while(not flag) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'id='</span>,<span class="keyword">id</span>,<span class="string">'name='</span>,<span class="keyword">name</span>,<span class="string">'cid='</span>,cid);</span><br><span class="line">        fetch city_result into id,name,cid;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">	<span class="comment">-- 关闭游标</span></span><br><span class="line">    close city_result;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/cursor_1.png" alt="游标"></p>
<pre><code>4. 说明
    * 游标最好配合句柄一起使用，这样就不需要在单独查询数据条数，进行循环语句的判断
    * 可以根据不同的循环条件，对游标的具体推进做出调整</code></pre><h4 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h4><pre><code>有返回值的存储过程（存储过程也可以返回值，out参数类型）

1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> function_name([params])</span><br><span class="line"><span class="keyword">returns</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<pre><code>2. 案例
    定义函数，满足某种条件的记录数：</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delemiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fn1(countryid <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">num</span> <span class="built_in">int</span>;</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> <span class="keyword">num</span> <span class="keyword">from</span> city <span class="keyword">where</span> country_id = countryid;</span><br><span class="line">	return num;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure>

<pre><code>3. 调用函数
    * 使用select来调用函数
    * 函数相当于一个表达式，使用select来调用函数</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/fun_1.png" alt></p>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><pre><code>触发器（trigger）是与表有关的数据库对象，指在insert/update/delete之前或之后，触发并执行触发器中定义的SQL语句集合，
 * 确保数据的完整性
 * 记录日志， 在进行操作之前，生成记录，保存在日志文件中
 * 数据校验，使用触发器在操作之前进行数据校验，保证数据安全

1. 使用别名OLD和NEW来引用触发器中发生变化的记录内容，现在MySQL数据库，触发器只支持行级触发，不支持语句级触发。
2. OLD和NEW的使用</code></pre><table>
<thead>
<tr>
<th align="center">触发器类型</th>
<th align="center">NEW和OLD的使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">insert型</td>
<td align="center">NEW表示将要或已经插入的数据</td>
</tr>
<tr>
<td align="center">update型</td>
<td align="center">NEW表示将要修改或者修改后的数据，OLD表示修改之前的数据</td>
</tr>
<tr>
<td align="center">delete型</td>
<td align="center">OLD表示将要或者已经删除的数据</td>
</tr>
</tbody></table>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><pre><code>1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name </span><br><span class="line"><span class="keyword">before</span>|<span class="keyword">after</span> <span class="keyword">insert</span>|<span class="keyword">update</span>|<span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> table_name</span><br><span class="line">[<span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span>] <span class="comment">-- 行级触发器</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">-- SQL</span></span><br><span class="line"><span class="keyword">end</span>;```  </span><br><span class="line"></span><br><span class="line">	2. 案例</span><br><span class="line">		在插入数据进入city之后，将名称存入country表</span><br><span class="line">```sql</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_insert_city</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> city</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> country <span class="keyword">values</span>(<span class="literal">null</span>,new.city_name);</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure>

<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><pre><code>1. 语法</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看触发器</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">triggers</span>\G;</span><br><span class="line"><span class="comment">-- 删除触发器</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> [schema_name.]trigger_name; </span><br><span class="line"><span class="comment">-- 默认删除当前数据库的指定触发器</span></span><br></pre></td></tr></table></figure>

<h2 id="MySQL的体系结构"><a href="#MySQL的体系结构" class="headerlink" title="MySQL的体系结构"></a>MySQL的体系结构</h2><h3 id="MySQL的体系结构-1"><a href="#MySQL的体系结构-1" class="headerlink" title="MySQL的体系结构"></a>MySQL的体系结构</h3><pre><code>1. 组成部分
    整个MySQL Server有以下几个部分组成：
    1. 连接层：接受客户端的连接请求，用户认证
        包括安全认证，权限检测
        * Connection Pool
    2. 服务层：各种服务组件，完成核心功能
        * Manegement Server: 管理组件，包括备份，恢复。。
        * SQL interface：SQL语句接口，可以定义DML,DDL,Procedure
        * Parser: 解析器，解析SQL语句
        * Optimizer：优化器，
        * Caches：缓存
    3. 存储引擎：
        InnoDB,Memery,Merge...
        选择合适的存储引擎存储数据
    4. 文件系统层
        最终的文件需要存储在磁盘内部，包括数据信息和各种日志信息

2. 各个层次的作用
    1. 连接层
        * 包含本地sock通信和大多数基于客户端/服务器模式工具实现的类似TCP/IP的通信。
        * 主要完成类似于连接处理，授权认证，相关的安全方案。
        * 在连接层引入了连接池的概念，为通过认证安全的连接提供线程，可以实现基于SSL的安全链接，服务器也会为安全链接的用户验证权限。

    2. 服务层
        * 主要完成数据库的核心功能，SQL接口，缓存，SQL的分析和优化，内置函数的执行。
        * 所有的跨存储引擎的功能也是在这一层实现，比如过程和函数，在服务层，服务器会解析查询并创建相应的内部解析树，并对其完成特定的优化比如确定表的查询顺序，是否利用索引等，最后生成相应的执行操作。
        * 如果是select语句，还会查询缓存。

    3. 存储引擎层
        * 真正负责MySQL数据的存储和查询，服务器通过API和存储引擎进行通信
        * 不同的存储引擎具有不同的功能

    4. 文件系统层
        * 将数据存储在文件系统之上，和文件系统进行交互

MySQL最多的特点：
    插件式的存储引擎结构，如果存储引擎的性能达不到要求可以进行改变存储引擎</code></pre><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>存储引擎就是存储数据，建立索引，更新查询数据等技术的实现。</li>
<li>存储引擎是基于表的，而不是基于库的，存储引擎也称为表类型,可以在表的建立时指定存储引擎</li>
<li>其他数据库oracle，SQL Server只支持一种存储引擎，MySQL支持可拔插的存储引擎架构，可以根据需要选择存储引擎</li>
<li>MySQL支持的存储引擎包括：InnoDB,MyISAM,Memoey,CSV,BDB,Merge等，InnoDB，BDB支持事务安全，其中InnoDB是默认的存储引擎（5.5版本之后）</li>
</ul>
<p>可以使用<code>show engines</code>来展示存储引擎,也可以使用<code>show variables like &#39;%storage_engines&#39;</code>来查看存储引擎</p>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/engines_1.png" alt></p>
<h4 id="各种存储引擎特性"><a href="#各种存储引擎特性" class="headerlink" title="各种存储引擎特性"></a>各种存储引擎特性</h4><pre><code>常用的存储引擎：InnoDB MyISAM</code></pre><table>
<thead>
<tr>
<th align="center">特点</th>
<th align="center">InnoDB</th>
<th align="center">MyISAM</th>
<th align="center">Memory</th>
<th align="center">Merge</th>
<th align="center">NDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储限制</td>
<td align="center">64TB</td>
<td align="center">有</td>
<td align="center">有</td>
<td align="center">没有</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">事务安全</td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">锁机制</td>
<td align="center">行锁（高并发）</td>
<td align="center">表锁</td>
<td align="center">表锁</td>
<td align="center">表锁</td>
<td align="center">行锁</td>
</tr>
<tr>
<td align="center">B树索引</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">哈希索引</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">5.6以后</td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">集群索引</td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">数据索引</td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">索引缓存</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">空间使用</td>
<td align="center">高</td>
<td align="center">低</td>
<td align="center"></td>
<td align="center">低</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">内存使用</td>
<td align="center">高</td>
<td align="center">低</td>
<td align="center">中</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">批量插入</td>
<td align="center">低</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">外键</td>
<td align="center">支持</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h5 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h5><pre><code>InnoDB存储引擎是MySQL的默认存储引擎，具有提交，回滚，恢复事务能力，相对于MyISAM存储引擎，InnoDB的写的处理效率较低，而且会占用更多的存储空间来存储索引和数据。</code></pre><p><strong>支持事务安全</strong></p>
<pre><code>默认每个查询是一次事务，会自动提交事务
使用start transaction,开启事务，在数据查询之后，使用commit可以提交事务</code></pre><p><strong>支持外键</strong></p>
<pre><code>InnoDB存储引擎是唯一支持外键的存储引擎，在创建子表时，可以指定在删除，更新主表对子表的操作如下，restrict,cascade,set null,no action
* restrict和no action：限制子表有关联记录时，父表不能更新
* cascade: 在更新父表的时候，更新对应子表中的记录
* set null: 在更新父表的时候，子表的对应字段设置为空</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`city_innodb`</span>(</span><br><span class="line">	<span class="string">`city_id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	<span class="string">`city_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	<span class="string">`country_id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(<span class="string">`city_id`</span>),</span><br><span class="line">	<span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(country_id) <span class="keyword">REFERENCES</span> country_innodb(country_id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line">on <span class="keyword">update</span> restrict: 在更新时，存在关联，不能进行更新</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span>: 在删除时，级联删除</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/innodb.png" alt="InnoDB"></p>
<p><strong>存储方式</strong></p>
<pre><code>在linux操作系统下，mysql只要存储两个文件
1. .frm文件：存储表的结构信息（定义 ）
2. .idb文件：存储表的索引信息和数据</code></pre><h5 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h5><pre><code>MyISAM不支持事务和外键，访问速度块，对事务的完整性没有要求的select,insert为主的数据可以使用MyISAM存储引擎</code></pre><p><strong>不支持事务</strong></p>
<pre><code>一旦查询语句执行，数据会马上提交到数据库</code></pre><p><strong>文件存储方式</strong></p>
<pre><code>每个MyISAM存储引擎会分成3个文件名称和表的名称相同，拓展名不同：
1. .frm: 存储表的定义
2. .myd: 存储表的数据
3. .myi: 存储表的索引</code></pre><h5 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h5><pre><code>1. Memory存储引擎将表的数据存放在内存中。
2. 每个表对应一个磁盘文件，格式是.frm,该文件只存放表的结构，数据文件全都存放在内存中，这样有利于数据的快速处理，提高表的效率。
3. Memory类型的表的数据访问速度快，因为数据存放在内存中，可以默认使用Hash索引，但是服务一旦关闭表中的数据就会丢失。</code></pre><h5 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h5><pre><code>类似于视图，虚拟表，只包含结构，不包含数据
1. Merge是一组MyISAM的组合，这些MyISAM表结构必须完全相同，Merge本身并没有存储数据
2. 对Merge类型的表可以进行查询，删除，更新等，这些操作实际上是对内部的MyISAM进行操作
3. 对于Merge类型表的插入操作，是通过子句insert_method子句定义插入的表，
    * 使用first,last使插入的数据作用在第一个或者最后一个表上
    * 不定义或者定义为no,表示不能对Merge表进行插入操作
4. drop操作，只是删除了Merge本身的定义，对实际表没有影响

1. Merge类型的使用</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表1</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_1(</span><br><span class="line">	order_id <span class="built_in">INT</span>,</span><br><span class="line">	order_money <span class="keyword">DOUBLE</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	order_address <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(order_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=MYISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"><span class="comment">-- 表2</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_2(</span><br><span class="line">	order_id <span class="built_in">INT</span>,</span><br><span class="line">	order_money <span class="keyword">DOUBLE</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	order_address <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(order_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=MYISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"><span class="comment">-- merge表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_all(</span><br><span class="line">	order_id <span class="built_in">INT</span>,</span><br><span class="line">	order_money <span class="keyword">DOUBLE</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	order_address <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(order_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">MERGE</span> <span class="keyword">UNION</span> = (order_1,order_2) INSERT_METHOD = <span class="keyword">LAST</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_1 <span class="keyword">VALUES</span>(<span class="number">10</span>,<span class="number">100.0</span>,<span class="string">'上海'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_1 <span class="keyword">VALUES</span>(<span class="number">20</span>,<span class="number">300.0</span>,<span class="string">'北京'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_2 <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">100.0</span>,<span class="string">'云南'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_2 <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">100.0</span>,<span class="string">'合肥'</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/merge_1.png" alt></p>
<pre><code>2. 注意
    union: 表示合并的是哪些表
    insert_method: 插入数据的方式，这里使用last，向order_2插入数据
    合并表的主键有可能会出现相同的情况</code></pre><h4 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h4><pre><code>在选择存储引擎时，可以根据需要进行选择单个存储引擎，也可以选择多个存储引擎同时使用：</code></pre><ul>
<li>InnoDB: 对数据的安全性要求比较高，数据容错率低，在并发环境下要求数据的一致性，数据除了查询之外还有更新和删除的时候，应该选择InnoDB存储引擎。比如计费系统，财务系统</li>
<li>MyISAM: 不支持事务控制，如果对数据的操作以查询和插入为主，对并发的要求不高的情况下，可以使用</li>
<li>Memory: 所有的数据都保存在内存中，对数据的操作速度快，在小容量，对访问速度要求比较高的情况下，可以使用Memory引擎。更新不太频繁的小表中</li>
<li>Merge: 将一组MyISAM表组合起来，作为一个引用来使用，可以突破单个MyISAM引擎表的大小限制，将不同的表存在多个磁盘，可以改善访问效率。数据存储仓库比较合适 </li>
</ul>
<h3 id="优化SQL步骤"><a href="#优化SQL步骤" class="headerlink" title="优化SQL步骤"></a>优化SQL步骤</h3><pre><code>在初期开发过程中，数据量比较小，一般来说只需要实现功能即可，但是随着用户数据的增多，
SQL语句的执行速度越来越慢,此时，需要对一些有问题的SQL语句进行优化。</code></pre><h4 id="插入大量的数据"><a href="#插入大量的数据" class="headerlink" title="插入大量的数据"></a>插入大量的数据</h4><pre><code>* 不同的存储引擎具有不同的功能，如果在MySQL数据库中建立大量的数据，可以在使用Memory创建表，然后将内存中的数据插入想要的表
* 可以使用存储过程，也可以建立多个独立的数据表，使用Merge进行合并</code></pre><ul>
<li><p><a href="https://blog.csdn.net/weixin_44901453/article/details/96453405" target="_blank" rel="noopener">1</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/hill1126/p/11334523.html" target="_blank" rel="noopener">2</a></p>
<ol>
<li><p>修改默认的存储空间<br> MySQL默认的内存空间为16M，可以手动修改内存大小</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置内存大小为1GB</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_heap_table_size = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查看当前的设置的大小</span></span><br><span class="line"><span class="keyword">select</span> @@max_heap_table_size;</span><br><span class="line"><span class="comment">-- 在重新连接数据库服务端的时候，生效</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>建立memory表<br> 只需要具体的存储引擎为Memory，属性的域和想要插入的域一致</p>
</li>
<li><p>建立具体应用的表<br> 存储引擎可以为InnoDB,MyISAM</p>
</li>
<li><p>建立生成数据并插入的存储过程</p>
</li>
<li><p>将建立的表数据插入具体应用的表,清空在内存中的数据</p>
</li>
</ol>
</li>
</ul>
<p><code>TRUNCATE TABLE tablename</code></p>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/sql_5.png" alt></p>
<h4 id="查看SQL执行频率"><a href="#查看SQL执行频率" class="headerlink" title="查看SQL执行频率"></a>查看SQL执行频率</h4><p>MySQL客户端连接成功之后，可以使用<code>show global|session status</code>查看服务器的状态信息，<code>show global|session status</code>可以根据参数<code>session</code>查看当前会话（当前连接）的统计结果，或者<code>golbal</code>整个数据库（自从上次启动之后）的统计结果</p>
<pre><code>1. 当前session的统计结果</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这里通配符使用 - ，一共7个，长度固定，更好观察结果</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Com______'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/sql_1.png" alt="当前连接的状态"></p>
<pre><code>2. 查看InnoDB存储引擎的统计结果</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'InnoDB_rows_%'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/sql_2.png" alt="InnoDB的状态"></p>
<pre><code>3. 查看自从上次重启之后的统计结果</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Com_______'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/sql_3.png" alt="当前服务器的状态"></p>
<h4 id="定位低效率SQL语句"><a href="#定位低效率SQL语句" class="headerlink" title="定位低效率SQL语句"></a>定位低效率SQL语句</h4><ul>
<li>慢查询日志进行定位：可以通过慢查询日志来定位哪些执行效率比较慢的SQL语句，使用<code>--log-slow-queries[=file_name]</code>选项启动的时侯，mysqld写一个包含执行时间超过<code>long-query-time</code>秒的SQL语句，可以分析日志，定位到慢查询语句</li>
<li>show processlist: 慢查询日志在查询结束之后才能发现执行效率低的SQL语句，可以使用命名令来查看当前SQL语句在进行的线程，包括线程的状态，是否锁表等信息，可以实时的查看SQL的执行情况</li>
</ul>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/sql_4.png" alt="当前服务器的状态"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id列：用户登录MySQL之后，分配的connection_id,可以调用函数connection_id进行查看</span><br><span class="line">user列：显示当前用户，如果不是root用户，只能显示当前权限内的sql</span><br><span class="line">host列：显示这个SQL是从哪个IP的哪个端口发出的，跟踪出现问题的用户</span><br><span class="line">db列：当前进程正在连接哪个数据库</span><br><span class="line">command列：当前连接正在执行的命令，sleep,query,connect</span><br><span class="line">state列：当前连接的状态，语句执行过程中的一个状态</span><br><span class="line">time列：已经进行的时间</span><br><span class="line">info列：正在执行的SQL语句</span><br></pre></td></tr></table></figure>

<h4 id="explain分析计划执行"><a href="#explain分析计划执行" class="headerlink" title="explain分析计划执行"></a>explain分析计划执行</h4><pre><code>通过定位慢查询语句可以知道哪些SQL语句的执行效率比较低，可以使用explain或者desc命令分析MySQL如何
执行select语句，包括在执行过程中表如何连接以及连接顺序

查询SQL语句的执行计划：</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- explain desc都可以获取SQL的执行顺序</span></span><br><span class="line"><span class="keyword">explain</span> | <span class="keyword">desc</span> <span class="keyword">select</span> * <span class="keyword">from</span> vote_record <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">500</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/mysql/explain_1.png" alt="explian执行计划"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 属性的含义</span></span><br><span class="line">id: 查询的序列号，一组数字，表示查询过程中<span class="keyword">select</span>子句或者操作表的顺序</span><br><span class="line">select_type: 执行操作的类型，simple update...</span><br><span class="line"><span class="keyword">table</span>: 输出结果集的表</span><br><span class="line"><span class="keyword">type</span>: 表的连接类型，性能由好到差<span class="keyword">system</span>,const,eq_ref,<span class="keyword">ref</span>,ref_of_null,index_merge ,index_subquert,<span class="keyword">range</span>,<span class="keyword">index</span> ,<span class="keyword">all</span></span><br><span class="line">possible_keys: 可能使用的索引</span><br><span class="line"><span class="keyword">key</span>: 实际使用的索引</span><br><span class="line"><span class="keyword">rows</span>: 扫描行的数量</span><br><span class="line">extra: 执行情况的说明和描述</span><br></pre></td></tr></table></figure>

<h5 id="explain-id"><a href="#explain-id" class="headerlink" title="explain: id"></a>explain: id</h5><pre><code>id: 表示表的加载顺序,可以通过查看id来发现语句执行的顺序

1. id相同，表示从上到下顺序加载</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询用户对应的角色信息</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">as</span> u,t_role <span class="keyword">as</span> r,user_role <span class="keyword">as</span> ur <span class="keyword">where</span> u.id = ur.user_id <span class="keyword">and</span> ur.role_id = r.id;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="/2020/10/12/mysql/explain_2.png" alt="explain_id"></p>
</blockquote>
<pre><code>2. id不同，id的值越大，优先级越高</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询指定用户名的角色,嵌套查询</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> role_code <span class="keyword">from</span> t_role <span class="keyword">where</span> <span class="keyword">id</span> = (<span class="keyword">select</span> role_id <span class="keyword">from</span> user_role <span class="keyword">where</span> user_id = (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> username = <span class="string">'zxl'</span>));</span><br><span class="line">1. 先查询t_user 2.再查询user_role 3.最后查询t_user</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="/2020/10/12/mysql/explain_3.png" alt="explain_id"></p>
</blockquote>
<pre><code>3. id有相同的，也有不同的</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询用户id为2的对应的角色信息</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_role r,(<span class="keyword">select</span> * <span class="keyword">from</span> user_role <span class="keyword">where</span> user_id = <span class="string">'2'</span>) a <span class="keyword">where</span> a.role_id = r.id;</span><br></pre></td></tr></table></figure>

<h5 id="explain-select-type"><a href="#explain-select-type" class="headerlink" title="explain: select_type"></a>explain: select_type</h5><pre><code>select_type: 执行语句的类型
    derived衍生类型没有表现出来</code></pre><table>
<thead>
<tr>
<th align="center">取值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">simple</td>
<td align="center">简单的查询，不包含子查询和Union</td>
</tr>
<tr>
<td align="center">primary</td>
<td align="center">包含复杂子查询语句，最外层的查询语句为该标识</td>
</tr>
<tr>
<td align="center">subquery</td>
<td align="center">在select或者where子句包含子查询</td>
</tr>
<tr>
<td align="center">derived</td>
<td align="center">在from列表包含的子查询，标记为衍生，MySQL递归执行，生成临时表</td>
</tr>
<tr>
<td align="center">union</td>
<td align="center">若第二个select子句包含在union之后，标记为union;union子句包含在from子句内，外层select标记derived</td>
</tr>
<tr>
<td align="center">union result</td>
<td align="center">从union表获取的结果</td>
</tr>
<tr>
<td align="center">效率</td>
<td align="center">从上往下逐渐降低</td>
</tr>
</tbody></table>
<h5 id="explain-table"><a href="#explain-table" class="headerlink" title="explain: table"></a>explain: table</h5><pre><code>查询的数据是基于哪张表的</code></pre><h5 id="explain-type"><a href="#explain-type" class="headerlink" title="explain: type"></a>explain: type</h5><pre><code>显示的是访问类型，重要的参考指标</code></pre><table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">null</td>
<td align="center">MySQL不访问任何的表，索引，直接返回结果，系统函数</td>
</tr>
<tr>
<td align="center">system</td>
<td align="center">表只有一行记录，const的特例，一般不会出现</td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">常量，通过索引一次就找到了，在使用主键或者唯一索引进行查询的时候,只有一条数据匹配。将主键索引放置到where子句，MySQL就能将查询转换为一个常量，const将主键或唯一索引于常量值进行比较</td>
</tr>
<tr>
<td align="center">eq_ref</td>
<td align="center">使用唯一索引，使用主键的关联索引，关联查询的数据只有一条</td>
</tr>
<tr>
<td align="center">ref</td>
<td align="center">非唯一性索引，返回匹配的结果集，本质也是索引查询</td>
</tr>
<tr>
<td align="center">range</td>
<td align="center">只检索给定返回的行，使用一个索引来返回数据，where后有between,in</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">扫描整个索引树，效率比All要高</td>
</tr>
<tr>
<td align="center">all</td>
<td align="center">扫描所有数据，整个数据文件，效率最低</td>
</tr>
</tbody></table>
<pre><code>效率排序</code></pre><figure class="highlight"><table><tr><td class="code"><pre><span class="line">null system const eq_ref fulltext ref_or_null index_merge unique_subquery</span><br><span class="line">index_sunquery range index all</span><br><span class="line">注意：</span><br><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</span><br></pre></td></tr></table></figure>

<pre><code>在进行SQL优化的时候，至少保证达到range级别，最好到达ref</code></pre><h5 id="explain-key"><a href="#explain-key" class="headerlink" title="explain: key"></a>explain: key</h5><ul>
<li>possible_key: 可能使用到的索引</li>
<li>key：实际上使用的索引</li>
<li>key_len: 索引的长度，长度越低，效率越高</li>
</ul>
<h5 id="explain-rows"><a href="#explain-rows" class="headerlink" title="explain: rows"></a>explain: rows</h5><pre><code>扫描行的数量    </code></pre><h5 id="explain-extra"><a href="#explain-extra" class="headerlink" title="explain: extra"></a>explain: extra</h5><pre><code>额外的执行计划</code></pre><table>
<thead>
<tr>
<th align="center">extra</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">using filesort</td>
<td align="center">MySQL会对数据进行外部的索引排序，不是按照数据库中的索引进行读取，称为“文件排序”，效率低</td>
</tr>
<tr>
<td align="center">using temporary</td>
<td align="center">使用临时表保存中间结果,MySQL在查询中间结果时使用临时表，order by group by</td>
</tr>
<tr>
<td align="center">using index</td>
<td align="center">相应的select操作使用了索引，效率可以</td>
</tr>
</tbody></table>
<h4 id="show-profile分析SQL"><a href="#show-profile分析SQL" class="headerlink" title="show profile分析SQL"></a>show profile分析SQL</h4><p>MySQL自从5.0.7之后增加了<code>show profiles</code>和<code>show profile</code>语句的支持。<code>show profiles</code>能够在SQL优化的同时帮助我们了解时间耗费在哪。</p>
<p>通过<code>have_ptofiling</code>参数，可以看出MySQL是否支持profile:</p>
<blockquote>
<p><img src="/2020/10/12/mysql/profile_1.png" alt="查看profile是否支持"></p>
</blockquote>
<h4 id="trace分析优化器执行计划"><a href="#trace分析优化器执行计划" class="headerlink" title="trace分析优化器执行计划"></a>trace分析优化器执行计划</h4><h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3>]]></content>
      <categories>
        <category>Linux</category>
        <category>MySQL</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 优化</title>
    <url>/2020/05/18/Hexo%20%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="Hexo-next自适应宽屏"><a href="#Hexo-next自适应宽屏" class="headerlink" title="Hexo next自适应宽屏"></a>Hexo next自适应宽屏</h2><p><code>/themes/next/source/css/_schemes/Picses/_layout.styl</code>在文件末尾添加代码<br><code>// 以下为新增代码！！修改post宽度</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">header&#123;</span> <span class="attr">width:</span> <span class="number">80</span><span class="string">%</span> <span class="type">!important</span><span class="string">;</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">header.post-header</span> <span class="string">&#123;</span></span><br><span class="line"> 		<span class="attr">width:</span> <span class="string">auto</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">	<span class="string">&#125;</span></span><br><span class="line"><span class="string">.container</span> <span class="string">.main-inner</span> <span class="string">&#123;</span> <span class="attr">width:</span> <span class="number">80</span><span class="string">%;</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">.content-wrap</span> <span class="string">&#123;</span> <span class="attr">width:</span> <span class="string">calc(100%</span> <span class="bullet">-</span> <span class="string">260px);</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">.header</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">+tablet()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="string">auto</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">+mobile()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="string">auto</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">.container</span> <span class="string">.main-inner</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">+tablet()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="string">auto</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">+mobile()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="string">auto</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">.content-wrap</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">+tablet()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">100</span><span class="string">%</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">+mobile()</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">100</span><span class="string">%</span> <span class="type">!important</span><span class="string">;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="顶部进度条"><a href="#顶部进度条" class="headerlink" title="顶部进度条"></a>顶部进度条</h2><pre><code>1. 在主题的配置文件中，找到pace:标签，可以开启进度条的设置
2. pace_theme: pace-theme-flash：具体的样式</code></pre><p><a href="https://blog.csdn.net/u011236348/article/details/88146947" target="_blank" rel="noopener">进度条参考博客地址</a></p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>在<code>themes/*/source/css/_custom/custom.styl</code>中添加代码<br>`</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Zitiming;</span><br><span class="line">    src: url('/fonts/Zitiming.ttf');</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.site-title</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">40px</span> !important;</span><br><span class="line">	<span class="attribute">font-family</span>: <span class="string">'Zitiming'</span> !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中字体文件在 <code>themes/next/source/fonts</code> 目录下，里面有个 <code>.gitkeep</code>的隐藏文件，打开写入你要保留的字体文件，比如我的是就是写入 <code>Zitiming.ttf</code>，具体字库自己从网上下载即可</p>
<h2 id="设置网站缩略图标"><a href="#设置网站缩略图标" class="headerlink" title="设置网站缩略图标"></a>设置网站缩略图标</h2><p>把你的图片（png或jpg格式，不是favicon.ico）放在<code>themes/next/source/images</code>里，然后打开 主题配置文件 找到<code>favicon</code>，将<code>small、medium、apple_touch_icon</code>三个字段的值都设置成<code>/images/图片名.jpg</code>就可以了，其他字段都注释掉</p>
<h2 id="静态资源压缩"><a href="#静态资源压缩" class="headerlink" title="静态资源压缩"></a>静态资源压缩</h2><pre><code>参考文档：</code></pre><ul>
<li><a href="https://maplerain.cc/posts/69416b20.html" target="_blank" rel="noopener">静态资源压缩</a></li>
<li><a href="https://blog.csdn.net/guang_s/article/details/84751813" target="_blank" rel="noopener">cache的使用</a></li>
<li><a href="https://wiki.zthxxx.me/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/gulp-imagemin-%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener">imagemin参数设置</a></li>
</ul>
<h3 id="gulp-imagemin中的默认组件无法加载"><a href="#gulp-imagemin中的默认组件无法加载" class="headerlink" title="gulp-imagemin中的默认组件无法加载"></a>gulp-imagemin中的默认组件无法加载</h3><pre><code>1. 卸载原来的版本</code></pre><p><code>npm uninstall gulp-imagemin --save-dev</code></p>
<pre><code>2. 安装cnpm</code></pre><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<pre><code>3. 重新安装gulp-imagemin</code></pre><p><code>cnpm install gulp-imagemin --save-dev</code></p>
<pre><code>4. --save-dev的含义</code></pre><p>保存配置信息至<code>package.json</code>的<code>devDependencies</code>节点</p>
<h3 id="gulp-imagemin使用缓存cache"><a href="#gulp-imagemin使用缓存cache" class="headerlink" title="gulp-imagemin使用缓存cache"></a>gulp-imagemin使用缓存cache</h3><pre><code>由于图片压缩的速度太过于缓慢，而且每次重新部署的时候都需要进行压缩，时间浪费太严重，可以使用cache进行缓解这种现象
1. 安装gulp-cache插件</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cnpm install gulp-imagemin --save-dev</span><br></pre></td></tr></table></figure>

<pre><code>2. gulpfile.js的编写</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cache=request(<span class="string">"gulp-cache"</span>);</span><br><span class="line">gulp.task(<span class="string">'minify-img'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.*'</span>)</span><br><span class="line">        .pipe(cache(imagemin(&#123;</span><br><span class="line">            optimizationLevel: <span class="number">5</span>, <span class="comment">// 取值范围：0-7（优化等级），默认：3  </span></span><br><span class="line">            progressive: <span class="literal">true</span>,  <span class="comment">// 无损压缩jpg图片，默认：false </span></span><br><span class="line">            interlaced: <span class="literal">true</span>,   <span class="comment">// 隔行扫描gif进行渲染，默认：false </span></span><br><span class="line">            multipass: <span class="literal">true</span>         <span class="comment">// 多次优化svg直到完全优化，默认：false </span></span><br><span class="line">        &#125;)))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<pre><code>3. 清理cache</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'cleanCache'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.clearAll(done);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="imagemin-pngquant深度压缩png图片"><a href="#imagemin-pngquant深度压缩png图片" class="headerlink" title="imagemin-pngquant深度压缩png图片"></a>imagemin-pngquant深度压缩png图片</h3><pre><code>1. 安装imagemin-pngquant插件</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cnpm install pngquant --save-dev</span><br></pre></td></tr></table></figure>

<pre><code>2. gulpfile.js</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp=request(<span class="string">"gulp"</span>);</span><br><span class="line"><span class="keyword">var</span> pngquant=request(<span class="string">"imagemin-pngquant"</span>);</span><br><span class="line">gulp.task(<span class="string">'testImagemin'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	gulp.src(<span class="string">'src/img/*.*'</span>)</span><br><span class="line">    	.pipe(imagemin(&#123;</span><br><span class="line">        	progressive: <span class="literal">true</span>, <span class="comment">//类型：Boolean 默认：false 无损压缩jpg图片</span></span><br><span class="line">        	use: [pngquant()] <span class="comment">//使用pngquant深度压缩png图片的imagemin插件</span></span><br><span class="line">    	&#125;))</span><br><span class="line">    	.pipe(gulp.dest(<span class="string">'dist/img'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<pre><code>3. 使用
    1. 可以在命令行下使用：gulp testImagemin
    2. 创建新的执行脚本，里面包含 testImagemin</code></pre><h2 id="更新时间"><a href="#更新时间" class="headerlink" title="更新时间"></a>更新时间</h2><p>在主题的配置文件下，使用<code>update</code>会找到一个<code>updated_at</code>的属性改为<code>true</code>即可。</p>
<h2 id="代码显示"><a href="#代码显示" class="headerlink" title="代码显示"></a>代码显示</h2><p>在hexo的根目录下，<code>_config.yml</code>中的<code>auto_detect: false</code>改为true<br>在hexo的主题目录下，<code>_config.yml</code>中的<code>auto_detect: false</code>改为true</p>
<p><code>highlight_theme: night eighties</code>,指定代码主题的样式</p>
<h2 id="增加代码复制功能"><a href="#增加代码复制功能" class="headerlink" title="增加代码复制功能"></a>增加代码复制功能</h2><pre><code>参考文件地址：</code></pre><ul>
<li><a href="https://blog.csdn.net/Awt_FuDongLai/article/details/107466848" target="_blank" rel="noopener">代码复制</a></li>
</ul>
<h2 id="隐藏网页底部powered-By-Hexo-强力驱动"><a href="#隐藏网页底部powered-By-Hexo-强力驱动" class="headerlink" title="隐藏网页底部powered By Hexo / 强力驱动"></a>隐藏网页底部powered By Hexo / 强力驱动</h2><p>打开<code>themes/next/layout/_partials/footer.swig</code>,隐藏驱动之间的代码即可，或者直接删除。</p>
<h2 id="底部显示错误"><a href="#底部显示错误" class="headerlink" title="底部显示错误"></a>底部显示<i class="fa fa-angle-right"></i>错误</h2><p>更改<code>\themes\next\layout\_partials\pagination.swig</code>中的代码，将paginator()的代码改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">paginator(&#123;</span><br><span class="line">  prev_text: <span class="string">'&lt;i class="fa fa-hand-o-left" aria-label="'</span> + __(<span class="string">'accessibility.prev_page'</span>) + <span class="string">'"&gt;&lt;/i&gt;'</span>,</span><br><span class="line">  next_text: <span class="string">'&lt;i class="fa fa-hand-o-right" aria-label="'</span> + __(<span class="string">'accessibility.next_page'</span>) + <span class="string">'"&gt;&lt;/i&gt;'</span>,</span><br><span class="line">  mid_size : <span class="number">1</span>,</span><br><span class="line">  <span class="built_in">escape</span>   : <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="增加雪花特效"><a href="#增加雪花特效" class="headerlink" title="增加雪花特效"></a>增加雪花特效</h2><pre><code>已经配置完成，在样式配置文件中打开配置就行了</code></pre><p>在<code>\themes\next\layout\_layout.swig</code>文件引用</p>
<ul>
<li><a href="https://blog.csdn.net/stormdony/article/details/86001618" target="_blank" rel="noopener">雪花特效</a></li>
</ul>
<h2 id="引入背景图片"><a href="#引入背景图片" class="headerlink" title="引入背景图片"></a>引入背景图片</h2><p>打开文档下<code>themes\next\source\css\ _custom\custom.sty</code>l文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(https:<span class="comment">//source.unsplash.com/random/1600x900);</span></span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:<span class="number">50</span>% <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="增加不蒜子统计-可惜在本博客无法使用，不知道为什么"><a href="#增加不蒜子统计-可惜在本博客无法使用，不知道为什么" class="headerlink" title="增加不蒜子统计: 可惜在本博客无法使用，不知道为什么"></a>增加不蒜子统计: 可惜在本博客无法使用，不知道为什么</h2><pre><code>1. 修改代码文件</code></pre><p>先将busuanzi的脚本文件下载到本地<code>themes/next/source/js/src/</code>下，保存为<code>busuanzi.pure.mini.js</code>,修改文件<code>themes/next/layout/_third-party/analytics/busuanzi-counter.swig</code>中的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"> # 将其改为</span><br><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"/js/src/busuanzi.pure.mini.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<pre><code>2. 修改配置文件_config.yml</code></pre><p>在<code>themes/next/_config.yml</code>主题配置文件，搜索关键字<code>busuanzi_count</code>,将enable的值改为true,并对站点UV配置、站点PV配置、单页面PV进行配置。如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_uv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-user"&gt;本站访客数&lt;/i&gt;</span></span><br><span class="line">  <span class="string">site_uv_footer:人次</span></span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-eye"&gt;本站总访问量&lt;/i&gt;</span></span><br><span class="line">  <span class="string">site_pv_footer:次</span></span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-file-o"&gt;本文总阅读量&lt;/i&gt;</span></span><br><span class="line">  <span class="string">page_pv_footer:次</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>1819-password-does-not-satisfy</title>
    <url>/2020/10/28/pwd_not_safe/</url>
    <content><![CDATA[<h2 id="ERROR-1819-HY000-Your-password-does-not-satisfy-the-current-policy-requirements"><a href="#ERROR-1819-HY000-Your-password-does-not-satisfy-the-current-policy-requirements" class="headerlink" title="ERROR 1819 (HY000): Your password does not satisfy the current policy requirements"></a>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>在更改MySQL数据库的密码时，出现这个问题，这是因为设置的密码过于简单，MySQL中对于密码 的设置具有限制</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> authentication_string=<span class="keyword">PASSWORD</span>(<span class="string">'root'</span>) <span class="keyword">where</span> <span class="keyword">USER</span>=<span class="string">'root'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</span><br></pre></td></tr></table></figure>

<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><pre><code>1. 更改MySQL中对于密码设置的限制</code></pre><p>密码的长度是由<code>validate_password_length</code>决定的,但是可以通过以下命令修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p><code>validate_password_policy</code>决定密码的验证策略,默认等级为<code>MEDIUM</code>(中等),可通过以下命令修改为<code>LOW</code>(低)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>修改完成后密码就可以设置的很简单，比如1234之类的。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>MySQL</category>
        <category>Error</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>1524-plugin-not-load</title>
    <url>/2020/10/28/plugin_not_load/</url>
    <content><![CDATA[<h2 id="ERROR-1524-HY000-Plugin-‘msyql-native-password’-is-not-loaded"><a href="#ERROR-1524-HY000-Plugin-‘msyql-native-password’-is-not-loaded" class="headerlink" title="ERROR 1524 (HY000): Plugin ‘msyql_native_password’ is not loaded"></a>ERROR 1524 (HY000): Plugin ‘msyql_native_password’ is not loaded</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>在登录MySQL本地服务器的时候，出现上面的问题</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">zhaolong@zl-vm:~$ sudo mysql -uroot -proot</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">ERROR 1524 (HY000): Plugin 'msyql_native_password' is not loaded</span><br></pre></td></tr></table></figure>

<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul>
<li>在文件<code>/etc/mysql/my.cnf</code>文件中增加代码,开启<code>无密码登录</code>：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-<span class="keyword">grant</span>-<span class="keyword">tables</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重启MySQL,重新进行登录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo service mysql restart</span><br><span class="line">sudo mysql</span><br></pre></td></tr></table></figure>

<ul>
<li>输入以下命令，在将<code>/etc/mysql/mysql.cnf</code>修改过来就可以了</li>
<li>如果此时不修改<code>mysql.cnf</code>文件，可以使用<code>sudo mysql</code>直接进入客户端</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> authentication_string=<span class="keyword">PASSWORD</span>(<span class="string">"密码"</span>) <span class="keyword">where</span> <span class="keyword">User</span>=<span class="string">'root'</span>;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">plugin</span>=<span class="string">"mysql_native_password"</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line">quit;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>MySQL</category>
        <category>Error</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>1045-access-denied</title>
    <url>/2020/10/28/access_denied/</url>
    <content><![CDATA[<h2 id="ERROR-1045-28000-Access-denied-for-user-‘debian-sys-maint’-’localhost’-using-password-YES"><a href="#ERROR-1045-28000-Access-denied-for-user-‘debian-sys-maint’-’localhost’-using-password-YES" class="headerlink" title="ERROR 1045 (28000): Access denied for user ‘debian-sys-maint’@’localhost’ (using password: YES)"></a>ERROR 1045 (28000): Access denied for user ‘debian-sys-maint’@’localhost’ (using password: YES)</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p> 在使用<code>sudo mysql -udebian-sys-maint -p</code>的时候，出现这个错误<br>    使用的是MySQL登录密码</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><pre><code>修改root用户的密码，通过命令来修改root用户的密码：</code></pre><ul>
<li>查看密码</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 通过查看文件获取原始的密码</span></span><br><span class="line">sudo vim /etc/mysql/debian.cnf</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p><img src="/2020/10/28/access_denied/1045_1.png" alt></p>
<ul>
<li>更新密码</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 更改密码</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> authentication_string=<span class="keyword">PASSWORD</span>(<span class="string">'root'</span>) <span class="keyword">where</span> <span class="keyword">USER</span>=<span class="string">'root'</span>; </span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"><span class="comment">-- 退出</span></span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<ul>
<li>重新登录    </li>
</ul>
<p>使用更新后的密码可以进行登录</p>
<h3 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h3><ul>
<li><a href="https://blog.csdn.net/xiaoshunzi111/article/details/51898939" target="_blank" rel="noopener">1045 Error&lt;/&gt;</a></li>
<li><a href="https://blog.csdn.net/pengge0727/article/details/81448952?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.channel_param" target="_blank" rel="noopener">1045 Error2</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>MySQL</category>
        <category>Error</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>2002-mysql-conn-err</title>
    <url>/2020/10/28/conn_err/</url>
    <content><![CDATA[<h2 id="2002-Can’t-connect-to-local-MySQL-server-through-socket-‘-var-lib-mysql-mysql-sock’-13-“权限不够”"><a href="#2002-Can’t-connect-to-local-MySQL-server-through-socket-‘-var-lib-mysql-mysql-sock’-13-“权限不够”" class="headerlink" title="2002 - Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (13 “权限不够”)"></a>2002 - Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (13 “权限不够”)</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>在Linux中安装MySQL5.7.31以及Navicat可视化界面，MySQL的连接没有问题，但是在Navicat连接
数据库的过程中出现错误，错误如下：</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn.png" alt="Navicat连接MySQL界面"></p>
<pre><code>具体的错误代码:</code></pre><blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn_2.png" alt="2002_MySQL_Error"></p>
</blockquote>
<h3 id="本地MySQL客户端不能连接MySQL"><a href="#本地MySQL客户端不能连接MySQL" class="headerlink" title="本地MySQL客户端不能连接MySQL"></a>本地MySQL客户端不能连接MySQL</h3><pre><code>1. 查看MySQL的server配置文件</code></pre><p>在<code>socket ‘/var/lib/mysql/mysql.sock’</code>中，这个目录是连接本地mysql，通常通过一个Unix域套接字文件进行的，可能这个mysql.sock套接字文件配置有问题，本地客户端就不能连接。</p>
<pre><code>2. 方法</code></pre><p>ubuntu系统的mysql配置文件在<code>/etc/mysql/my.cnf</code>,在此目录里还有一个<code>mysql.cnf</code>,这两个文件是通过软连接的同一个文件, 我在<code>my.cnf</code>里添加配置信息,<code>mysql.cnf</code>里会自动改变。</p>
<p>使用<code>mysql</code>客户端不能连接到mysql服务端，是因为<code>mysql</code>连接的时候，使用了这个配置文件的<code>[client]</code>部分,新安装的mysql配置文件里是没有内容的,也就没有指定客户端的<code>mysql.sock</code>套接字文件位置;默认使用的是<code>mysql-server</code>服务端的配置,在<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>里;</p>
<blockquote>
</blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn_3.png" alt="mysql配置文件"></p>
<pre><code>3. 更改文件</code></pre><p>更改mysql客户端的mysql.sock套接字文件, 在配置文件<code>/etc/mysql/my.cnf</code>里添加:</p>
<blockquote>
</blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn_4.png" alt="mysql配置文件更改"></p>
<pre><code>4. 重启</code></pre><p>使用<code>sudo service mysql restart</code>命令重启服务，使用<code>mysql -uroot -p</code>登录</p>
<h3 id="本地可以登录，Navicat无法登录"><a href="#本地可以登录，Navicat无法登录" class="headerlink" title="本地可以登录，Navicat无法登录"></a>本地可以登录，Navicat无法登录</h3><p>在终端命令行下可以登录，但是使用Navicat无法登录，看了mysql服务端的配置<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>文件</p>
<blockquote>
</blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn_5.png" alt="mysql配置文件"></p>
<pre><code>1. 解决
    重新编辑连接，将主机名称进行更改</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn_6.png" alt="navicat连接"></p>
<blockquote>
</blockquote>
<p><img src="/2020/10/28/conn_err/2002_conn_7.png" alt="navicat连接成功"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>MySQL</category>
        <category>Error</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu</title>
    <url>/2020/10/24/ubuntu/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>这篇博客主要记录在使用Vmware安装的Unbuntu系统下遇到的错误以及解决问题的方式</code></pre><h2 id="虚拟机打开黑屏（1）"><a href="#虚拟机打开黑屏（1）" class="headerlink" title="虚拟机打开黑屏（1）"></a>虚拟机打开黑屏（1）</h2><pre><code>1. 解决方式
    由于在日志里面有句话，虚拟打印设备无法使用，在编辑中启用虚拟设备，可以打开虚拟机

2. 链接</code></pre><ul>
<li><a href="https://blog.csdn.net/qq_37074001/article/details/102645024" target="_blank" rel="noopener">虚拟机黑屏解决方法</a></li>
</ul>
<h2 id="虚拟机打开黑屏（2）"><a href="#虚拟机打开黑屏（2）" class="headerlink" title="虚拟机打开黑屏（2）"></a>虚拟机打开黑屏（2）</h2><pre><code>在每次重新打开电脑的时候，可以正常进入Unbuntu系统，但是一旦关闭后，无法再次进入系统，一值黑屏

本系统VMware: 15, Uubuntu: 18.04
解决方法：
    1. 在进入Unbuntu的时候，按F2进入启动项，按键盘&apos;E&apos;,进行编辑

    2. 在屏幕里的待编辑文字中找到【splash】 ，正常在中下部

    3. 在【splash】后加入一个空格，再键入【nomodeset】

    4. 按下Ctrl+X，退出编辑，重启系统，此时可以正常系统

    5. 进入Unbuntu系统后，打开终端，编辑文件</code></pre><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo gedit /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>

<pre><code>6. 随后在打开的文档中，找到所有的【splash】，并在其后加入一个空格，再键入【nomodeset】

7. 保存文件，以后就可以正常使用Ubuntu了</code></pre><h2 id="Unbuntu安装FTP"><a href="#Unbuntu安装FTP" class="headerlink" title="Unbuntu安装FTP"></a>Unbuntu安装FTP</h2><h3 id="E-无法定位软件包-vsftpd"><a href="#E-无法定位软件包-vsftpd" class="headerlink" title="E: 无法定位软件包 vsftpd"></a>E: 无法定位软件包 vsftpd</h3><pre><code>1. 问题描述
    在使用`sudo apt-get install vsftpd`安装ftp系统的时候，出现该问题</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/24/ubuntu/1_error.png" alt="E: 无法定位软件包 vsftpd"></p>
<pre><code>2. 解决方法</code></pre><p>更新软件源，<code>sudo apt-get update</code>        </p>
<h2 id="无法解析域名"><a href="#无法解析域名" class="headerlink" title="无法解析域名"></a>无法解析域名</h2><pre><code>1. 问题描述
    在使用`sudo apt-get update`,出现域名无法解析的问题，应该是域名服务器出现了问题，实际上是虚拟操作系统的网络出了问题，重新配置网络之后，可以进行更新</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/24/ubuntu/2_error.png" alt="无法解析域名"></p>
<pre><code>2. 解决方法
    1. 查看DNS的配置文件
        重新配置网络DNS</code></pre><pre><code class="linux">cat /etc/resolv.conf</code></pre>
<blockquote>
</blockquote>
<p><img src="/2020/10/24/ubuntu/2_1.png" alt></p>
<ul>
<li><a href="https://www.jb51.net/article/158414.htm" target="_blank" rel="noopener">Linux网络配置</a></li>
</ul>
<h2 id="ifconig无法使用"><a href="#ifconig无法使用" class="headerlink" title="ifconig无法使用"></a>ifconig无法使用</h2><pre><code>* sudo apt install net-tools
* sudo apt update: 升级apt</code></pre><ul>
<li><a href="https://blog.csdn.net/i_spirit/article/details/109182493" target="_blank" rel="noopener">command “ifconfig” not found</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Unbuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>multi-categories</title>
    <url>/2020/10/29/multi-categories/</url>
    <content><![CDATA[<h2 id="Hexo博客的多个分类的解决方案"><a href="#Hexo博客的多个分类的解决方案" class="headerlink" title="Hexo博客的多个分类的解决方案"></a>Hexo博客的多个分类的解决方案</h2><pre><code>在写博客的时候，很多方面并不是单一的，需要和其他的事务关联起来，此时的分类不能单一的看作一个，需要分为多个标签，这里提供一些解决方案。
多个标签的解决方法相同</code></pre><h3 id="子分类"><a href="#子分类" class="headerlink" title="子分类"></a>子分类</h3><pre><code>1. 含义
    将文章的分类方式，按照包含的关系进行分类，后面的分类包含于前面的分类

2. 使用
    将文章分类于，java.servlet</code></pre><ul>
<li>分类方式一：</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Servlet</span></span><br></pre></td></tr></table></figure>

<ul>
<li>分类方式二：</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span> <span class="string">[Java,</span> <span class="string">Servlet]</span></span><br></pre></td></tr></table></figure>

<pre><code>这两个的作用一致，分类的结构都是树形结构</code></pre><h3 id="多个分类"><a href="#多个分类" class="headerlink" title="多个分类"></a>多个分类</h3><p>希望将一篇文章分类于多个目录中,下面的是将文件分类于<code>java</code>和<code>servlet</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="string">-[Java]</span></span><br><span class="line">  <span class="string">-[Servlet]</span></span><br></pre></td></tr></table></figure>

<pre><code>也可以在多分类的基础上使用子分类</code></pre><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="string">-[Java,</span> <span class="string">Servlet]</span></span><br><span class="line">  <span class="string">-[Programming]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>soft</title>
    <url>/2020/10/26/soft/</url>
    <content><![CDATA[<h2 id="SecureCRT"><a href="#SecureCRT" class="headerlink" title="SecureCRT"></a>SecureCRT</h2><pre><code>1. 作用
    Windows和Linux之间的文件传输，支持SSH

2. 官网地址</code></pre><ul>
<li><p><a href="https://www.vandyke.com/cgi-bin/releases.php?product=securecrt" target="_blank" rel="noopener">SecureCRT官网</a></p>
</li>
<li><p><a href="https://www.vandyke.com/cgi-bin/releases.php?product=securecrt" target="_blank" rel="noopener">https://www.vandyke.com/cgi-bin/releases.php?product=securecrt</a></p>
<p><a href="https://pan.baidu.com/s/163MKL_sAXwfQ_8oPXGW7MA" target="_blank" rel="noopener">百度网盘地址，提取码：ab12 </a></p>
<ol start="3">
<li><p>安装<br> 需要注意安装路径，其余的直接next</p>
</li>
<li><p>破解</p>
</li>
</ol>
</li>
<li><p><a href="http://www.xue51.com/soft/10266.html" target="_blank" rel="noopener">SecrueCRT破解教程</a></p>
</li>
</ul>
<p>在软件安装包中存在注册机，直接根据教程进行破解就可以了</p>
<pre><code>5. 使用
    建立链接，可以使用sz,rz进行文件的下载和上传，也可以使用sftp进行文件的下载和上传</code></pre><ul>
<li><p><a href="https://blog.csdn.net/yule117737767/article/details/82388285" target="_blank" rel="noopener">SecrueCRT使用教程1</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_41880069/article/details/89643358?utm_medium=distribute.pc_relevant.none-task-blog-title-3&spm=1001.2101.3001.4242" target="_blank" rel="noopener">SecrueCRT使用教程2</a></p>
<p>  使用SFTP进行文件传输：Alt + P,打开sftp界面</p>
<ul>
<li>lcd 本地上传或者下载目录</li>
<li>cd linux文件目录</li>
<li>put 本地文件夹下的文件名</li>
<li>get linux文件夹下的文件名<blockquote>
</blockquote>
<img src="/2020/10/26/soft/secureCRT_1.png" alt="secure文件上传和下载"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>1046-no-database</title>
    <url>/2020/10/28/not_db/</url>
    <content><![CDATA[<h2 id="1046-3D000-No-database-selected"><a href="#1046-3D000-No-database-selected" class="headerlink" title="1046 (3D000): No database selected"></a>1046 (3D000): No database selected</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><pre><code>在MySQL进行数据更新的时候，出现这个错误</code></pre><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><pre><code>1. 出现位置</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> authentication_string=<span class="keyword">PASSWORD</span>(<span class="string">'root'</span>) <span class="keyword">where</span> <span class="keyword">USER</span>=<span class="string">'root'</span>;</span><br></pre></td></tr></table></figure>

<pre><code>2. 错误代码</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ERROR 1046 (3D000): No database selected</span><br></pre></td></tr></table></figure>

<pre><code>3. 解决
    因为是直接使用 SQL 语句的方式来删除账户，所以必须先选择 mysql 自身的数据库：</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>MySQL</category>
        <category>Error</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2020/10/12/maven/</url>
    <content><![CDATA[<h2 id="Maven基础知识"><a href="#Maven基础知识" class="headerlink" title="Maven基础知识"></a>Maven基础知识</h2><pre><code>1. Maven的含义
    * 一个项目管理工具
    * 依赖管理：
        Maven对项目的jar包的管理过程，传统项目直接把jar包放置在项目中，
        maven工程真正的jar包放置在仓库中，项目中只需要放置坐标
    * 一键构建：
        maven中集成了对tomcat插件，可以对项目进行编译，测试，打包，安装和发布等

2. 依赖管理
    1. 仓库的种类
        * 本地仓库
        * 远程仓库（私服）
        * 中央仓库

    2. 仓库之间的关系
        当我们启动一个maven工程时，maven会通过pom文件中的jar坐标去本地仓库寻找
        如果本地仓库没有对应jar包，会默认到中央仓库寻找对应jar包，下载到本地仓库
        在公司中，如果本地仓库没有对应jar包，会先从私服下载，如果私服没有jar包，可以从中央仓库下载jar包，也可以从本地仓库上传jar包

3. 一键构建
    1. 常用命令
        * clean:对构建信息进行清理
        * complie: src/main/java目录进行编译
        * test: 对测试进行编译
        * package: 对项目进行打包，默认目录在target目录（本地complie目录）
        * install：将包安装到本地仓库
        * deploy：项目上传到私服

    2. maven的生命周期
        * 清理生命周期：clean
        * 默认生命周期: complie test package install deploy
        * 站点生命周期：</code></pre><h2 id="Maven传统使用"><a href="#Maven传统使用" class="headerlink" title="Maven传统使用"></a>Maven传统使用</h2><pre><code>1. jar包的冲突原因
    如果一个项目导入核心jar包，会自动导入它所依赖的其他jar，如果导入的jar包所依赖的包是同一个，可能因为导入jar包的顺序问题，产生jar包的冲突

2. 解决jar包的冲突
    1. 第一声明优先原则
        哪个jar包的坐标在靠上的位置，这个jar包就是先声明的，先声明的jar包的坐标下的依赖包可以优先进入项目

    2. 路径近者优先原则
        * 直接依赖：项目中直接导入的jar包，就是该项目的直接依赖jar包
        * 传递依赖：项目中没有直接导入的jar包，可以通过直接依赖的jar包传递到项目中的jar
        直接依赖路径比传递依赖路径近，最终进入项目的jar包会是路径近的直接依赖

    3. 直接排除法
        排除某个jar包的依赖包，使用exclusions排除该jar包的依赖包，在坐标内部排除当前jar包，可以不写版本号，默认和当前jar包的版本号一致

3. 版本锁定
    1. 原因
        maven工程可以分为父子依赖，
        凡是依赖别的项目后拿到的别的项目的依赖，都属于传递依赖。
        项目A,被项目B依赖，项目A中的所有jar包都会传递到项目B,如果此时项目B的开发人员重新导入的jar包，由于是直接依赖，会覆盖到项目A的jar包

    2. 解决方法
        使用&lt;dependencyManagement&gt;来进行版本锁定，将项目主要的jar包的版本锁定，那么其他依赖该项目的项目中，即使有同名的jar包，也不会发生jar包覆盖

    3. 使用方法
        使用&lt;DependencyManagement&gt;标签只是起到版本锁定的作用，导入jar包还是需要使用&lt;Dependencies&gt;标签来进行导入jar包        

    4. 简化pom.xml文件
        * 使用&lt;properties&gt;标签来进行坐标版本的引入，减少后续的开发中的jar版本修改问题
        * 使用&lt;DependencyManagement&gt;来进行版本锁定</code></pre><h2 id="Maven工程的拆分聚合"><a href="#Maven工程的拆分聚合" class="headerlink" title="Maven工程的拆分聚合"></a>Maven工程的拆分聚合</h2><pre><code>1. 拆分的思想
    将一个完整的项目，拆分成多个独立的模块，在需要其中的某个模块的时候，可以直接引用该模块，有利于提高代码的可重用性，以及维护性

2. 聚合的思想
    把拆分的零散的模块组合起来形成一个完整的项目的过程，就是maven的聚合过程</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/12/maven/maven_1.png" alt="拆分聚合"></p>
<h3 id="拆分案例"><a href="#拆分案例" class="headerlink" title="拆分案例"></a>拆分案例</h3><pre><code>1. 步骤
    * 建立一个project,作为父工程，只需要工程中包含pom.xml文件就可以
    * 建立子模块，选中当前的项目，右键New-&gt;Module
    * 在创建子模块的时候会显示父工程的名称
    * 子模块中的pom.xml文件包含父工程的组织名和版本号（共享），父工程pom.xml会包含子模块的模块名</code></pre><blockquote>
</blockquote>
<p><img src="/2020/10/12/maven/maven_parent.png" alt="父工程的建立"></p>
<blockquote>
<p><img src="/2020/10/12/maven/maven_son_dao.png" alt="子工程的建立"></p>
</blockquote>
<p><img src="/2020/10/12/maven/maven_son_dao_2.png" alt="子工程的建立2"></p>
<blockquote>
</blockquote>
<p><img src="/2020/10/12/maven/maven_pom.png" alt></p>
<pre><code>2. 注意
    1. 项目,工程和模块之间的区别
        工程不等于一个完整的项目，模块也不等于一个完整的项目，一个完整的项目看的是代&lt;br&gt;码，代码完整，才说明是一个完整的项目，和此项目是工程或模块没有关联

        1. 工程天生只能使用自己的内部资源，天生是独立的，后期可以和其他的工程或模块建立关联关系
        2. 模块天生属于父工程的，天生不是独立的，模块一旦创建，所有的父工程的资源模块都可以使用

    2. 父子工程
        * 子模块天生集成父工程，可以使用父工程的所有资源
        * 子模块之间天生没有任何关联，后期可以自己建立关系，
            子模块在需要使用其他模块的地方引用模块的坐标就可以了

        * 父子工程之间不用建立关系，继承关系是天生的，不需要手动建立
        * 子工程之间引用叫做依赖，依赖关系不是天生的，需要手动建立

3. 传递依赖的jar包能否使用
    * 直接依赖的jar包的作用域为complie,传递依赖的jar包的作用域与这个jar包在pom.xml文件中的定义相关，
    * 如果实际开发中发现对应的jar包无法导入，可以重新导入jar包

4. maven父子工程项目的测试
    1. 通过maven的run启动父工程来进行服务启动
    2. 先将父子工程的jar包安装到本地仓库，父工程 install，安装到本地仓库,然后通过子工程的web来进行启动
    3. 使用本地的tomcat来进行服务启动

    第一种和第二种的服务启动的方式是基于maven自带的tomcat服务器启动，
        1. 方式一：使用父工程的run命令来进行服务启动，此时服务首先加载pom.xml文件，进行jar包的导入，由于此时的所有jar包都存在，可以启动服务
        2. 方式二：使用启动web项目来启动服务，在查找jar包的时候只有service层的jar包，本地仓库没有，中央仓库也没有，jar包导入错误，无法启动，只有将jar包安装到本地仓库，才能使用web项目来进行服务的启动（install）

    第三种方式：直接使用本地的tomcat服务器来进行服务的启动</code></pre><h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><pre><code>1. 私服的安装</code></pre><ul>
<li><a href="https://www.cnblogs.com/qdhxhz/p/9801325.html" target="_blank" rel="noopener">maven私服的下载地址</a></li>
</ul>
<h2 id="下载第三方jar"><a href="#下载第三方jar" class="headerlink" title="下载第三方jar"></a>下载第三方jar</h2><pre><code>1. 安装第三方jar包到本地仓库
    1. 进入jar包的所在目录</code></pre><p><code>mvn install:install-file -DgroupId=com.alibaba -DartiactId=fastjson -Dversion=1.1.37 -Dfile=fastjson-1.1.37.jar -Dpackage=jar</code></p>
<pre><code>2. 使用cmd命令行安装</code></pre><p><code>mvn install:install-file -DgroupId=com.alibaba -DartiactId=fastjson -Dversion=1.1.37 -Dfile=D:/2017217796/fastjson-1.1.37.jar -Dpackage=jar</code></p>
<pre><code>注意事项：
    这种安装方法，默认本地仓库的位置为C盘下的指定安装目录，如果曾经更改过本地仓库的位置，会产生错误</code></pre>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet路径有关的问题</title>
    <url>/2020/09/26/servlet_path/</url>
    <content><![CDATA[<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><pre><code>1. getRequestDispacher(url) : 只有相对路径，相对于项目路径，还是相对于当前文件路径
    *  ServletRequest接口中的参数路径不仅可以相对于当前Servlet上下文根，还可以相对与当前Servlet路径    
    *  因为在getRequestDispatcher(url)方法中封装了ServletContext.getRealPath()以获得相应的项目根路径，再通过字符串相加，从而可以获得一个完整的路径

2. 如果在静态页面中引用资源，可以直接写拦截路径，不需要增加/,默认在当前项目的文件夹下，如果增加/,会在当前目录的上一级目录中寻找资源
3. 如果使用 /xxxx/xx，则认为在当前项目的路径下寻找资源（在项目的路径下寻找资源）
4. 如果使用 xxxx/xxx,会将当前访问资源的上一级目录作为根目录，进行字符串拼接，寻找目标资源（在当前的路径下寻找资源）

5. 在使用的时候，可以按照访问的路径长短来进行转发资源的url书写
    * 在同一个访问路径下，可以直接使用文件名作为url参数，会得到想要的资源
    * 不在同一访问路径下，可以使用项目文件路径，就是在注解中使用的路径，也可以访问目标资源

总结：
    1. 如果是在静态页面，比如html,如果访问路径不加/，意味着在当前的项目路径下寻找资源；如果增加/,意味着在当前项目路径的上一级目录中寻找资源
    2. 如果是在servlet中进行转发，使用/xx,意味着从项目路径下寻找资源；不使用/，意味着从当前的访问路径中寻找资源
    3. res.getContextPath()查找当前的上下文路径，不能用在转发上</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/26/servlet_path/dispacher_1.png" alt="静态页面的访问形式"><br><img src="/2020/09/26/servlet_path/dispacher_2.png" alt="两种路径的区别"><br><img src="/2020/09/26/servlet_path/dispacher_url_use.png" alt="url的格式，使用方式"></p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><pre><code>1. sendRedirect(url):只有相对于项目路径的url
    * 通过使用 req.getContextPath()+&quot;/xxx/xxx&quot;进行资源的访问</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/26/servlet_path/sendredirect_1.png" alt="sendRedirect"></p>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><pre><code>* 不需要增加/,默认在当前项目的文件夹下，如果增加/,会在当前目录的上一级目录中寻找资源</code></pre>]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2020/09/19/servlet/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="两种架构"><a href="#两种架构" class="headerlink" title="两种架构"></a>两种架构</h3><pre><code>1. C/S架构和B/S架构
    C/S：Client/Server，客户端和服务器
        * 必须在客户端安装特定软件
        * 图形显示效果好，但是在服务器的软件和功能升级的时候，客户端也必须一起升级

    B/S: Brower/Server，浏览器和服务器
        * 无需安装客户端，任何浏览器都可以进行访问
        * 涉及到升级的，只需要升级服务器就可以了
        * 需要使用HTTP协议</code></pre><h3 id="服务器简介"><a href="#服务器简介" class="headerlink" title="服务器简介"></a>服务器简介</h3><pre><code>1. 什么是web？
    Web（World Wide Web）称为万维网，简单理解就是网站，表示internet主机上供外界访问的资源。
    资源分类：
        * 静态资源：Web页面中供人们浏览的数据始终是不变的。（HTML,CSS）
        * 动态资源：Web页面中人们浏览的数据是根据程序产生的，不同的时间，甚至不同的设备访问看到的内容是不同的。（JSP,Servlet）

2. 什么是Web服务器？
    Web服务器是运行以及发布Web应用的一个容器，只有将开发的Web项目放置到该容器中，才能使网络中的用户通过浏览器访问。

3. 常见服务器
    * 开源：
        1. Tomcat,主流的服务器之一
        2. jetty,淘宝的使用
        3. resin,效率最高的
        用法相同，只有开启和关闭服务器的命令上有差别

4. Tomcat服务器：
    * Apache软件基金会的Jakarta的一个核心项目，免费开源，支持JSP和servlet规范。
    * 技术先进，性能稳定，比较主流的Web服务器

    1. 下载安装

    2. Tomcat的目录结构
        1. bin: 二进制可执行文件
        2. conf:
            * server.xml,Tomcat服务器的配置信息，修改端口号，字符编码等
            * web.xml，项目部署描述文件
        3. lib: Tomcat的类库，jar包，服务器运行需要的jar包
        4. logs: 日志文件
        5. temp: 临时文件，Tomcat停止后可以删除
        6. webapps: 所有部署的项目，每个文件夹都是一个项目，ROOT是一个特殊的项目，在没有写地址栏时，对应的就是ROOT项目。
        7. work: 运行生成的文件，最终运行的文件都在这里

    3. Tomcat的启动
        * 在安装目录下的bin,双击startup.bat,显示毫秒数，启动成功
        * 在浏览器内输入，http://localhost:8080,出现页面，则显示成功

    4. 停止Tomcat
        双击shutdown.bat即可关闭

    5. 修改默认端口号
        在conf文件夹的内部，打开server.xml,找到&lt;connector&gt;标签，可以修改默认端口号
        修改后，重启Tomcat可以使用修改后的端口

    6. 项目部署的访问静态资源
        Tomcat是Web服务器，项目存在于webapps内部，通过特定的URL访问

        * 创建项目
            在webapps中建立文件夹，myapp
                - 创建WEB—INF，存放项目的核心内容
                    * 创建.classes文件夹，存放.class文件
                    * 创建lib,存放jar文件
                    * 创建web.xml，项目配置文件
                - 静态资源，与WEB—INF同级目录

        * URL访问资源
            在浏览器输入：http://localhost:8080/myapp/hello.html,可以访问到资源

    7. Tomcat的响应流程
        一旦用户访问，服务器会到webapps查找对应的资源文件，找到之后，回响应用户请求，显示对应的资源文件


    8. Tomcat的常见错误
        * Tomcat闪退
            JAVA_HOME配置是否有问题

        * 404
            服务器访问资源不存在，产生404</code></pre><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="Servlet的基础概念"><a href="#Servlet的基础概念" class="headerlink" title="Servlet的基础概念"></a>Servlet的基础概念</h3><pre><code>1. 含义
    * Server Applet的简称，是服务器端的程序（代码，功能实现），可交互式的处理客户端发送到服务器的请求，并完成响应操作。
    * 动态网页技术

2. 作用
    * 接收客户端发送的请求，并完成相应的操作
    * 动态生成网页
    * 将包含操作结果的网页响应给客户端</code></pre><h3 id="Servlet开发步骤"><a href="#Servlet开发步骤" class="headerlink" title="Servlet开发步骤"></a>Servlet开发步骤</h3><pre><code>1. 搭建开发环境
    将Servlet相关的jar包(lib/servlet-api.jar)导入classpath中

2. 编写Servlet的实现类
    * 实现javax.servlet.Servlet接口
    * 重写方法
    * 在service()核心编写语句

3. 将编译生成的.class文件放在WEB-INF/classes文件下
4. 修改web.xml的配置信息</code></pre><blockquote>
</blockquote>
<pre><code>&lt;servlet&gt;
&lt;!-- 为指定的class起别名 --&gt;
  &lt;servlet-name&gt;my&lt;/servlet-name&gt;
  &lt;servlet-class&gt;MyServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;!-- 访问资源的映射。使用/来访问MyServlet资源 --&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;my&lt;/servlet-name&gt;
  &lt;!-- 访问路径，浏览器的访问路径 --&gt;
  &lt;url-patten&gt;/&lt;/url-patten&gt;
&lt;/servlet-mapping&gt;

url-patten:配置的内容就是浏览器地址栏输入的URL项目名称后资源的内容

5. 错误
    500 ：服务器端错误</code></pre><h3 id="使用IDEA开发部署Servlet"><a href="#使用IDEA开发部署Servlet" class="headerlink" title="使用IDEA开发部署Servlet"></a>使用IDEA开发部署Servlet</h3><pre><code>1. 步骤
    * 创建项目，选择Java EE 7，并勾选Web Application
    * 输入项目名称和保存位置，点击Finsh，完成项目创建

2. 文件目录结构
    * .idea: 项目配置文件
    * src:存放Java代码
    * web : 存放静态资源
        WEB-INF:项目配置文件，classes和jar文件
            web.xml:
        index.jsp:动态页面

3. 使用方式
    * 导入外部jar包，servlet-api.jar
    * 重写实现类实现Servlet接口
    * 将访问路径进行绑定，使用servlet 和 servlet-mapping进行路径绑定
    * 开启服务，进行结果查看

4. IDEA集成Tomcat服务器
    * File -&gt; Setting -&gt; ApplicatioServices -&gt; + ,导入Tomcat的解压缩位置
    * 点击Edit Configurations,将项目放置到Deployment中
    * 开启Tomcat

5. 手动导入第三方jar包
    * 在web目录下，WEB-INF建立lib文件夹，将需要导入的jar包复制，然后点击lib目录，使用右键，Add As Librarys

6. 导出war包
    * 项目完成后，可以打包成war包，将其放在Tomcat的webapps目录下，一旦开启服务器，可以自动解压，实现项目部署。
    * 步骤：
        1. Project Structure -&gt; Artifacts -&gt; + -&gt; Web Application:Archive -&gt; For 
        2. 构建项目，bulid -&gt; bulid Artifacts
        3. 会在项目的out文件夹下生成，war包，将该包复制到webapps中，在再次开启服务器时，会将该项目解压，部署

7. 热部署
    在不进行服务器重启的前提现，进行数据的更新
    整个项目从新部署，包括从新打上.war 文件。会清空session ，释放内存。

    * war包，项目最终完成，将其放在服务器的文件目录下，可以实现启动服务器的同时部署项目
    * IDEA的开发工具集成Tomcat,编译项目时，生成的文件会放置在out文件夹中，再次刷新浏览器，会得到最新的信息</code></pre><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><pre><code>1. 含义
    超文本传输协议（HyperText Transfer Protocol），是互联网的一种网络协议
    基于请求与响应模式的，无状态的，应用层的协议，运行于TCP协议之上

2. 特点    
    * 由于是基于请求和响应的，可以支持浏览器/服务器模式
    * 简单快速：
        客户端只向服务器发送请求方法和路径，服务器就可以发送响应数据，通信速度很快，请求的方法有GET,POST
    * 灵活：可以传输不同类型的数据
    * 无连接的：每次TCP连接只处理一个请求或多个，服务器处理完客户端的请求之后，会断开连接，可以减少开销
    * 无状态的：HTTP协议对于事务没有记忆能力

3. HTTP通信流程
    1. 客户端与服务器建立TCP连接（三次握手）
    2. 客户端发送请求
    3. 服务器接受请求，并响应
    4. 客户端与服务器关闭连接（四次挥手）

4. 请求报文
    当浏览器向服务器发出请求时，向服务器传递一个数据块，就是请求报文
    * 请求行 请求方法/地址 URI协议/版本
    * 请求头 Request Header：可以接受的数据，语言，端口号，以及当前浏览器信息    
    * 空行
    * 请求正文    

5. 响应报文
    当服务器响应浏览器的请求，向浏览器传递一个数据块，就是响应报文
    * 状态行 
    * 响应头 Respone Header
    * 空行
    * 响应正文    

6. 常见状态码</code></pre><table>
<thead>
<tr>
<th align="center">状态编码</th>
<th align="center">状态描述</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">OK</td>
<td align="center">客户端请求成功</td>
</tr>
<tr>
<td align="center">302</td>
<td align="center">Found</td>
<td align="center">临时重定向</td>
</tr>
<tr>
<td align="center">403</td>
<td align="center">Forbidden</td>
<td align="center">服务器收到请求，但是拒绝提供服务，在正文中给原因</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">Not Found</td>
<td align="center">请求的资源不存在</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">Internal Server Error</td>
<td align="center">服务器错误，无法完成请求</td>
</tr>
</tbody></table>
<h2 id="Servlet深入"><a href="#Servlet深入" class="headerlink" title="Servlet深入"></a>Servlet深入</h2><h3 id="Servlet核心接口和类"><a href="#Servlet核心接口和类" class="headerlink" title="Servlet核心接口和类"></a>Servlet核心接口和类</h3><pre><code>1. Servlet的实现类
    * 通过实现Servlet接口创建Servlet类
    * 继承GenericServlet类
    * 继承HttpServlet类

2.1 Servlet接口
    Servlet是Servlet API的最重要的接口，所有的Servlet都会与该接口相关联，或是直接实现该接口，或是间接继承该接口的实现类

    接口中的方法：
    void init()
    ServletConfig getServletConfig()
    void service(ServletRequest request,ServletRespone respone)
    String getServletInfo()
    void destroy()

2.2 GenericServlet抽象类
    提供了生命周期方法init和destroy的实现方法，我们只需要实现service方法就可以
    实现了Servlet接口，重写了除了service()之外的所有方法
    一旦我们继承了该抽象类，只需要重写该方法就行

2.3 HttpServlet抽象类
    具体处理HTTP协议服务器端程序，继承了GenericServlet抽象类，重写了service()方法，针对HTTP协议的抽象类
    doGet,doPost,doPut,doDelete等方法</code></pre><h3 id="Servlet的创建方式"><a href="#Servlet的创建方式" class="headerlink" title="Servlet的创建方式"></a>Servlet的创建方式</h3><pre><code>1. 实现Servlet的接口</code></pre><blockquote>
</blockquote>
<pre><code>public class MyServlet implements Servlet { 
@Override
public void init(ServletConfig servletConfig) throws ServletException {

}

@Override
public ServletConfig getServletConfig() {
    return null;
}

@Override
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    System.out.println(new Date());
}

@Override
public String getServletInfo() {
    return null;
}

@Override
public void destroy() {

}</code></pre><p>}</p>
<pre><code>2. 继承HttpServlet抽象类（推荐）</code></pre><blockquote>
<pre><code>可以重写doGet,doPost，对访问进行修改
public class MyServlet3 extends HttpServlet {
    可以重写Http访问有关的方法
    doGet,doPost
}</code></pre></blockquote>
<pre><code>3. 常见错误
    1. 404:未找到资源
        * 地址书写错误
        * 地址没有问题，将IDEA的out目录删除，然后重新运行
    2. servlet地址重复
        * both mapped to the url-patten which is not permitted
    3. servlet配置地址错误</code></pre><h3 id="Servlet的配置方式"><a href="#Servlet的配置方式" class="headerlink" title="Servlet的配置方式"></a>Servlet的配置方式</h3><pre><code>1. 使用web.xml（2.5之前）</code></pre><blockquote>
<pre><code>&lt;!-- 建立访问映射 --&gt;
  &lt;servlet&gt;
    &lt;!-- 名称 --&gt;
    &lt;servlet-name&gt;servlet&lt;/servlet-name&gt;
    &lt;!-- 全限定类名 --&gt;
    &lt;servlet-class&gt;com.servlet_02_start.servlet.MyServlet&lt;/servlet-class&gt;
    &lt;!-- 启动时加载 --&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/start&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;</code></pre></blockquote>
<pre><code>url-patten的匹配规则：</code></pre><table>
<thead>
<tr>
<th align="center">含义</th>
<th align="center">具体</th>
<th align="center">触发时机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">精确匹配</td>
<td align="center">/具体的名称</td>
<td align="center">只有url路径是具体的名称的时候才会出发Servlet</td>
</tr>
<tr>
<td align="center">后缀匹配</td>
<td align="center">*.xxx</td>
<td align="center">只要是以xxx结尾的就匹配</td>
</tr>
<tr>
<td align="center">通配匹配符</td>
<td align="center">/*</td>
<td align="center">匹配所有的请求,包括服务器的所有资源</td>
</tr>
<tr>
<td align="center">通配匹配符</td>
<td align="center">/</td>
<td align="center">匹配所有的请求,包括服务器的所有资源,不包括.jsp</td>
</tr>
<tr>
<td align="center">&gt;   <strong>通配符的匹配并不影响精确匹配的结果</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>load-on-startup标签
    * 元素标记容器是否在web应用启动的时候加载servlet
    * 值必须是整数，值越小，优先级越高，加载的时机越早，表示在初始化时被加载的顺序
    * 如果不写或者是负数，表示在servlet被使用的时候加载
    * 如果值相同，则按照顺序加载servlet,0优先级最高

2. 使用注解配置（Servlet3.0之后）
    类名之上添加，不用在.xml中配置
    @WebServlet注解
        属性：
            * name:servlet的名称，可以不写
            * value:配置url路径，可以配置多个
            * urlPattens:配置url路径，与value作用相同，但不能同时使用
            * loadOnStartup:表示配置创建servlet的时间，默认-1，表示在访问的时候创建

注解和web.xml之间没有冲突</code></pre><h2 id="Servlet应用"><a href="#Servlet应用" class="headerlink" title="Servlet应用"></a>Servlet应用</h2><h3 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h3><pre><code>获取客户端请求，所有的客户端的请求数据都存在于Request对象里</code></pre><h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><pre><code>1. get提交的数据会放在URL之后，以?分隔，URL和数据，参数之间以&amp;连接
2. get方式明文传递，数据量小，不安全
3. 效率高，浏览器默认为GET请求
4. 对应的方法为GET</code></pre><h4 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h4><pre><code>1. post请求把提交的数据放在HTTP的Body中
2. post密文传输，数据量大，安全
3. 效率相对不高
4. 对应的Servlet方法是doPost</code></pre><h4 id="Request的常用方法"><a href="#Request的常用方法" class="headerlink" title="Request的常用方法"></a>Request的常用方法</h4><pre><code>1. 方法</code></pre><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String getParameters(String name)</td>
<td align="center">组件名称</td>
<td align="center">根据表单组件名称获取数据</td>
</tr>
<tr>
<td align="center">void setCharacterEncoding(String chaset)</td>
<td align="center">设置字符编码</td>
<td align="center">指定请求的编码</td>
</tr>
</tbody></table>
<h4 id="Request的应用"><a href="#Request的应用" class="headerlink" title="Request的应用"></a>Request的应用</h4><pre><code>1. 从表单中使用get方法获取数据</code></pre><blockquote>
<pre><code>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    //1.获取用户的请求
    String username = req.getParameter(&quot;username&quot;);
    String password = req.getParameter(&quot;password&quot;);
    System.out.println(&quot;username:&quot;+username+&quot;  --&gt; &quot;+&quot;password:&quot;+password);
}
&lt;form action=&quot;register&quot; method=&quot;get&quot;&gt;
    用户名:&lt;label&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
&lt;/label&gt;&lt;br/&gt;
    密码:&lt;label&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;
&lt;/label&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;
&lt;/form&gt;</code></pre></blockquote>
<pre><code>通过浏览器的内容可看出，使用get方法提交的数据是明文，以?分隔URL和数据，以&amp;拼接参数

问题：get方法参数乱码
    客户端和服务器端的编码不一致，可以使用统一的编码格式，按照此编码进行数据的传输和接受

    Tomcat的7以及以下版本，客户端以UTF-8的编码格式进行数据传输，服务器以ISO8859-1的字符编码来接收数据，两边的编码方式不一样，导致乱码问题。

    可以在服务器接受收数据的时候以IOS8859-1来接收，在进行编码转换

    Tomcat的8版本解决了get方法的乱码问题

2. 使用post方法获取数据</code></pre><blockquote>
<pre><code>protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
  //设置统一编码
  req.setCharacterEncoding(&quot;UTF-8&quot;);     
    //1.获取用户的请求
    String username = req.getParameter(&quot;username&quot;);
    String password = req.getParameter(&quot;password&quot;);
    System.out.println(&quot;username:&quot;+username+&quot;  --&gt; &quot;+&quot;password:&quot;+password);
}
&lt;form action=&quot;register&quot; method=&quot;get&quot;&gt;
    用户名:&lt;label&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
&lt;/label&gt;&lt;br/&gt;
    密码:&lt;label&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;
&lt;/label&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;
&lt;/form&gt;</code></pre></blockquote>
<pre><code>通过浏览器的内容可看出，使用post方法提交的数据没有出现数据信息,只有接受的路径名称，更安全

问题：post中文乱码
    客户端的编码格式为UTF-8,在post使用的时候，将服务器的编码格式转化为UTF-8
    使用ServletRequest的setCharacterEncoding设置编码</code></pre><h2 id="Respone对象"><a href="#Respone对象" class="headerlink" title="Respone对象"></a>Respone对象</h2><pre><code>响应客户端请求，并向客户端输出信息    </code></pre><h3 id="Resopne的主要方法"><a href="#Resopne的主要方法" class="headerlink" title="Resopne的主要方法"></a>Resopne的主要方法</h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>setHeader(name,value)</td>
<td>设置响应信息头</td>
</tr>
<tr>
<td>setContentType(String)</td>
<td>设置响应文件类型,文件编码</td>
</tr>
<tr>
<td>setCharacterEncoding(String)</td>
<td>设置响应编码</td>
</tr>
<tr>
<td>getWriter()</td>
<td>获取字符输出流,返回数据</td>
</tr>
</tbody></table>
<h4 id="响应数据给客户端"><a href="#响应数据给客户端" class="headerlink" title="响应数据给客户端"></a>响应数据给客户端</h4><blockquote>
<pre><code>//响应数据给客户端
  resp.setCharacterEncoding(&quot;UTF-8&quot;);
  PrintWriter printWriter = resp.getWriter();
  printWriter.println(&quot;OK&quot;)</code></pre></blockquote>
<pre><code>问题：出现中文乱码
    和Request的乱码原因相同
    1. 方法一
    * 使用setCharacterEncoding(&quot;UTF-8&quot;)方法来进行服务端编码格式设置
    * 使用setHeader(&quot;Content-type&quot;,&quot;text/html;charset=UTF-8&quot;);
    2. 方法二
    * setContentType(&quot;text/html;charset=UTF-8&quot;),同时设置文件类型和编码格式，必须在获取输出流之前使用</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>问题
1. 在servlet中，调用业务逻辑和显示页面都在同一个servlet中，职能不单一，不利于后期维护
2. 可以将业务逻辑和显示信息分离

单独写类进行业务逻辑，和显示信息的打印
XxxController extend HttpServlet
XxxJsp extend HttpServlet

如何跳转到JSP
如何将查询到的数据传送给展示的servlet</code></pre><h3 id="转发（request）"><a href="#转发（request）" class="headerlink" title="转发（request）"></a>转发（request）</h3><pre><code>转发的作用在服务器端，将请求发送给服务器的其他资源，共同完后一次请求</code></pre><h4 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h4><pre><code>1. 页面跳转实现
    在调用业务逻辑的servlet中，编写
        request.getRequestDispatcher(&quot;/目标url-patten&quot;).forward(request,respone)

    页面跳转属于同一次请求，客户端察觉不到转发的过程，在服务器内部进行跳转，地址栏不发生改变</code></pre><h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><pre><code>1. forword表示同一次请求，在服务器内部内部跳转，可以共享同一次request作用域的数据

2. request作用域: 拥有存储数据的空间，作用范围是一次请求(可以进行多次转发)
    * 可以将数据存储到request内部，在一次请求的内部进行数据传递，任意位置获取数据
    * 可以传递任意数据类型(基本数据类型，对象，集合等)

3. request数据存储：以键值对存储数据
    * request.setAttribute(key,value)：key，String类型，value,Object类型
    * 将数据以键值对的方式存储在数据空间内部

4. 获取数据
    * request.getAttribute(key)
    * 通过String类型的key访问value
    * 需要转换数据类型</code></pre><h4 id="转发的注意事项"><a href="#转发的注意事项" class="headerlink" title="转发的注意事项"></a>转发的注意事项</h4><pre><code>1. 转发是服务器的行为
2. 转发浏览器只有一次请求
3. 浏览器地址不变
4. 转发两次的跳转信息不会丢失，可以使用request作用域传递数据
5. 转发只能将请求转发给同一个web中的组件</code></pre><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><pre><code>重定向作用在客户端，客户端将请求发送给服务器之后，服务器响应给客户端一个新的请求地址，客户端重新发送请求</code></pre><h4 id="页面跳转-1"><a href="#页面跳转-1" class="headerlink" title="页面跳转"></a>页面跳转</h4><pre><code>1. 实现
    * respone.sendRedirect(&quot;目标URI&quot;)
    * 表示服务器中的一个资源，资源在服务器中的路径(/项目/资源)

    客户端做了两次请求，地址栏发生了改变</code></pre><h4 id="数据传递-1"><a href="#数据传递-1" class="headerlink" title="数据传递"></a>数据传递</h4><pre><code>1. sendRedirect跳转时，地址栏发生改变，代表客户端重新发送的请求，属于两次请求

2. respone没有作用域，两次的request数据无法共享

3. 传递数据：
    使用拼接字符串进行数据传递(&quot;/webproject/b&quot;+&quot;?name=1&amp;password=1&quot;)

4. 获取数据
    使用request.getParameters,只能是string的数据类型</code></pre><h4 id="重定向注意实项"><a href="#重定向注意实项" class="headerlink" title="重定向注意实项"></a>重定向注意实项</h4><pre><code>1. 客户端的行为
2. 浏览器有两次请求
3. 浏览器地址栏发生改变
4. 两次跳转的传输信息会丢失(request范围)
5. 重定向可以指向任意资源，包括其他站点的资源</code></pre><h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><h3 id="生命周期的四个阶段"><a href="#生命周期的四个阶段" class="headerlink" title="生命周期的四个阶段"></a>生命周期的四个阶段</h3><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><pre><code>1. 当用户第一次访问servlet时，由容器调用servlet的构造方法创建servlet对象，也可以在容器启动之后进行创建，使用load_on_startup可以控制对象的创建时间    
2. 只进行一次实例化</code></pre><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre><code>1. 在初始化阶段，init()被调用，方法定义在javax.servlet.Servlet的接口中，以servletConfig对象作为参数
2. init()只执行一次</code></pre><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><pre><code>1. 当客户端有一个请求，容器就会将ServletRequest与响应ServletRespone转给对应的servlet对象，以参数的形式传给service()
2. service()执行多次</code></pre><h4 id="死亡"><a href="#死亡" class="headerlink" title="死亡"></a>死亡</h4><pre><code>1. 当容器停止或者重新启动都会销毁servlet对象
2. destroy()执行一次</code></pre><h3 id="Servlet的特性"><a href="#Servlet的特性" class="headerlink" title="Servlet的特性"></a>Servlet的特性</h3><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><pre><code>1. 问题
    servlet对象只创建一个实例对象，类似于单例模式，而Tomcat服务器容器可以同时多个线程并发访问同一个servlet,如果某个线程对成员变量进行修改，会造成线程安全问题

2. 解决线程安全问题
    * synchronized同步锁
        将存在线程安全问题的代码放入synchroized内部

        但是servlet只进行一次实例化，在线程进行访问的时候，对业务进行上锁，多个其他线程会等待释放锁，效率比较低

    * 实现SingleThreadModel接口
        servlet实现SingleThreadModel接口，每个线程会创建自己的servlet实例，请求不存在资源共享的问题，没有线程安全问题，但是servlet已经不使用

    * 使用局部变量，防止共享资源的出现
        推荐使用局部变量进行数据操作</code></pre><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h3 id="现有问题"><a href="#现有问题" class="headerlink" title="现有问题"></a>现有问题</h3><pre><code>1. HTTP协议是无状态的，不能保存每次提交的信息
2. 如果用户发来一个新的请求，服务器无法知道是否与上次的请求有关
3. 如果需要多次进行请求的操作，没有关联，难以进行下去</code></pre><h3 id="状态管理的概念"><a href="#状态管理的概念" class="headerlink" title="状态管理的概念"></a>状态管理的概念</h3><pre><code>将浏览器与web服务器的多次交互当作一个整体来处理，并且将多次的交互数据保存下来</code></pre><h3 id="状态管理的分类"><a href="#状态管理的分类" class="headerlink" title="状态管理的分类"></a>状态管理的分类</h3><pre><code>1. 客户端状态管理：
    将状态保存在客户端：Cookie
2. 服务器状态管理：
    将状态保存在服务端：Session</code></pre><h2 id="Cookie的使用"><a href="#Cookie的使用" class="headerlink" title="Cookie的使用"></a>Cookie的使用</h2><h3 id="什么是Cookie"><a href="#什么是Cookie" class="headerlink" title="什么是Cookie"></a>什么是Cookie</h3><pre><code>1. Cookie是浏览器访问Web服务器的某个资源时，由web服务器在HTTP响应消息头中附带传送给浏览器的一小段数据(服务器创建，保存在浏览器端)
2. 一旦Web浏览器保存了某个Cookie，在每次访问该web服务器都应该将这个cookie附加在HTTP请求头上回传给服务器
3. 一个Cookie主要由标识该信息的名称和值组成(key:value)

Cookie的原理
    * 在浏览器首次连接服务器，并得到服务器的响应数据，由服务器创建一个Cookie响应给浏览器，浏览器将响应的Cookie进行存储
    * 在以后的请求中，每次的请求数据中都会增加Cookie数据，而服务器收到请求后会首先进行Cookie的比对，如果存在Cookie,就获取Cookie，进行下面的操作</code></pre><h3 id="创建Cookie"><a href="#创建Cookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h3><pre><code>1. 创建Cookie</code></pre><blockquote>
<pre><code>//1.创建Cookie对象
  Cookie ck = new Cookie(&quot;zxl&quot;,&quot;123456&quot;);
//2.将Cookie响应给浏览器
  resp.addCookie(ck);</code></pre></blockquote>
<blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/cookie1.png" alt="cookie在浏览器"><br><img src="/2020/09/19/servlet/cookie2.png" alt="cookie在浏览器2"></p>
<pre><code>2. 常用的设置：
    1. setPath()：指定可以获取Cookie的路径
    2. setMaxAge():设置生命周期    
        * &gt;0:设置过期时间，以秒为单位，不随浏览器的关闭而结束
        * =0:浏览器关闭,Cookie结束
        * &lt;0:浏览器临时存储，一旦内存清理或者浏览器关闭，就不存在，默认-1</code></pre><p><img src="/2020/09/19/servlet/cookie_setting.png" alt="Cookie的设置"></p>
<h3 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h3><pre><code>获取Cookie必须包含创建cookie对象时允许访问的的路径，即在创建cookie的setPath</code></pre><blockquote>
<pre><code>//获取Cookie
Cookie[] cookies = req.getCookies()；
//2.获取需要的cookies
if(cookies != null){
   for(Cookie cookie:cookies){
      System.out.println(&quot;cookie&quot;+cookie.getName()+&quot;---&gt;&quot;+cookie.getValue());
   }
}</code></pre></blockquote>
<h3 id="修改Cookie"><a href="#修改Cookie" class="headerlink" title="修改Cookie"></a>修改Cookie</h3><pre><code>只需要保证Cookie的名称和路径一致，就可以覆盖原来的cookie，只是名称一样的，不会进行覆盖
其余步骤和创建cookie一样</code></pre><blockquote>
<pre><code>Cookie ck = new Cookie(&quot;1&quot;,&quot;1&quot;)；
ck.setPath(&quot;/webs&quot;)；
ck.setMaxAge(60*60)；
resq.addCookie(ck)；</code></pre></blockquote>
<h3 id="Cookie编码与解码"><a href="#Cookie编码与解码" class="headerlink" title="Cookie编码与解码"></a>Cookie编码与解码</h3><pre><code>Cookie是不需要中文的，只能包含ASCII码，如果需要使用unicode，需要进行编码和解码    </code></pre><p><img src="/2020/09/19/servlet/charset.png" alt="编码异常"></p>
<pre><code>* 编码可以使用java.net.URLEncoder的encode(String str,String encoding)
* 解码可以使用java.net.URLDecoder的decode(String str,String encoding)</code></pre><h4 id="创建-读取带有中文的Cookie"><a href="#创建-读取带有中文的Cookie" class="headerlink" title="创建 读取带有中文的Cookie"></a>创建 读取带有中文的Cookie</h4><p><img src="/2020/09/19/servlet/encode_decode.png" alt></p>
<h3 id="Cookie的优点和缺点"><a href="#Cookie的优点和缺点" class="headerlink" title="Cookie的优点和缺点"></a>Cookie的优点和缺点</h3><pre><code>1. 优点：
    * 可以配置到期规则
    * 简单：基于文本结构，包含简单的键值对
    * 数据持久性：Cookie默认在到期之前可以一直存在于浏览器

2. 缺点
    * 数据大小受限制：一般浏览器的Cookie在4k,8k字节的限制
    * 用户配置为禁用，会限制Cookie的使用
    * cookie可能被篡改，对安全性造成威胁</code></pre><h2 id="Session对象"><a href="#Session对象" class="headerlink" title="Session对象"></a>Session对象</h2><h3 id="Session概述"><a href="#Session概述" class="headerlink" title="Session概述"></a>Session概述</h3><pre><code>1. Session用于记录用户的状态，是指在一段时间内，单个客户端与Web服务器的一连串相关的交互过程
2. 在一个Session中，一个用户可能会多次请求同一个资源，也有可能访问不同的服务器资源

Session的原理：
    * 服务器会为每一个会话分配一个Session对象
    * 同一个浏览器的多次请求，同属于一个会话
    * 首次使用Session时，服务器会创建Session，并创建Cookie存储SessionId发回服务器

Session对象是由服务器创建的，存储于服务器端</code></pre><h3 id="Session使用"><a href="#Session使用" class="headerlink" title="Session使用"></a>Session使用</h3><pre><code>1. Session作用域：拥有存储数据的空间，作用范围是一次会话
    * 一次会话，是使用同一个浏览器发送的多次请求，一旦浏览器关闭，则会话结束
    * 可以将数据存入Session,在一次会话的任意位置进行获取
    * 可以传递任意数据类型（基本数据，字符串，数组，集合等）</code></pre><h4 id="获取Session对象"><a href="#获取Session对象" class="headerlink" title="获取Session对象"></a>获取Session对象</h4><pre><code>在浏览器首次连接服务器时，服务器自动创建Session对象，并创建Cookie返回sessionId
//1.通过request对象获取Session对象</code></pre><p><code>HttpSession session = request.getSession();</code><br><code>System.out.println(session.getId());</code></p>
<h3 id="Session数据传递"><a href="#Session数据传递" class="headerlink" title="Session数据传递"></a>Session数据传递</h3><h4 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h4><pre><code>* setAttribute(属性名，Object)
    session.setAttribute(key,value);以键值对的形式存储数据</code></pre><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><pre><code>* getAttribute(属性名)
    session.getAttribute(key);获取数据</code></pre><h4 id="移除数据"><a href="#移除数据" class="headerlink" title="移除数据"></a>移除数据</h4><pre><code>* removeAttribute(key)
    session.removeAttribute(key)</code></pre><h3 id="Session的生命周期"><a href="#Session的生命周期" class="headerlink" title="Session的生命周期"></a>Session的生命周期</h3><pre><code>* 开始：浏览器首次使用到Session的请求，会创建Session
* 结束：
        浏览器关闭，则无效
        Session超时，则无效（可以设置最大有效时间，单位秒）
            session.setMaxInactiveInter
        手工销毁，则失效
            session.invalidate();//退出登录，注销</code></pre><h3 id="Session超时设置"><a href="#Session超时设置" class="headerlink" title="Session超时设置"></a>Session超时设置</h3><pre><code>session.setMaxInactiveInterval(60);</code></pre><h3 id="禁用session解决"><a href="#禁用session解决" class="headerlink" title="禁用session解决"></a>禁用session解决</h3><pre><code>由于session是借助cookie来进行传递的，如果浏览器禁止cookie，浏览器不会接收session，在下一次连接的时候，会创建一个新的session

URL重写：
    浏览器在访问服务器的地址时，不再使用原来的地址，而是经过改写的地址，原来的地址后面增加了sessionId

实现：
    使用respone.encodeRedirectURL(String url)生成新的URL，根据是否禁用cookie来在尾部追加SessionId</code></pre><h3 id="Seeeion的案例"><a href="#Seeeion的案例" class="headerlink" title="Seeeion的案例"></a>Seeeion的案例</h3><pre><code>* 进行登录验证</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/session_exp_1.png" alt="Seeeion的案例_进行登录验证"></p>
<pre><code>* 进行邮箱验证</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/session_exp_2.png" alt="Seeeion的案例_进行登录验证"></p>
<h3 id="Request-Session的区别"><a href="#Request-Session的区别" class="headerlink" title="Request,Session的区别"></a>Request,Session的区别</h3><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/request_session.png" alt="请求和会话"></p>
<h3 id="重定向和转发的区别"><a href="#重定向和转发的区别" class="headerlink" title="重定向和转发的区别"></a>重定向和转发的区别</h3><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/redirect_forward.png" alt="重定向和转发"></p>
<h3 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h3><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/cookie_session.png" alt="cookie session"></p>
<pre><code>* cookie和session都是保存浏览器访问服务器的状态，使用方式和存储位置不一样
* cookie存储的数据都是字符串，需要使用`respone.addCookie()`,将数据响应给浏览器，可以一次响应多个Cookie
* sesssion可以存储任意类型数据，直接`session.setAttribute()`,一个会话只有一个Session，一个SessionId</code></pre><h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><pre><code>* 全局对象，拥有作用域，对应tomcat的一个web应用
* 当web服务器启动时，会为每一个web应用程序创建一个ServletContext对象，共享的存储区
* ServletContext在服务器启动的时候创建，服务器关闭的时候销毁</code></pre><h3 id="获取ServletContext"><a href="#获取ServletContext" class="headerlink" title="获取ServletContext"></a>获取ServletContext</h3><pre><code>1. 使用GenericServlet对象
    * getServletContext(),HttpServlet继承了GenericServlet,可以使用this.getServletContext()获取对象

2. HttPServletRequest对象
    * getServletContext()

3. HttpSession
    * getServletContext()</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><pre><code>1. 获取当前项目的真实路径：
    * context.getRealPath()

2. 获取项目的上下文名称：部署时的路径，项目的名称
    * context.getContextPath()

3. 全局容器 : 整个web应用都可以使用
    * 存储数据：setAttribute(string,object)
    * 获取数据：getAttribute(string)
    * 移除数据：removeAttribute(string)</code></pre><h3 id="ServletContext特点"><a href="#ServletContext特点" class="headerlink" title="ServletContext特点"></a>ServletContext特点</h3><pre><code>* 唯一性：一个项目只有一个ServletContext
* 生命周期：只要容器不关闭或者应用不卸载，servletContext一直存在</code></pre><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 统计当前项目的访问次数</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/servletcontext_count.png" alt="servletcontext"></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><pre><code>现有问题
    代码冗余，可以抽取代码，比如编码问题</code></pre><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><pre><code>过滤器(Filter)是位于客户端和服务器目标资源的一道过滤技术</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/filter_exe.png" alt="过滤器的执行流程"></p>
<h3 id="filter作用"><a href="#filter作用" class="headerlink" title="filter作用"></a>filter作用</h3><pre><code>1. 执行在servlet之前，客户端发送请求的时候，会先经过过滤器，再到达目标资源；响应的时候，会根据执行流程再次反向执行filter
2. 可以解决多个servlet的代码冗余问题，编码处理，登录验证</code></pre><h3 id="filter的编写"><a href="#filter的编写" class="headerlink" title="filter的编写"></a>filter的编写</h3><pre><code>Servlet API提供了一个Filter接口，只要实现了这个接口，就会成为过滤器（Filter）</code></pre><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><pre><code>1. 编写java的实现代码
2. 编写doFileter()方法
3. 让请求继续下去，使用FilterChain,拦截链
    filterChain.doFilter(req,resp):让请求继续下去

在响应的时候，也会将响应传递给过滤器，然后再传递给客户端</code></pre><h3 id="filter的配置"><a href="#filter的配置" class="headerlink" title="filter的配置"></a>filter的配置</h3><pre><code>1. 注解配置
    @WebFilter(value = &quot;/过滤的目标资源&quot;)

2. 在web.xml中配置filter
    使用filter filter-mapping</code></pre><h3 id="过滤器链和过滤优先级"><a href="#过滤器链和过滤优先级" class="headerlink" title="过滤器链和过滤优先级"></a>过滤器链和过滤优先级</h3><pre><code>1. 过滤器链
    * 客户端对服务器请求之后，服务器会执行一组过滤器，那么这组过滤器就叫做过滤器链。
    * 每个过滤器实现特定的功能当第一个过滤器的doFilter方法被调用的时候，web服务器会创建一个代表过滤器链的filterChain对象，在doFilter方法中，开发人员如果调用了`FilterChain`的`doFilter`方法，web服务器会检查是否还有其他的过滤器，如果还有，就会执行第二个过滤器，如果没有，就调用目标资源。

2. 过滤器链的优先级
    * 如果全是注解，会按照类全名称的字典顺序
    * 如果全是xml,按照filter的注册顺序，从上往下
    * 两者都有，xml的优先级高于注解
    * 同时配置，会执行多次过滤</code></pre><h3 id="filter拦截路径设置"><a href="#filter拦截路径设置" class="headerlink" title="filter拦截路径设置"></a>filter拦截路径设置</h3><pre><code>1. 精确拦截;
    /index.jsp
2. 后缀拦截:
    *.jsp，不需要加/
3. 通配符拦截
    /* ,/aaa/bbb/*
    不能使用/进行拦截</code></pre><h3 id="filter使用场景"><a href="#filter使用场景" class="headerlink" title="filter使用场景"></a>filter使用场景</h3><pre><code>1. 过滤器解决编码问题
    * 统一解决字符编码问题
2. 解决权限验证问题
    * 在过滤器中验证是否登录过服务器</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/errors_01.png" alt></p>
]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM</title>
    <url>/2020/09/18/ssm/</url>
    <content><![CDATA[<h2 id="SSM框架的整合"><a href="#SSM框架的整合" class="headerlink" title="SSM框架的整合"></a>SSM框架的整合</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>SSM,spring springmvc mybatis三大框架的整合，可以使用多种方式，这里使用xml+注解的方式</code></pre><h3 id="整合的思路"><a href="#整合的思路" class="headerlink" title="整合的思路"></a>整合的思路</h3><pre><code>1. 以spring框架为核心，进行其他的框架的整合(针对各个框架的使用范围进行整合)</code></pre><p><img src="/2020/09/18/ssm/ssm_1.png" alt></p>
<h4 id="导入的坐标版本"><a href="#导入的坐标版本" class="headerlink" title="导入的坐标版本"></a>导入的坐标版本</h4><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_version.png" alt="使用的坐标版本"></p>
<h4 id="日志文件的配置"><a href="#日志文件的配置" class="headerlink" title="日志文件的配置"></a>日志文件的配置</h4><pre><code>1. pom.xml
    * log4j
    * slf4j-api
    * slf4j-log4j12
        完成日志文件的配置，将标准日志转为log4j格式日志</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_log.png" alt="日志文件的配置"></p>
<pre><code>2. log4j.propreties配置文件</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_log2.png" alt="日志文件的配置"></p>
<h4 id="spring框架的配置"><a href="#spring框架的配置" class="headerlink" title="spring框架的配置"></a>spring框架的配置</h4><pre><code>1. pom.xml配置
    * spring-context: 容器，扫描数据
    * spring-aop
    * spring-tx
    * spring-test:单元测试
    * spring-jdbc
    * aspectjweaver:切入点，切面
    * jstl: Java EL表达式</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_spring1.png" alt="spring的配置1"></p>
<pre><code>2. applicationContext.xml的配置
    * 配置需要扫描的包，指定不需要扫描的MVC层的包，MVC的数据由springMV来进行数据扫描</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_spring2.png" alt="spring的配置2"></p>
<pre><code>3. 配置完上述的配置文件
    可以使用spring的注解，进行对象注册</code></pre><h4 id="springMVC的整合"><a href="#springMVC的整合" class="headerlink" title="springMVC的整合"></a>springMVC的整合</h4><pre><code>1. pom.xml配置
    * spring-web
    * spring-webmvc
    * servlet-api
    * jsp-api</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_springmvc1.png" alt="springmvc的配置"></p>
<pre><code>2. web.xml配置
    * DispatcherServlet：前端控制器
    * CharacterEncodingFilter: 字符编码过滤器

3. springmvc.xml配置
    * 开启注解扫描：controller由springmvc来进行扫描
    * 开启视图解析器：InternalViewResolver
    * 配置静态资源过滤：mvc:resources
    * 配置开启springmvc注解支持
    * 配置监听器</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_springmvc2.png" alt="springmvc的配置"></p>
<pre><code>4. spring整合springMVC
    在启动服务器的时候，加载web.xml文件的时候，只加载了springMVC的配置文件，没有读取spring的配置文件来进行容器的创建以及加载。

    使用监听器：ContextLoaderListener,来监听ServletContext实例的创建，一旦创建，就会扫描spring的配置文件，进行spring容器的创建

    监听器的默认配置文件：/WEB-INF/applicationContext.xml
        1. 在/WEB-INF/复制文件
        2. 使用&lt;context-param&gt;进行容器扫描路径的配置</code></pre><p><img src="/2020/09/18/ssm/ssm_listener.png" alt="spring整合springmvc"></p>
<pre><code>5. 监听器的配置
    使用spring框架的监听器，在创建ServletContext的时候，同时扫描spring的配置文件，可以通知框架注册实例，以供数据注入</code></pre><h4 id="MyBatis的整合"><a href="#MyBatis的整合" class="headerlink" title="MyBatis的整合"></a>MyBatis的整合</h4><pre><code>1. pom.xml文件的配置
    * mybatis
    * mysql-connector-java
    * c3p0
    * mybatis-spring 整合jar包

2. SqlMapConfig.xml配置
    * typeAlisaes：为实体类创建别名，使用package
    * 数据库连接环境
    * mappers: 配置映射文件

3. 整合思路
    * 将数据的DAO层的代理对象存入容器
    * 步骤
        1. 在applicationContext.xml文件编写使用MyBatis的文件步骤
        2. 编写数据库连接池bean对象</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/mybatis_spring_1.png" alt="数据连接池"></p>
<pre><code>3. 配置SqlSessionFactoryBean对象
可以使用参数设置生成的bean的名称，指定读取的配置文件以及mapper的配置文件</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/mybatis_spring_2.png" alt="将dao对象交由spring容器创建"></p>
<pre><code>4. 配置扫描的映射文件所在的包</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/mybatis_spring_3.png" alt="将dao对象交由spring容器创建"></p>
<pre><code>        5. 总结
            spring整合mybatis时，可以在核心配置文件applicationContext.xml中，整合mybatis的配置文件，可以将SqlMapConfig.xml文件的内容完全整合进核心配置文件，也可以整合部分，然后在核心配置文件中引用SqlMapConfig.xml文件。

4. 出现的错误</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/erroer_1.png" alt="web.xml或使用此应用程序部署的jar文件中解析"><br><img src="/2020/09/18/ssm/error_2.png" alt="classnotfound:org.apache.jsp.">    </p>
<h4 id="spring的声明式事务控制"><a href="#spring的声明式事务控制" class="headerlink" title="spring的声明式事务控制"></a>spring的声明式事务控制</h4><pre><code>1. 配置事务管理器
2. 配置事务通知
    * 配置事务的使用位置，传播级别。。
3. 配置AOP
    * 配置切入点表达式
    * 配置事务</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_transaction.png" alt="事务管理"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2020/09/18/springMVC/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><pre><code>1. B/S，浏览器/服务器模式的开发中，服务端程序一般分为三层，展示层，业务层和持久层。
    * 展示层：WEB层，用来与客户端进行数据交互的，表现层采用MVC的设计
    * 业务层：处理业务逻辑
    * 持久层：与数据库进行交互

2. MVC?
    MVC(Model View Controller):模型视图控制器，一种设计模式
    * Model: javabean,通常代指数据模型，用于封装数据
    * View:  jsp,jsp或者html,用于展示数据
    * Controller: servlet,处理用户交互的部分，处理程序逻辑的部分</code></pre><h3 id="SpringMVC的入门案例"><a href="#SpringMVC的入门案例" class="headerlink" title="SpringMVC的入门案例"></a>SpringMVC的入门案例</h3><pre><code>1. 项目环境搭建
    1. 选择maven工程的archetype
    2. 选择webapp模板
    3. 填写项目名称等信息
    4. 添加archetypeCagalog internal加快项目创建的速度
    5. 使用webapp在main目录下创建java和resources目录，并使用mark directory as声明</code></pre><blockquote>
<p><img src="/2020/09/18/springMVC/maven_createproject_quickstart.png" alt="maven_createproject_quickstart"></p>
</blockquote>
<blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/change_directory.png" alt="change_directory"></p>
<pre><code>2. 配置MVC项目的步骤
    1. 配置前端控制器，在servlet上配置控制器,主要是访问路径以及拦截</code></pre><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置前端控制器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<pre><code>&lt;!-- 配置过滤器 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;:初始化参数
              &lt;param-name&gt;encoding&lt;/param-name&gt;
              &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;</code></pre></blockquote>
<pre><code>2. 配置TomCat服务器
    配置项目路径，端口等服务器信息配置</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/quickstart_tomcat.png" alt="tomcat设置"></p>
<pre><code>3. 配置视图解析器
    在项目配置文件中配置视图解析器，配置前缀路径以及后缀文件名</code></pre><h3 id="SpringMVC实例解析"><a href="#SpringMVC实例解析" class="headerlink" title="SpringMVC实例解析"></a>SpringMVC实例解析</h3><pre><code>1. SpringMVC的流程的说明
    * 启动服务器，加载配置文件
        1. DispacherServet被创建
        2. springmvc.xml被加载
        3. HelloController被加载到容器
        4. 开启注解扫描的包，配置视图解析器，开启MVC注解
    * 发送http请求，后台处理</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/quickstart_1.png" alt><br><img src="/2020/09/18/springMVC/quickstart_2.png" alt></p>
<pre><code>2. springMVC的三大组件(容器)
    * 处理器映射器：HandlerMapping
    * 处理器适配器：HandlerAdapter
    * 视图解析器：ViewResolver

    在开启springMVC的注解时，会自动加载处理器映射器，处理器适配器</code></pre><h2 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h2><h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><pre><code>1. @RequestMapping：建立请求和方法之间的关联
    path,value:请求路径的字符串

2. 使用位置
    * 放在方法上，可以直接使用路径来请求数据，二级目录
    * 放在类上，类上的路径为一级目录，可以先访问一级目录再访问二级目录的方法</code></pre><p><img src="/2020/09/18/springMVC/requestmapping.png" alt></p>
<pre><code>3. RequestMapping的属性: 任意两个属性之间是&amp;&amp;的关系
    1. value,path: 互为别名，都是指定请求的路径,请求的URL
    2. mathod: 用于指定请求的方法，method={RequestMethod.GTE,RequestMethod.POST}等
    3. params: 指定限制请求参数的条件，支持简单的表达式，要求请求参数中的key和value必须和配置一样
        * params={&quot;accountName&quot;},请求参数中必须要有accountName
        * params={&quot;money!100&quot;},请求参数money不能是100
    4. headers: 发送的请求中必须包含的请求头</code></pre><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><pre><code>1. 含义
    把请求中指定名称的参数传给控制器的形参（形参赋值）

2. 使用位置
    * 只能定义在参数上
    * 在请求的参数名称和方法上的形参名称不一样时，使用注解进行映射

3. 属性
    1. name,value: 请求中的参数名称
    2. required: 默认true，请求中的参数名称必须与name属性的值相同</code></pre><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><pre><code>1. 含义
    用于获取请求体内容，直接使用得到的是 key=value&amp;key=value 的数据    
    get请求方式不适用，参数不在请求体

2. 属性
    required:是否必须要有请求体，默认为true。当取值为true时，使用get方式报错，为false时，使用get获取数据为null

3. 使用
    注解定义在参数上
    直接注解将请求体内部的数据以键值对的方式赋给指定的形参</code></pre><h4 id="PathVarible"><a href="#PathVarible" class="headerlink" title="@PathVarible"></a>@PathVarible</h4><pre><code>1. 含义
    绑定url中的占位符，url中有/delete/{id},{id}就是占位符

2. 属性
    * value: 指定占位符的名称
    * required: 必须包含占位符

3. 使用
    * 只能作用在参数上
    * value的名称必须和访问路径下的占位符的名称一致
    * 访问时只需要在访问路径的占位符上添加数据就可以了</code></pre><h5 id="RESTful编程风格"><a href="#RESTful编程风格" class="headerlink" title="RESTful编程风格"></a>RESTful编程风格</h5><pre><code>1. Representational State Transfer：
    表述性状态转换

2. 请求地址相同，但是具体的请求方法不同
    * 获取：GET
    * 创建：POST
    * 更新：PUT
    * 删除：DELETE</code></pre><h5 id="HiddentHttpMethodFilter"><a href="#HiddentHttpMethodFilter" class="headerlink" title="@HiddentHttpMethodFilter"></a>@HiddentHttpMethodFilter</h5><pre><code>1. 说明
    浏览器form表单只支持GET,POST请求，DELETE以及PUT不支持，这个过滤器可以将浏览器的请求改为指定的请求方式</code></pre><h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h4><pre><code>1. 说明
    获取请求头

2. 属性
    * name,value: 指定需要获取请求头中的那个属性名称
    * required: 默认true,是否必须有此属性名称

3. 使用
    * 只能作用在参数上
    * 必须指定想要获取的标签的名称</code></pre><h4 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h4><pre><code>1. 说明
    把指定的Cookie名称的值传入控制器方法参数

2. 属性
    * value: 指定Cookie的名称
    * required: 是否必须有此cookie

3. 使用
    * 作用在参数上
    * 需要指定cookie的key</code></pre><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h4><pre><code>1. 说明
    可以出现在方法和参数上
    * 方法：当前方法会在控制器的方法执行之前先执行，可以修饰没有返回值的方法，也可以修饰有返回值的方法
    * 参数：获取指定的参数给属性赋值

2. 属性
    * value: 用于获取数据的key,数据类型可以是JavaBean,也可以是集合

3. 使用
    * 当表单提交的字段不完整，可以保证没有提交的数据使用数据库原本的字段数据    </code></pre><h4 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h4><pre><code>1. 说明
    用于多次执行控制器方法之间的参数共享

2. 属性
    * value: 指定存入的属性名称
    * type: 指定存入的数据类型

3. 使用
    * 只能作用在类上
    * 可以借助Model来将数据存入Request域中</code></pre><h2 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>1. 绑定机制
    1. 表单提交的数据都是key=value格式的，username=hh&amp;password=oooo
    2. SpringMVC的参数绑定过程是把表单提交的数据作为控制器中的参数进行绑定的
    3. 表单的name和参数的名称必须是一样的（不一致可以使用@RequestParam）

2. 支持的数据类型
    1. 基本数据类型和字符串类型
    2. 实体类型（javaBean）
    3. 集合数据类型（List,Map）

3. 基本数据类型和字符串类型
    * 表单中的name属性和参数列表的名称一致，可以直接进行封装
    * 表单中的name属性和参数列表的名称不一致

4. 实体类型
    1. 简单的JavaBean
        * 表单中的name属性和实体类的属性名称一致，框架会自动封装
        * 使用@RequestParam进行映射

    2. 包含其他的JavaBean引用
        * 将引用的其他JavaBean的属性名称连同该对象的属性作为表单的name属性

5. 集合数据类型
    将集合的引用以及属性进行数据封装</code></pre><p><img src="/2020/09/18/springMVC/connection.png" alt="集合的参数封装"></p>
<h4 id="数据转换器"><a href="#数据转换器" class="headerlink" title="数据转换器"></a>数据转换器</h4><pre><code>1. 说明
    表单传输的数据都是字符串类型，SpringMVC框架进行了数据类型转换
    string-&gt; Integer, Double,...
    字符串转换为Date时，格式不正确，需要显式指定自定义类型转换器

2. 使用接口
    将S类型的数据转换为T类型
    public interface Converter&lt;S,T&gt;{
        T converter(S); S:source,T:target
    }
    将指定的数据类型进行转换，实现converter

3. 使用步骤
    1. 编写Converter接口的实现类，实现converter方法
    2. 配置自定义类型转换器
        * springMVC项目配置文件中配置，将自定义配置类加入ConversionServiceFactortBean中
    3. 配置转换器服务</code></pre><p><img src="/2020/09/18/springMVC/defaultconversion.png" alt="自定义类型转换器"></p>
<h2 id="Servlet-API"><a href="#Servlet-API" class="headerlink" title="Servlet API"></a>Servlet API</h2><h3 id="获取原生的Servlet-API"><a href="#获取原生的Servlet-API" class="headerlink" title="获取原生的Servlet API"></a>获取原生的Servlet API</h3><pre><code>1. 获取方式
    使用参数获取的方式，将希望获取到的对象作为参数绑定到路径

2. 实例
    @RequestMapping(&quot;/servletAPI&quot;)
    public String testServletAPI(HttpServletRequest request){

    }</code></pre><h2 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><pre><code>因为配置了视图解析器，包含String类型返回值，会自动解析我们配置的静态资源，会到指定的路径寻找返回值名称相同的文件
1. 字符串代表一个静态或者动态页面
2. 在方法中获取需要的数据，使用Request域来获取，将其填充在页面上显示</code></pre><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><pre><code>1. 默认值，返回一个和当前方法相同的访问路径的一个jsp文件</code></pre><p><img src="/2020/09/18/springMVC/void_01.png" alt="默认返回值void"></p>
<pre><code>2. 可以使用servlet的请求转发，重定向
    * 转发：request.getRequestDispatcher(&quot;/WEB-INF/pages/xx.jsp&quot;).forward(req,resp);
        自已手动转发的路径必须写当前项目的全路径，视图解析器不再自动寻找路径

    * 重定向：response.sendRedirect(req.getContextPath()+&quot;/WEB-INF/pages/xx.jsp&quot;)

    转发在当前的web项目内部进行，不需要带项目名称；重定向，不知道项目路径，需要加上项目路径

3. 直接进行响应
    直接使用输出流来响应数据</code></pre><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><pre><code>1. 说明
    ModelAndView对象为spring提供的一个对象，可以用来调整具体的JSP视图

2. 使用
    创建ModelAndView对象，使用addObject(key,Object)添加数据
    使用setViewName()指定返回的页面

    返回值String类型的与ModelAndView的实现机制相同，String基于ModelAndView来实现的</code></pre><p><img src="/2020/09/18/springMVC/model.png" alt></p>
<h3 id="使用关键字来进行转发和重定向"><a href="#使用关键字来进行转发和重定向" class="headerlink" title="使用关键字来进行转发和重定向"></a>使用关键字来进行转发和重定向</h3><pre><code>1. 需要使用视图解析器来进行资源的获取
    如果没有配置视图解析器，需要手动配置转发和重定向的路径

2. 基于返回值为字符串的方式
    * &quot;forward:success&quot; : 转发到配置好的路径下的指定后缀的页面
    * &quot;rediect:success&quot; ：重定向

3. 注意
    使用关键字，会使用UrlBaseViewReslover进行视图解析，会使用到配置的视图解析器</code></pre><h3 id="JSON数据：ResponseBody响应"><a href="#JSON数据：ResponseBody响应" class="headerlink" title="JSON数据：ResponseBody响应"></a>JSON数据：ResponseBody响应</h3><h4 id="过滤静态资源"><a href="#过滤静态资源" class="headerlink" title="过滤静态资源"></a>过滤静态资源</h4><pre><code>1. 问题
    在配置前端控制器的时候，使用了通配符 / 来进行URL拦截，DispatcherServlet拦截了除了.jsp之外的所有资源，静态资源也会被拦截，从而不能使用。如果希望不拦截静态资源，可以再springmvc.xml中配置。

2. 解决</code></pre><blockquote>
<pre><code>&lt;!-- 配置静态资源过滤: js下的文件不进行拦截 --&gt;
&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt; &lt;!-- js文件 --&gt;
&lt;mvc:resources mapping=&quot;/images/**&quot; location=&quot;/images/&quot;/&gt;
&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot;/&gt;</code></pre></blockquote>
<pre><code>location: webapp目录下的所有指定文件
mapping: 表示以/static开头的所有的请求路径</code></pre><h4 id="响应json格式数据"><a href="#响应json格式数据" class="headerlink" title="响应json格式数据"></a>响应json格式数据</h4><pre><code>1. 导入必须的包
    jackson-databind jackson-core jackson-annotations,可以由框架进行数据的赋值

2. 使用@ResponseBody
    将查询到的数据封装到json格式的页面中，完成异步请求，响应json格式数据</code></pre><h3 id="响应数据总结"><a href="#响应数据总结" class="headerlink" title="响应数据总结"></a>响应数据总结</h3><table>
<thead>
<tr>
<th align="center">返回值类型</th>
<th align="center">跳转页面</th>
<th align="center">要求</th>
<th align="center">使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String</td>
<td align="center">指定的返回字符串表示的页面</td>
<td align="center">使用视图解析器配置需要解析的页面</td>
<td align="center">在对应的文件夹下创建和返回值名称相同的页面</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">默认返回和访问路径相同的目录结构下的文件</td>
<td align="center">可以使用重定向和转发，Model来进行页面跳转，或者直接响应数据</td>
<td align="center">配合转发和重定向来使用</td>
</tr>
<tr>
<td align="center">ModelAndView</td>
<td align="center">使用setViewName()指定跳转的页面</td>
<td align="center">需要使用addAttribute()添加元素</td>
<td align="center">ModelMap</td>
</tr>
<tr>
<td align="center">关键字字符串</td>
<td align="center">使用关键字 redirect forward进行转发和重定向</td>
<td align="center">在返回值为字符串的格式下</td>
<td align="center">和String类似</td>
</tr>
<tr>
<td align="center">json格式数据</td>
<td align="center">返回json格式的数据</td>
<td align="center">使用第三方库来进行解析和包装</td>
<td align="center">使用@ResponseBody</td>
</tr>
</tbody></table>
<pre><code>* ModelAndView和String的实现机制类似
* 使用转发和重定向可以访问的资源范围不仅局限在定义的资源文件
* void的返回类型，可以使用上述三种方式来响应数据
* json格式的数据应该和ajax(异步 JavaScript XML)配合来使用</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="传统的文件上传"><a href="#传统的文件上传" class="headerlink" title="传统的文件上传"></a>传统的文件上传</h3><pre><code>1. form表单的要求
    * enctype的属性要求，multipart/form-data
    * method：post</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/file_upload.png" alt="文件上传1"></p>
<pre><code>2. 解析工具
    * 第三方jar包：commons-fileupload-1.4,commons-io-2.6</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/file_pom.png" alt="导入jar包"></p>
<pre><code>3. 步骤
    将本地文件上传至服务器
    * 编写文件上传的jsp文件
    * 导入第三方库，处理上传后的文件
    * 一旦提交表单，所有的数据会存在于request对象的域中，将数据传送给方法，进行处理</code></pre><blockquote>
<pre><code>//1.指定文件上传位置
    String path = request.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);
    System.out.println(path);
    //2.判断文件路径是否存在
    File file = new File(path);
    if (!file.exists()){
        //文件不存在，创建目录
        file.mkdirs();
    }
    //3.解析request对象，获取上传文件项
    DiskFileItemFactory fileItemFactory = new DiskFileItemFactory();
    ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);
    List&lt;FileItem&gt; fileItems = null;
    //4.解析
    try {
        fileItems = servletFileUpload.parseRequest(request);
        //遍历
        for(FileItem item:fileItems){
            //判断当前的item是否为上传文件项
            if(item.isFormField()){
                //普通表单
            }else {
                //上传文件
                //获取上传文件的名称
                String name = item.getName();
                //设置文件名称唯一,防止相同的文件名产生的覆盖
                String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
                name = uuid+&quot;_&quot;+name;
                //完成上传,指定路径上传文件
                item.write(new File(path,name));
                //删除临时文件
                item.delete();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }</code></pre></blockquote>
<h3 id="springMVC的文件上传"><a href="#springMVC的文件上传" class="headerlink" title="springMVC的文件上传"></a>springMVC的文件上传</h3><pre><code>1. 说明
    * springMVC框架提供了MultipartFile对象，该对象表示要上传的文件，要求变量名称必须和表单file标签的name属性名称相同
    * 由前端控制器获取请求，将请求传送给文件解析器来进行request对象的解析，获取文件上传项，再由控制器将获取到的文件上传项作为参数绑定到对应的方法上，在方法中只需要进行文件的上传就可以，不需要关注文件的解析和获取工作
    * 注意：
        参数绑定：方法的参数必须和file的name属性相同

2. 配置文件
    commons-fileupload connoms-io</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/springmvc_upload.png" alt="springMVC文件上传的原理"><br><img src="/2020/09/18/springMVC/springmvc_upload1.png" alt="springMVC文件上传的部分源码"></p>
<pre><code>一旦配置上传文件的大小，不能超过限制</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/springmvc_upload_error.png" alt="springMVC文件大小上传限制"></p>
<pre><code>2. 步骤
    * 书写文件上传表单
    * 配置文件解析器
        CommonsMultipartResoler,其中id属性必须为 multipartReslover
            可以进行依赖注入

    * 方法书写</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/springmvc_upload2.png" alt="springMVC文件上传"></p>
<h3 id="同一个服务器的文件上传总结"><a href="#同一个服务器的文件上传总结" class="headerlink" title="同一个服务器的文件上传总结"></a>同一个服务器的文件上传总结</h3><pre><code>springMVC的框架只是将解析文件的过程进行了封装，本质上还是使用FileItemFactory等进行文件解析，在方法中可以直接调用上传文件项

1. 通用上传文件步骤
    1. 获取上传文件目录，可以使用file.mkdirs()进行创建
    2. 对request域进行文件解析，获取文件项(FileItem)[文件解析器]
    3. 生成唯一Id,防止文件覆盖，UUID.randomUUID().toString().replace(&quot;_&quot;,&quot;&quot;);
    4. 文件上传，transferTo(new File(path,name));将文件上传到指定的路径下，生成指定文件名称的文件
    5. 清理临时文件</code></pre><h3 id="跨服务器方式的文件上传"><a href="#跨服务器方式的文件上传" class="headerlink" title="跨服务器方式的文件上传"></a>跨服务器方式的文件上传</h3><pre><code>1. 分服务器的目的
    不同的功能服务器将其分开，方便开发
        * 应用服务器
        * 数据库服务器
        * 缓存服务器

2. 步骤
    * 导入跨服务器传输文件的第三方jar包，jersey-core,jersey-client
    * 编写业务程序
        1. 确定上传的文件路径，文件服务器上的路径
        2. 获取上传文件项的UUID,生成唯一ID
        3. 获取客户端对象（客户端-服务器的方式建立连接）
            Client client = Client.create();
        4. 建立连接，
            WebResource resource = client.resource(path);
        5. 上传文件
            resource.put(upload.getBytes());</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/file_upload3.png" alt="跨服务器上传"></p>
<pre><code>3. 出现的错误
    1. 500：Method Not Allowed
        可以在文件服务器的文件目录下建立文件夹改变Tomcat服务器的readonly属性，Tomcat服务器的安装目录下的conf文件中的web.xml，属性值改为false</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/e1.png" alt></p>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><pre><code>1. 配置文件
    1. commons-fileupload_1.4.jar commons-io_2.5.jar
    2. CommonsMultipartResolver对象
    3. 需要下载的文件的文件名

2. 演示代码</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/filedown.png" alt="文件下载演示代码"></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><pre><code>Controller调用service,service调用dao,异常向上抛出，最终由DispatcherServlet找异常处理器进行处理。</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/error_process.png" alt="异常处理流程"><br><img src="/2020/09/18/springMVC/exception_1.png" alt="异常抛出演示"></p>
<h3 id="springMVC的异常处理"><a href="#springMVC的异常处理" class="headerlink" title="springMVC的异常处理"></a>springMVC的异常处理</h3><pre><code>1. 步骤
    * 编写自定义异常处理类 （提示信息）
    * 编写异常处理器，必须实现异常处理器接口，HandlerExceptionResolver
    * 配置异常处理器（决定跳转页面）
        在springmvc.xml中增加bean标签，将异常处理器加载到容器中</code></pre><p><img src="/2020/09/18/springMVC/exception_2.png" alt="异常抛出"></p>
<h2 id="拦截器（Interceptor）"><a href="#拦截器（Interceptor）" class="headerlink" title="拦截器（Interceptor）"></a>拦截器（Interceptor）</h2><pre><code>springMVC的拦截器和servlet的Filter过滤器的作用类似，用于对处理器（controller）进行预处理和后处理。
    Interceptor chain : 拦截器链，对一组拦截器按照一定的顺序进行访问

interceptor和filter的区别
* interceptor: 只能在springMVC中，在配置/*之后，只会拦截访问的控制器方法，如果访问的是jsp,css,html不会进行拦截
* filter: servlet规范的部分，所有的java web都可以使用，在配置之后，对所有要访问的资源进行拦截

编写拦截器必须实现 HandlerInterceptor接口</code></pre><h3 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h3><pre><code>1. 步骤
    * 编写自定义拦截器类（implements HandlerInterceptor）
    * 在容器中注册该拦截器类
    * 声明需要拦截的对象

2. 注册拦截器
    * 可以编写多个拦截器，构成拦截器链
    * &lt;mvc:mapping path=&quot;&quot;&gt;：指定要拦截的请求路径</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/inter_1.png" alt></p>
<pre><code>3. 拦截的方法</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/inter_2.png" alt></p>
<pre><code>* preHandler: 预处理，在controller方法执行之前执行
    return true: 放行，继续执行后面的拦截器
    return false: 不放行，可以使用转发和重定向来进行页面跳转

* postHandler: 后处理，在controller方法执行结束，跳转页面之前执行

* afterCompletion: 页面执行结束后，执行这个方法</code></pre>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Reflection（java反射机制）</title>
    <url>/2020/09/10/reflection/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><pre><code>1. 反射（reflection）：动态语言的关键
    * 反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性和方法
    * 加载完类之后，在堆内存的方法区产生一个Class对象（一个类只有一个Class对象），这个对象就包含完整的类的信息，可以通过这个Class对象看到类的结构，通过对象看到类的结构的过程，叫做反射

2. 使用反射的应用
    * 在运行时判断一个对象所属的类
    * 在运行时构造任意一个类的对象
    * 在运行时获取泛型的信息
    * 在运行时获取私有属性，私有方法
    * 在运行时父类的信息，父类上的泛型
    * 在运行时获取接口
    * 在运行时获取所在包，注解
    * 。。。

3. 相干的API
    * java.lang.Class
    * java.lang.reflect.Method    //方法
    * java.lang.reflect.Filed    //成员变量    
    * java.lang.reflect.Constructor        //构造器

4. 反射和封装性
    * 通过直接new对象，或反射的方式都可以调用公共的结构，具体使用位置？
        1. 建议直接使用new方式，编译的时候可以确定创建哪个对象
        2. 编译的时候无法确定创建哪个对象，根据传入的参数进行对象的创建，使用反射的方式：
            反射机制具有动态性

    * 有了反射机制，与对象的封装性，如何看待两种技术？
        1. 不矛盾
        2. 封装性：将对象的属性和方法进行权限限定，暴露出的接口表现用户可以使用的方法，建议用户使用的方法和属性，不建议使用私有方法[建不建议]
        3. 反射：可以使用的方法，用户强制使用私有的属性和方法[能不能]</code></pre><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><h3 id="java-lang-Class的理解"><a href="#java-lang-Class的理解" class="headerlink" title="java.lang.Class的理解"></a>java.lang.Class的理解</h3><pre><code>1. 类的加载过程
    程序在经过javac.exe命令之后，会生成一个或多个字节码文件（.class）文件，
    接着使用java.exe命令对某个字节码文件进行解释运行。相当于将字节码文件加载到内存，此过程叫做类的加载。
    加载到内存中的类，我们称为运行时类，此运行时类，就作为Class类的一个实例。

2. 换句话说，Class的实例就是一个运行时类的对象
3. 加载到内存的运行时类，会缓存一定的时间。在此时间之内，可以通过不同的方法获取运行时类</code></pre><h3 id="获取Class的实例方式"><a href="#获取Class的实例方式" class="headerlink" title="获取Class的实例方式"></a>获取Class的实例方式</h3><pre><code>1. 方式一：通过运行时类的.class属性获取Class实例
    Class clazz1 = Person.class();
    System.Out.Println(clazz1);

2. 方式二：通过运行时类的对象的.getClass()方法获取实例
    Person person = new Person();
    Class clazz2 = person.getClass();

3. 方式三：通过Class的.forName(&quot;运行时类的全限定类名&quot;)获取实例
    Class clazz3 = Class.forName(&quot;全限定类名&quot;)；

4. 方式四：通过类的加载器获取实例
     ClassLoader classLoader = Reflection.class.getClassLoader();
    Class clazz4 = classLoader.loadClass(&quot;全限定类名&quot;);

上述的四种Class实例的获取方式，方式一和方式二，都与具体的实现类绑定，在开发中一般使用Class类的.forName()方法获取Class实例对象。</code></pre><h3 id="Class对象的范围"><a href="#Class对象的范围" class="headerlink" title="Class对象的范围"></a>Class对象的范围</h3><pre><code>1. class:各种类对象
2. interface
3. []:数组 只要数组的类型和维度相同，就是一个Class对象
4. enum:枚举
5. annotation
6. 基本数据类型
7. void</code></pre><h2 id="ClassLoader-类加载器"><a href="#ClassLoader-类加载器" class="headerlink" title="ClassLoader(类加载器)"></a>ClassLoader(类加载器)</h2><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><pre><code>1. 加载：将类的字节码文件读入内存，并为其创建一个java.lang.Class对象，实现类的加载过程
2. 链接：静态变量初始化为默认值
3. 初始化：JVM使用构造器方法完成类变量的赋值和静态代码块的语句顺序合并产生数据</code></pre><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><pre><code>1. 将.class加载到内存，将这些静态数据转换成方法区运行时的数据结构，生成Class对象，作为方法区中类数据的访问入口
2. 类缓存：一旦某个类被加载到类加载器，会在类加载器中维持一段时间，JVM的垃圾回收机制可以回收Class对象

3. 分类
    * 引导类加载器：C++编写的，主要加载Java的核心类库，用户无法获取到该加载器
    * 扩展类加载器：加载java/lib/ect中的jar包
    * 系统类加载器：加载当前程序中的类</code></pre><blockquote>
<pre><code>//1.对于自定义类，使用系统级类加载器
ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
System.out.println(classLoader);

//2.调用系统类加载器的getParent()，获取扩展类加载器
ClassLoader classLoader1 = classLoader.getParent();
System.out.println(classLoader1);

//3.调用扩展类加载器getParent()，无法获取引导类加载器
//引导类加载器加载java的核心类库
ClassLoader classLoader2 = classLoader1.getParent();
System.out.println(classLoader2);</code></pre></blockquote>
<h2 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h2><h3 id="反射创建运行时类的对象"><a href="#反射创建运行时类的对象" class="headerlink" title="反射创建运行时类的对象"></a>反射创建运行时类的对象</h3><pre><code>1. 使用.newInstance()方法创建运行时类的对象
    newInstance:
        * 调用此方法，创建运行时类的方法
        * 内部调用运行时类的空参构造器
        * 如果没有空参构造器，产生异常

2. 满足两个条件
    * 运行时类必须提供空参的构造器
    * 访问权限不能为private,通常设置为public</code></pre><h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><pre><code>修饰符 返回类型 变量名；

1. 获取所有属性
    1. 获取当前运行时类的所有属性（getDeclaredFileds）
        * 不考虑权限问题，不会获取父类的属性</code></pre><blockquote>
<pre><code>Field[] fields1 = clazz.getDeclaredFields();
for(Field field:fields1){
    System.out.println(field);
}</code></pre></blockquote>
<pre><code>2. 获取属性包含父类的属性（getFileds）
    * 获取当前运行时类以及父类的所有权限为public的属性</code></pre><blockquote>
<pre><code>Field[] fields = clazz.getFields();
for(Field field:fields){
    System.out.println(field);
}        </code></pre></blockquote>
<pre><code>2. 获取属性的修饰符,数据类型，变量名</code></pre><blockquote>
<pre><code>Class clazz = Person.class;

//获取当前运行时类的所有属性
Field[] fields = clazz.getDeclaredFields();

for(Field field:fields){
//修饰符
//权限被分配了 整型数据,使用Modifier的方法可以翻译为字符串
int modifiers = field.getModifiers();
System.out.print(Modifier.toString(modifiers)+&quot;\t&quot;);
//数据类型
Class&lt;?type = field.getType();
System.out.print(type.getName()+&quot;\t&quot;);
//属性名
System.out.println(field.getName());
}</code></pre></blockquote>
<p><img src="/2020/09/10/reflection/fields.png" alt="运行时类的属性"></p>
<h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><pre><code>1. 获取当前运行类声明的所有方法</code></pre><blockquote>
<pre><code>Method[] methods = clazz.getMethods();
for(Method method:methods){
    System.out.println(method);
}</code></pre></blockquote>
<pre><code>2. 获取当前运行时类以及所有父类的声明为public权限的方法</code></pre><blockquote>
<pre><code>Method[] declaredMethods = clazz.getDeclaredMethods();
for(Method method:declaredMethods){
    System.out.println(method);
}</code></pre></blockquote>
<pre><code>3. 获取方法的修饰符，数据类型，方法名
    * @Anno
    * 权限修饰符 返回值类型 方法名(形参列表) Throws Exception{}

    Method[] declaredMethods = clazz.getDeclaredMethods();
    for(Method method:declaredMethods){
        System.out.println(&quot;-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&quot;);
        //1.注解获取
        Annotation[] methodAnnotations = method.getAnnotations();
        for(Annotation anno:methodAnnotations){
            System.out.print(anno+&quot;\t&quot;);
        }

        //2.权限修饰符
        System.out.print(Modifier.toString(method.getModifiers())+&quot;\t&quot;);
        //3.返回值类型
        System.out.print(method.getReturnType()+&quot;\t&quot;);
        //4.方法名
        System.out.print(method.getName());
        System.out.print(&quot;(&quot;);
        //5.形参列表参数
        Class[] parameterTypes = method.getParameterTypes();
        if(parameterTypes.length 0){
            for(int i = 0;i &lt; parameterTypes.length;i++){
                if(i == parameterTypes.length-1){
                    System.out.print(parameterTypes[i].getName()+&quot; args_&quot;+i);
                    break;
                }
                System.out.print(parameterTypes[i].getName()+&quot; args_&quot;+i+&quot; , &quot;);
            }
        }
        System.out.print(&quot;)&quot;);
        //6.获取抛出的异常
        Class[] exceptionTypes = method.getExceptionTypes();
        if(exceptionTypes.length 0){
            System.out.print(&quot; throws &quot;);
            for(int i = 0;i &lt; exceptionTypes.length;i++){
                if(i == exceptionTypes.length-1){
                    System.out.print(exceptionTypes[i].getName());
                    break;
                }
                System.out.print(exceptionTypes[i].getName()+&quot; , &quot;);
            }
        }
        System.out.println(&quot;{&quot;+&quot;\n&quot;+&quot;}&quot;);
    }</code></pre><h3 id="获取构造器的结构"><a href="#获取构造器的结构" class="headerlink" title="获取构造器的结构"></a>获取构造器的结构</h3><pre><code>1. 当前运行时类的所有的构造器</code></pre><blockquote>
<pre><code>Constructor&lt;?&gt;[] constructors = clazz.getConstructors();
for(Constructor c:constructors){
    System.out.println(c);
}</code></pre></blockquote>
<pre><code>2. 当前运行时类的所有public的构造器</code></pre><blockquote>
<pre><code>Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();
for(Constructor c:constructors){
    System.out.println(c);
}</code></pre></blockquote>
<h3 id="获取运行时类的父类"><a href="#获取运行时类的父类" class="headerlink" title="获取运行时类的父类"></a>获取运行时类的父类</h3><pre><code>1. getSuperClass():获取父类
2. getGenericSuperClass()：获取带有泛型的父类</code></pre><h2 id="调用运行时类的指定结构（方法和属性）"><a href="#调用运行时类的指定结构（方法和属性）" class="headerlink" title="调用运行时类的指定结构（方法和属性）"></a>调用运行时类的指定结构（方法和属性）</h2><pre><code>1. 获取指定的属性
    方法：
        getFiled():
            属性声明必须为public
        getDeclaredFiled()
            可以访问，但是如果想要访问私有属性，必须显式
            &lt;属性名&gt;.setAccessible(true);                

    1. 步骤
        * 获取Class对象
        * 创建Class对象的实例
        * 获取指定的属性
        * set方法
            * set(obj,value):obj：指明设置哪个对象的属性 value:设置的值
        * get方法
            * get(obj):obj：指明获取那个对象的属性

    2. 实例
        Class clazz = Person.class;
        Person p = (Person)clazz.newInstance();
        Filed filed = clazz.getDeclaredFiled(&quot;age&quot;);
        filed.setAccessible(true);
        filed.set(p,&quot;11111&quot;);

2. 获取指定的方法
    方法：
        getDeclaredMethod(name,param): 参数1：获取的方法的名称，参数2：获取的方法的形参列表
            可以访问，但是如果想要访问私有属性，必须显式
            &lt;方法名&gt;.setAccessible(true);

        &lt;方法名&gt;.invoke(obj,value):参数1:方法的调用者，参数2(可变形参)：赋值的实参
            invoke()方法的返回值为类中调用方法的返回值，
                如果调用的方法没有返回值，那么返回值为null

    1. 实例</code></pre><blockquote>
<pre><code>//1.获取指定的方法名
Method method = clazz.getDeclaredMethod(&quot;compareTo&quot;, String.class);
//2.确定当前方法是可以访问的
method.setAccessible(true);
//3.调用方法
method.invoke(p,&quot;HHHHH&quot;);   //p.show(&quot;HHHHH&quot;)</code></pre></blockquote>
<pre><code>2. 调用静态方法
    invoke(null)
    invoke(Person.class)</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2020/09/09/spring/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-什么是spring："><a href="#1-什么是spring：" class="headerlink" title="1. 什么是spring："></a>1. 什么是spring：</h3><pre><code>1. 分层的Java SE/EE的轻量级开源框架
2. 提供了展现层Spring MVC 和持久层Spring JDBC以及业务层事务管理的众多技术
3. 展现层和持久层的中间部分，业务层</code></pre><h3 id="2-spring的核心："><a href="#2-spring的核心：" class="headerlink" title="2. spring的核心："></a>2. spring的核心：</h3><pre><code>1. IoC（Inversion of Control）: 控制反转
2. AOP（Aspect Oriented Programming）: 面向切面编程</code></pre><h3 id="3-发展历程和优势"><a href="#3-发展历程和优势" class="headerlink" title="3.发展历程和优势"></a>3.发展历程和优势</h3><pre><code>spring优势：
    1. 方便解耦，简化开发
    2. AOP编程的支持
    3. 声明式事务的支持
    4. 方便程序的测试
    5. 方便集成各种优秀的框架</code></pre><h2 id="程序的耦合和解耦"><a href="#程序的耦合和解耦" class="headerlink" title="程序的耦合和解耦"></a>程序的耦合和解耦</h2><h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><pre><code>1. 什么是耦合：
    程序之间的依赖关系：
        * 类之间的依赖关系
        * 方法之间的依赖关系

2. 开发中的做法：
    编译期不依赖，运行时依赖

3. 方法：
    1. 使用读取配置文件来获取要创建的对象的全限定名称
        使用类加载器，获取配置文件的输入流
    2. 使用反射（reflection）来创建对象，而不是使用new关键字
        * 使用反射，如果字符串写死，以后无法再次使用别的数据库配置</code></pre><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><pre><code>1. 什么是解耦：
    降低程序之间的依赖关系

2. 解耦的方式：使用工厂模式创建Bean对象
      * bean: 可重用组件
      * javaBean &gt; 实体类
      * javaBean 用java语言编写的可重用组件
      * beanfactory：创建bean对象的工厂

3. 如何创建工厂模式
    1. 读取配置文件来反射bean对象
    2. 配置文件来创建service和dao
        唯一标识=全限定类名，key = value，根据对应的value创建实例对象</code></pre><h2 id="IoC（Inversion-of-Control）"><a href="#IoC（Inversion-of-Control）" class="headerlink" title="IoC（Inversion of Control）"></a>IoC（Inversion of Control）</h2><pre><code>1. 概念：
    把创建对象的权力交给框架，是框架的重要特征，包括依赖注入（Dependency Injection,DI）和依赖查找（Dependency Lookup）

2. 作用
    * 降低程序之间的耦合度
    * 将类中的对象创建工作交给spring框架来完成，只要获取该对象就可以了
    * 使用依赖注入进行属性值的填充，在创建对象的同时完成赋值</code></pre><h3 id="基于XML的IoC配置"><a href="#基于XML的IoC配置" class="headerlink" title="基于XML的IoC配置"></a>基于XML的IoC配置</h3><h4 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h4><pre><code>1. 步骤
    * 读取配置文件创建IoC容器（ApplicationContext）
    * 根据id，获取容器中的文件

2. 配置文件的内容
    * 主要是&lt;bean&gt;标签，id:查找对象的唯一标识符，class:要创建的对象的全限定类名

3. 读取配置文件创建容器
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    根据类路径下的xml配置文件创建容器，配置文件需要放置在类路径下

    ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;bean.xml&quot;);
    可以加载磁盘任意路径下的配置文件

    ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class);
    根据类上有@Configuration的类创建容器

4. 根据id获取对象
    as.getBean(&quot;id&quot;);</code></pre><h4 id="BeanFactory和ApplicationContext"><a href="#BeanFactory和ApplicationContext" class="headerlink" title="BeanFactory和ApplicationContext"></a>BeanFactory和ApplicationContext</h4><pre><code>1. Beanfactory接口
    * 创建核心容器时，创建对象的方式采用延迟加载的方式，什么时候根据ID获取对象的时候，什么时候开始创建真正的对象
     * 多例模式适用

2. ApplicationContext接口
    * 创建核心容器时，创建对象的方式采用立即加载的方式，只要一读取完配置文件马上创建配置文件中的对象
     * 单例模式时适用：只创建一个对象

3. 具体的使用
    BeanFactory是顶层接口，功能不如ApplicationContext，实际使用的接口为ApplicationContext接口

    ApplicationContext可以根据配置文件的不同，选择合适的加载方式
    可以感知到对象的单例还是多例，从而选择不同的方式创建对象</code></pre><h4 id="spring对bean对象的管理细节"><a href="#spring对bean对象的管理细节" class="headerlink" title="spring对bean对象的管理细节"></a>spring对bean对象的管理细节</h4><h5 id="1-创建bean的三种方式"><a href="#1-创建bean的三种方式" class="headerlink" title="1. 创建bean的三种方式"></a>1. 创建bean的三种方式</h5><pre><code>1. 使用默认构造函数创建：
   在spring的配置文件中使用bean标签，配以id 和 class属性，且没有其他的属性和标签时
   采用的就是默认构造函数创建bean对象(Class类的实例反射)，如果此时没有默认构造函数，则无法创建</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_IoC_bean.service.impl.AccountServiceImpl&quot;/&gt;</code></pre></blockquote>
<pre><code>2. 使用普通工厂中的方法创建对象
    使用某个类中的方法创建对象，并存入spring容器中</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.spring_03_IoC_bean.factory.InstanceFactory&quot;/&gt;
&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;/&gt;</code></pre></blockquote>
<pre><code>3. 使用工厂的静态方法创建对象（
    使用某个类的静态方法创建对象(可以不创建该对象)，并将其存入spring容器</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_IoC_bean.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;/&gt;</code></pre></blockquote>
<h5 id="2-bean对象的作用范围"><a href="#2-bean对象的作用范围" class="headerlink" title="2. bean对象的作用范围"></a>2. bean对象的作用范围</h5><pre><code>1. bean标签的scope属性规定bean对象的范围
2. 类型
    * singleton: 单例模式（默认）
    * prototype：多例模式
    * requset:web应用的一次请求
    * session：web应用中的一次会话
    * global-session：web应用中的全局会话</code></pre><h5 id="3-bean对象的生命周期"><a href="#3-bean对象的生命周期" class="headerlink" title="3. bean对象的生命周期"></a>3. bean对象的生命周期</h5><pre><code>1. 单例对象：singleton
  出生：当容器创建时，对象出生
  活着：只要容器还在，对象活着
  死亡：容器销毁，对象死亡
2. 多例对象：prototype
  出生：当使用对象时，spring框架创建
  活着：只要在使用的时候一直存在
  死亡：只有在对象长时间不用，且没有其他的对象引用的时候，由垃圾回收机制回收</code></pre><h4 id="依赖注入（dependency-injection-DI）"><a href="#依赖注入（dependency-injection-DI）" class="headerlink" title="依赖注入（dependency injection:DI）"></a>依赖注入（dependency injection:DI）</h4><pre><code>1. 什么是依赖？    
    当前类中引用到其他类的对象，叫做依赖。
    在spring框架中，依赖对象由框架提供，我们只需要提供配置文件的说明（IoC方式）

2. spring降低程序之间的依赖关系?
    IoC控制反转
    依赖注入

3. 依赖注入的数据类型：
    1. 基本数据类型和String类型
    2. 其他bean对象
    3. 复杂类型（集合类型）

4. 依赖注入的方式：
    1. 通过默认构造函数注入依赖
    2. 使用set方法注入 ***
    3. 通过注解注入</code></pre><h5 id="1-通过默认构造函数注入"><a href="#1-通过默认构造函数注入" class="headerlink" title="1. 通过默认构造函数注入"></a>1. 通过默认构造函数注入</h5><pre><code>标签：constructor-arg
位置：bean中的内部
属性含义：
    type: 指定要注入的数据类型，该数据类型是构造函数的某个或者某些参数的类型
    index: 指定要注入数据给构造函数的参数指定索引的位置的赋值
    name: 用于指定给构造函数的指定名称的参数赋值（主要方式）
    ===================指定给构造函数的那个参数赋值=======================

    value: 提供基本类型和String类型的数据
    ref: 指定其他的bean类型的数据，在spring的IoC的核心容器中的bean对象

优势：
    在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功
缺点：
    改变了bean对象的实例化方式，在我们创建对象时，即使用不到这些数据，也必须提供数据</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;李某&quot;/&gt;
    &lt;constructor-arg name=&quot;age&quot; value=&quot;23&quot;/&gt;
    &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;
&lt;/bean&gt;</code></pre></blockquote>
<blockquote>
<pre><code>&lt;!-- 配置一个日期对象 --&gt;
&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;/&gt;</code></pre></blockquote>
<h5 id="2-使用set进行依赖注入"><a href="#2-使用set进行依赖注入" class="headerlink" title="2. 使用set进行依赖注入"></a>2. 使用set进行依赖注入</h5><pre><code>标签：property
位置：bean标签内部
参数：
    name:    指定注入的时候的方法的名称
    value:     指定基本数据类型和String类型
    ref:     指定其他的bean类型的数据，只要是在spring核心容器中的bean对象都可以

优势：创建bean对象的时候，可以直接使用默认构造函数
   缺点：
      如果某个成员必须有值，获取对象的set方法可能没有执行</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService2&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl2&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;22&quot;/&gt;
    &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;
&lt;/bean&gt;</code></pre></blockquote>
<blockquote>
<pre><code>&lt;!-- 配置一个日期对象 --&gt;
&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;/&gt;</code></pre></blockquote>
<h5 id="3-使用注解进行依赖注入"><a href="#3-使用注解进行依赖注入" class="headerlink" title="3. 使用注解进行依赖注入"></a>3. 使用注解进行依赖注入</h5><pre><code>@Autowired
@Qualifier
@Resource
@Value
进行依赖注入</code></pre><h5 id="4-注入复杂数据类型"><a href="#4-注入复杂数据类型" class="headerlink" title="4. 注入复杂数据类型"></a>4. 注入复杂数据类型</h5><pre><code>List Set      
Map Properties

标签：property
位置：property内部
其中：只要数据集合的结构相同，可以使用同一种标签进行依赖注入
    list set arrsy: 都可以使用&lt;list&gt;,&lt;array&gt;,&lt;set&gt;，序列格式
    map property:&lt;map&gt;,&lt;pros&gt;，键值对格式</code></pre><blockquote>
<pre><code>private String[] myStr;
private List&lt;StringmyList;
private Set&lt;StringmySet;
private Map&lt;String,StringmyMap;
private Properties myProp;</code></pre></blockquote>
<pre><code>具体的调用方法</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService3&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl3&quot;&gt;
&lt;property name=&quot;myStr&quot;&gt;
  &lt;array&gt;
    &lt;value&gt;AAA&lt;/value&gt;
    &lt;value&gt;VVVDDD&lt;/value&gt;
    &lt;value&gt;SS&lt;/value&gt;
    &lt;value&gt;SSDDD&lt;/value&gt;
  &lt;/array&gt;
&lt;/property&gt;
&lt;!-- map --&gt;
&lt;property name=&quot;myMap&quot;&gt;
  &lt;map&gt;
    &lt;entry key=&quot;1&quot; value=&quot;11111&quot;/&gt;
    &lt;entry key=&quot;2&quot; value=&quot;22222&quot;/&gt;
  &lt;/map&gt;
&lt;/property&gt;</code></pre>  
</blockquote>
<h3 id="基于注解的IoC配置"><a href="#基于注解的IoC配置" class="headerlink" title="基于注解的IoC配置"></a>基于注解的IoC配置</h3><pre><code>使用注解和xml开发要实现的功能都是一致的：降低程序之间的耦合，将xml中对应的功能交由注解来实现</code></pre><h4 id="1-用于创建bean对象的注解"><a href="#1-用于创建bean对象的注解" class="headerlink" title="1. 用于创建bean对象的注解"></a>1. 用于创建bean对象的注解</h4><pre><code>* 与xml配置文件中的&lt;bean&gt;标签的作用相同：创建一个bean对象，将其放置在容器中
* 如果想让spring知道存在组件，需要使用spring中的包扫描，将需要创建bean对象的包传入&lt;context&gt;标签中

1. @Component:组件注解
    * 作用：将当前对象存入spring容器中(写在类名上)
    * 属性：value:
            用于指定获取容器中bean的id，当我们不写时，默认是当前类名，首字母小写    

2. @Controller:一般用于表现层
3. @Service：一般用于业务层
4. @Repository:一般用于持久层
以上的三个注解和@Component的作用和属性完全一致，是spring框架为我们明确提供的三层注解，让我们的三层结构更加清晰</code></pre><h4 id="2-用于数据注入的注解"><a href="#2-用于数据注入的注解" class="headerlink" title="2. 用于数据注入的注解"></a>2. 用于数据注入的注解</h4><pre><code>* 与xml配置文件的&lt;property&gt;作用一致：进行数据注入

1. @Autowired:自动按照类型注入
     * 只要IoC容器中有唯一的bean对象和要注入的变量类型相同，就可以自动注入
     * 如果IoC容器中没有任何bean对象和要注入的变量类型相同，无法自动注入
     * 如果IoC容器中有多个bean对象和要注入的变量类型相同，
     * 首先圈定类型相同的bean对象的范围，然后会在进行变量名称的比对,如果名称相同，就可以注入数据</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/autowired.png" alt="autowired注解">         </p>
<pre><code>2. @Qualifier
    * 先按照类型自动注入，如果包含有多个相同类型的bean对象，会按照名称进行数据注入
    * 在按照类型注入的基础上，再按照名称注入，在给类成员的注入的时候不能单独使用，但是在给方法注入的时候可以，，将@Qualifier()中的名称所对应的Bean对象注入到方法中
    * 参数：
        value:用于指定注入的bean的id

3. @Resource
    * 直接按照bean的id进行注入，可以单独使用
    * 参数：
        name:用于指定注入的bean的id

注意：
     以上的三种注入方式只能注入其他的bean类型的数据，基本类型和String类型无法通过上述方法注入
          集合类型只能通过xml方式注入

4. @Value
    * 注入基本数据类型和String类型
    * 参数：    
        value:用于指定数据的值，可以使用SpEL（spring的El表达式）                      SpEL的写法：${表达式}</code></pre><h4 id="3-用于改变作用范围的注解"><a href="#3-用于改变作用范围的注解" class="headerlink" title="3. 用于改变作用范围的注解"></a>3. 用于改变作用范围的注解</h4><pre><code>* 与xml文件中的&lt;bean&gt;标签的scope属性作用相同

1. @Scope
    * 参数：
        value:singleton prototype</code></pre><h4 id="4-用于改变生命周期的注解"><a href="#4-用于改变生命周期的注解" class="headerlink" title="4. 用于改变生命周期的注解"></a>4. 用于改变生命周期的注解</h4><pre><code>1. @PreDestroy
    * 销毁容器
2. @PostConstruct
    * 初始化容器</code></pre><h3 id="使用IoC的一个简单案例"><a href="#使用IoC的一个简单案例" class="headerlink" title="使用IoC的一个简单案例"></a>使用IoC的一个简单案例</h3><pre><code>1. 环境配置
    使用DBUtils进行Dao数据交互
    spring框架
    mybatis进行JDBC连接
    c3p0作为数据源</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/IoC_exp_pom.png" alt="pom.xml"></p>
<pre><code>2. bean文件结构
    1. xml配置</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/Ioc_xml_exp.png" alt="xml配置的bean"></p>
<pre><code>2. annotation配置</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/IoC_anno_exp.png" alt="annotation配置的bean"></p>
<blockquote>
<p>注解的形式以及文件结构<br><img src="/2020/09/09/spring/Ioc_structure.png" alt="annotation的结构"></p>
</blockquote>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><pre><code>在案例中，配置文件存在annotation和xml同时存在，下面将其改造为纯注解方式

1. 改变xml中的组件扫描
    @Configurtion:
        * 作用：用于指定当前类是配置类
         * 当配置类作为AnnotationConfigApplicationContext()的参数时可以不写@Configuration，由扫描器直接扫描该配置类
         * 如果是子配置类，而且子配置类的字节码没有作为参数传入，必须写@Configuration

    @ComponentScan
        * 作用：用于指定spring在创建容器是需要扫描的包
        * 参数：value basePackages作用一样（@Alisafor）    
                类似&lt;context:component-scan base-package=&quot;com.spring_04_exp&quot;/&gt;

    一旦这个类上写了@Configuration 和@ComponentScan ,spring就会自动扫描配置包，并且创建对象将其放入容器，只需要拿到这个bean对象就可以了。

2. 根据方法的返回值创建Bean对象
    @Bean
        * 作用：把当前方法的返回值作为Bean对象存入spring容器中
        * 参数：name:
            用于指定bean的id,当不写时，方法名作为默认值
        * 使用注解配置方法时，spring框架会在容器中查找相对于的bean容器，查找方法与@AutoWired相同

3. 配置文件的读取
    @PropetySource
        * 作用：读取配置文件，用于指定properties文件的位置
        * 参数：value
            文件的名称:文件的路径
        * classpath关键字，表示在类路径下

4. 导入其他的配置类
    @Import
        * 作用：用于导入其他的配置类
        * 参数：value
            用于指定其他配置类的的字节码
        * 当我们使用Import注解时，拥有Import的配置类就是父配置类，写在value中的就是子配置类</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/anno_withoutxml_1.png" alt="配置类"><br><img src="/2020/09/09/spring/anno_withoutxml_2.png" alt="配置类"></p>
<pre><code>5. spring整合junit
    1. 程序的入口
        main方法
    2. JUnit单元测试
        没有main方法也能执行，其实junit中集成了main方法
        该方法就会判断当前测试类中有哪些方法上由@Test方法
        junit就会让Test注解执行该方法
    3. junit不知道spring框架
        在执行测试方法的时候，junit根本不知道由spring框架
        所以不会读取配置文件/创建spring容器

    4. 当测试方法执行时，没有IoC容器，就算写了@Autowired注解，也无法注入

    5. 解决方式    
        1. 导入spring整合test的jar包
        2. 使用junit的main方法替换为spring提供的main方法
            1. @Runwith
                * 作用：改变junit的main方法，使用spring框架提供的main方法，可以创建容器
                * 替换的方法的类的字节码
        3. 告诉spring运行器，spring和IoC容器的创建基于xml还是注解
            2. @ContextConfiguration
                * 作用：指定spring和IoC容器的创建基于xml还是注解
                * 参数：
                    locations : 指定xml文件的位置，加上classpath关键字，表示在类路径下
                    classes: 指定配置类位置，字节码文件

    6. 出现问题
        1. spring框架的5.x版本整合junit必须在4.12版本以上
        2. spring-context以及spring-test的版本号要一致
        3. 如果一直无法导入jar包，可以先将本地maven仓库对应的jar包删除，重新导入坐标</code></pre><h2 id="spring的AOP"><a href="#spring的AOP" class="headerlink" title="spring的AOP"></a>spring的AOP</h2><h3 id="完善account的案例"><a href="#完善account的案例" class="headerlink" title="完善account的案例"></a>完善account的案例</h3><h4 id="进行账户之间的转账"><a href="#进行账户之间的转账" class="headerlink" title="进行账户之间的转账"></a>进行账户之间的转账</h4><pre><code>1. 增加新的转账方法
2. 防止转账异常，应该在持久层增加事务控制
3. 将事务控制放在业务层控制
4. 增加数据库连接工具类
5. 为了保证每次连接都只有一个事务控制，将连接和线程绑定
6. 增加事务管理工具类 
7. 改变连接池对象，增加数据注入

增加很多冗余代码，配置文件变得更为复杂</code></pre><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><pre><code>1. 优势
    * 字节码随用随创建，随用随代理
    * 在不改变源码的时候对方法进行增强</code></pre><h4 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><pre><code>1. 涉及的类
    * Proxy类
    * JDK官方

2. 创建代理对象的方法
    * Proxy.newProxyInstance()

3. 要求
    * 被代理对象至少要实现一个接口，如果没有，不能使用

4. newProxyInstance()的参数
    * ClassLoader:类加载器
        用于加载代理对象的字节码，和被代理对象使用相同的类加载器：固定写法

    * Class[]:字节码数组
        用于指定代理和被代理对象实现相同的方法，代理谁就写谁的接口：固定写法

    * InvacationHandler
        用于指定增强的代码
        让我们写任何实现代理，一般在某个实现方法上进行改变
        一般情况下，为匿名内部类，但是不是必须的
        此接口的实现类，都是谁用谁写

5. InvacationHandler的实现方法的参数</code></pre><blockquote>
<pre><code>实现类中需要重写invoke方法,执行被代理对象的任何方法都会经过该方法
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
   return null;
 }
    * proxy : 被代理对象的引用
    * method : 当前执行的方法
    * args : 当前方法执行的参数
    * 返回类型：和被代理对象的相同方法有相同的返回值类型</code></pre></blockquote>
<h4 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h4><pre><code>1. 导入jar包
    cglib包

2. 涉及的类
    * Enhancer类
    * 第三方cglib库

3. 创建代理对象的方法
    * Enhancer.create()方法

4. create方法的参数
    * Class:被代理对象的字节码
    * Callback:
        * 用于提供增强的方法
         * 如何代理对象，该接口的实现类，通常情况下为匿名内部类，但不是必须的
         * 此接口的方法都是谁用谁写
         * 实现该接口的子接口的实现类，MethodInterceptor方法拦截器

5. MethodInterceptor方法的参数</code></pre><blockquote>
<pre><code>方法的重写
@Override
public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
    return null;
}
参数：
    * 执行被代理对象的方法都经过该方法
    * @param o 被代理对象
    * @param method 当前执行的方法
    * @param objects 当前方法执行的对象
    *                和基于接口的方法的invoke参数相同
    * @param methodProxy 当前执行方法的代理对象
    * @return 和当前方法的返回值类型相同
    * @throws Throwable    </code></pre></blockquote>
<h4 id="动态代理在案例中的使用"><a href="#动态代理在案例中的使用" class="headerlink" title="动态代理在案例中的使用"></a>动态代理在案例中的使用</h4><pre><code>1. 创建代理工厂类，在获取AccountService的基础上，对原有的方法进行增强，增加事务控制</code></pre><blockquote>
<pre><code>public class BeanFactory {
    private IAccountService accountService;
    private TransactionManager transactionManager;</code></pre></blockquote>
<pre><code>public void setTransactionManager(TransactionManager transactionManager) {
    this.transactionManager = transactionManager;
}</code></pre><blockquote>
</blockquote>
<pre><code>public final void setAccountService(IAccountService accountService) {
    this.accountService = accountService;
}</code></pre><blockquote>
</blockquote>
<pre><code>/**
 * 获取代理对象的返回方法
 * @return
 */
public IAccountService getAccountService(){
    return (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(),
            accountService.getClass().getInterfaces(), new InvocationHandler() {
                /**
                 * 增强方法,对事务进行增强
                 */
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    Object rtValue = null;
                    try {
                        //1.开启事务
                        transactionManager.beginTransaction();
                        //2.执行操作
                        rtValue = method.invoke(accountService,args);
                        //3.提交事务
                        transactionManager.commitTransaction();
                        //4.返回结果
                        return rtValue;
                    } catch (Exception e) {
                        //5.回滚事务
                        transactionManager.rollbackTransaction();
                        throw new RuntimeException(e);
                    } finally {
                        //6.释放资源
                        transactionManager.releaseTransaction();
                    }
                }
           });
     }
  }

2. bean.xml的配置
    * 增加新的bean对象，beanFactory
    * 使用工厂的方法，创建代理类对象，由于代理类对象的数据类型和被代理对象的数据类型相同，在测试的时候需要对注入的数据进行指定</code></pre><p><img src="/2020/09/09/spring/proxy.png" alt="代理类对象的配置文件"></p>
<pre><code>3. 测试类</code></pre><p><img src="/2020/09/09/spring/proxy_test.png" alt="动态代理的测试类"></p>
<h3 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h3><pre><code>1. Aspect Oriented Programming:面向切面编程
    通过预编译和运行期动态代理的方式，实现程序功能的统一维护的一种技术。AOP是OOP编程的延续，是函数式编程的一种衍生泛型，可以使用AOP对业务逻辑进行隔离，降低程序之间的耦合性，提高代码的可重用率。

    简单来说，将重复的代码抽取出来，在需要使用的时候，通过动态代理的方式，在不修改源码的基础上，对已有的方法进行增强。

2. AOP的优势
    1. 作用
        * 在程序的运行期间不改变源码的基础上，对已有的方法进行增强

    2. 优势
        * 减少重复代码
        * 提高开发效率
        * 方便维护

3. 实现方式
    动态代理
    spring会根据是否实现了接口，动态的选择实现代理的方式

4. AOP的相关术语
    * Joinpoint(连接点)：
        所谓连接点是指那些被拦截到的点，在spring中，只支持对方法类型的连接点。
        （业务层接口中的所有方法），连接业务和增强方法的点

    * Pointcut(切入点)：
        被增强的方法，叫做切入点，我们对于哪些joinpoint方法进行增强的定义

    切入点都是连接点，但不是所有的连接点都是切入点

    * Advice(通知/增强):
        拦截到Joinpoint之后所作的事情叫做通知。
        通知的类型：
            前置通知，后置通知，异常通知，最后通知，环绕通知</code></pre><p><img src="/2020/09/09/spring/advice.png" alt="advice_types"></p>
<pre><code>    * Target(目标对象)：
        代理的目标对象，即被代理对象

    * Weaving(织入)：
        把增强应用到目标对象来创建新的代理对象的过程。
        spring采用动态代理技术进行织入

    * Proxy(代理)：
        一个类被AOP织入后，产生一个代理对象

    * Aspect(切面)：
        切入点和通知的结合，切入点和通知的有序组合
5. 明确
    1. 开发阶段：
        核心业务代码，大部分程序员
        把公共代码抽取出来，制作成通知（最后才做）
        在配置文件中，声明切入点和通知的关系，即切面，

    2. 运行阶段：
        spring框架监控切入点的执行，一旦检测到切入点方法正在执行，则立即使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理的对应位置，将通知的功能织入，完成代码的逻辑运行。</code></pre><h3 id="基于XML的AOP配置"><a href="#基于XML的AOP配置" class="headerlink" title="基于XML的AOP配置"></a>基于XML的AOP配置</h3><pre><code>1. 配置步骤
    1. 把通知的bean交给spring来管理（由spring来统一控制）
    2. 使用aop:config标签表明开始aop配置,开始配置
    3. 使用aop:aspect:配置切面
          id：给切面提供唯一属性
          ref:通知类的bean的id

    4. 在aop:aspect标签的内部使用对应的标签配置通知的类型
         现在的示例的通知类型是printlog方法在切入点的执行，为前置类型
            aop:before表示配置前置通知
                  method属性用于指定那个方法是前置通知

    5. pointcut属性：指定切入点表达式，该表达式的含义：对业务层的那些方法增强
        写法；关键字：execution(表达式)
          表达式：
              访问修饰符 返回值 包名.包名...类名.方法名（参数列表）
          标准表达式：
              execution(public void com.spring_AOP_xml.service.impl.AccountServiceImpl.saveAccount())</code></pre><p><img src="/2020/09/09/spring/xml_AOP.png" alt="XML配置AOP"></p>
<pre><code>2. 切入点表达式的化简
    1. 通配表达式写法：* *..*.*(..),所有包下的方法都被增强
    * 步骤
        public void com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        1. 访问修饰符可以省略：
            void com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        2. 返回值类型可以使用通配符*代替：
            * 
    com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        3. 包名可以使用*.来代替，有几级包，需要写几个 
            * *.*.*.*.IAccountServiceImpl.saveAccount()
            使用*..可以表示当前包和子包，代表所有的包
        4. 类名和方法名可以使用*来表示
            * *..*.*()
        5. 参数：
            基本数据类型：直接写类型  int
            引用数据类型: 包名.类名  java.lang.String
            可以使用*来代表有无参数
                * *..*.*()和* *..*.*(*)不一样
            可以使用 ..来表示有无参数
        所以：
            * *..*.*(..):表示对所有类上的所有方法都进行增强

    2. 开发中：对业务层上的所有方法都进行增强
        * com.spring_AOP_xml.service.impl.*.*(..)

    3. 通用切入点表达式简化最终版：
        aop:pointcut标签：写在&lt;aop:aspect&gt;标签内部，但只能在当前标签内部使用，也可以写在外部，所有切面都可以使用，此时必须出现在切面之前
            id 切入点的唯一表示 
            expression：指定表达式内容
          &lt;aop:pointcut id=&quot;pc1&quot; expression=&quot;execution(* com.spring_AOP_xml.service.impl.*.*(..))&quot;/&gt;

        使用方式：
            &lt;aop:after method=&quot;printLog&quot; pointcut-ref=&quot;pc1&quot;/&gt;

3. 通知的类型（advice）
    前置通知：切入点方法执行之前
    后置通知：切入点方法正常执行之后执行
    异常通知：切入点方法异常的时候执行
    最终通知：无论怎样都会执行

    后置通知和异常通知只会执行一个</code></pre><p><img src="/2020/09/09/spring/advice_types.png" alt="通知类型"></p>
<pre><code>环绕通知：
    * 问题：
        在配置环绕通知之后，业务层方法没有执行，环绕通知执行了
    * 分析：
        没有对切入点的方法的明确调用
    * 解决：
        spring提供了一个接口，ProceedingJoinPoint的方法中proceed(),明确切入点方法的调用，该方法可以传入环绕通知参数，在程序执行期间，spring框架会为我们创建实现类。</code></pre><p><img src="/2020/09/09/spring/around_advice.png" alt="aroundadvice"></p>
<pre><code>* 环绕通知是spring框架为我们提供的一种方式：可以手动控制增强代码执行的方式</code></pre><h3 id="基于注解的AOP配置"><a href="#基于注解的AOP配置" class="headerlink" title="基于注解的AOP配置"></a>基于注解的AOP配置</h3><pre><code>1. 加入context扫描
2. 配置注解产生对象
3. 改变增强类的信息，切面的方法
4. 在bean.xml中增加开启注解配置AOP的标签
    &lt;aop:aspectj-autoproxy/&gt;:有这个标签才使用注解配置AOP</code></pre><p><img src="/2020/09/09/spring/AOP_anno.png" alt="通知和切面类注解">    </p>
<h2 id="JdbcTemlate"><a href="#JdbcTemlate" class="headerlink" title="JdbcTemlate"></a>JdbcTemlate</h2><h3 id="spring中的JdbcTemplate"><a href="#spring中的JdbcTemplate" class="headerlink" title="spring中的JdbcTemplate"></a>spring中的JdbcTemplate</h3><pre><code>1. 概念    
    * spring框架的提供的一个对象，是对原始Java API的简单封装，spring为我们提供了很多操作模板类。
    * 操作关系型数据库：
    * 操作nosql数据库
    * 操作消息队列:

    使用的时候需要导入spring-jdbc-5.1.10.RELEASE.jar
                    spring-tx-5.1.10.RELEASE.jar(事务相关)

2. 作用
    * 用于和数据库进行交互的，实现数据的CRUD

3. 如果重复的代码过多
    可以抽取重复代码，形成父类，使AccountDaoImpl继承该父类，也可以实现Dao的实现类</code></pre><blockquote>
<p>   Dao的两种实现方式:<br><img src="/2020/09/09/spring/dao_xml.png" alt="dao的xml配置方式"><br><img src="/2020/09/09/spring/dao_anno.png" alt="dao的annotation配置方式"></p>
</blockquote>
<h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h2><h3 id="spring的事务"><a href="#spring的事务" class="headerlink" title="spring的事务"></a>spring的事务</h3><pre><code>1. 明确
    * Java EE体系进行开发，事务处理位于业务层，spring提供分层设计业务层的事务处理方法
    * spring框架为我们提供一组事务控制的接口，位于spring-tx-5.1.10.RELEASE.jar
    * spring的事务控制基于AOP的，可以使用配置的控制和编程，主要使用配置事务

2. 事务API
    * platformTransactionManager</code></pre><h3 id="基于xml的事务控制"><a href="#基于xml的事务控制" class="headerlink" title="基于xml的事务控制"></a>基于xml的事务控制</h3><pre><code>1. 使用
    1. 配置事务管理器（DataSourceTransactionManager）
    2. 配置事务通知(tx:advice)
          此时需要导入事务的约束,tx的名称约束，同时也需要aop的支持
          使用tx:advice配置事务通知 
            id:唯一标志 
            transaction-manager:提供事务管理器使用
    3. 配置aop的通用切入点表达式
    4. 建立事务通知和切入点表达式的关联
    5. 配置事务的属性：事务的通知tx:advice的内部
        * isolation: 指定事务的隔离级别，默认值式DEFAULT,
        * propagation: 事务的传播行为REQUESTED 表示一定会有事务，增删改的选择，查询可以选择SUPPORTS
        * read-only: 事务是否只读，默认为false
        * time-out: 事务的超时时间,默认-1，表示永不超时，如果指定，以秒为单位
        * rollback-for: 指定一个异常，当产生该异常时，事务回滚，产生其他异常，事务不回滚，没有默认值，表示任何异常都会回滚
        * no-rollback-for：指定一个异常，当产生该异常时，事务不回滚，产生其他异常，事务回滚，没有默认值，表示任何异常都会回滚

2. 使用实例</code></pre><p><img src="/2020/09/09/spring/tran_xml.png" alt="基于xml的声明式事务"></p>
<h3 id="基于注解的事务配置"><a href="#基于注解的事务配置" class="headerlink" title="基于注解的事务配置"></a>基于注解的事务配置</h3><pre><code>1. 步骤
    1. 配置事务管理器（DataSourceTransactionManager）
    2. 开启spring对注解事务的支持（tx:annotation-driven）
    3. 使用注解@transactional对需要事务的地方进行定义
        xml中的事务属性，均可以在@Transactional的属性中配置

    如果查询和增删改的方法数量差不多，需要对增删改的方法单独配置事务支持

2. 实例</code></pre><p><img src="/2020/09/09/spring/tran_anno.png" alt="基于注解的声明式事务"></p>
<h3 id="使用纯注解的事务配置"><a href="#使用纯注解的事务配置" class="headerlink" title="使用纯注解的事务配置"></a>使用纯注解的事务配置</h3><p><img src="/2020/09/09/spring/tx_without_xml.png" alt="纯注解的声明式事务"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL 5.7.29</title>
    <url>/2020/06/18/mysql57/</url>
    <content><![CDATA[<h2 id="下载安装MySQL-5-7-29版本"><a href="#下载安装MySQL-5-7-29版本" class="headerlink" title="下载安装MySQL-5.7.29版本"></a>下载安装MySQL-5.7.29版本</h2><h3 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1.下载安装包"></a>1.下载安装包</h3><pre><code>官网下载安装包，离线安装方式</code></pre><ul>
<li><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">mysql数据库下载地址</a><blockquote>
</blockquote>
<img src="/2020/06/18/mysql57/0.png" alt></li>
</ul>
<h3 id="2-my-ini"><a href="#2-my-ini" class="headerlink" title="2.my.ini"></a>2.my.ini</h3><pre><code>下载的安装包解压后，安装目录如果没有*my.ini*文件，新建该文件，内容：
其中，文件安装和data目录可以自定义</code></pre><blockquote>
</blockquote>
<p><img src="/2020/06/18/mysql57/5.png" alt></p>
<h3 id="3-创建服务"><a href="#3-创建服务" class="headerlink" title="3.创建服务"></a>3.创建服务</h3><blockquote>
</blockquote>
<p><img src="/2020/06/18/mysql57/6.png" alt></p>
<pre><code>mysql57为服务名</code></pre><h3 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4.初始化"></a>4.初始化</h3><p><code>mysqld --initialize</code></p>
<h3 id="5-启动服务"><a href="#5-启动服务" class="headerlink" title="5.启动服务"></a>5.启动服务</h3><p><code>net start mysql</code></p>
<h3 id="6-连接数据库"><a href="#6-连接数据库" class="headerlink" title="6.连接数据库"></a>6.连接数据库</h3><ul>
<li>临时密码：在***.err下<blockquote>
</blockquote>
<img src="/2020/06/18/mysql57/4.png" alt><br><img src="/2020/06/18/mysql57/9.png" alt><br><img src="/2020/06/18/mysql57/11.png" alt></li>
</ul>
<h3 id="7-更改密码"><a href="#7-更改密码" class="headerlink" title="7.更改密码"></a>7.更改密码</h3><blockquote>
</blockquote>
<p><img src="/2020/06/18/mysql57/12.png" alt></p>
<h3 id="8-断开连接"><a href="#8-断开连接" class="headerlink" title="8.断开连接"></a>8.断开连接</h3><p><code>exit</code></p>
<h3 id="9-退出服务"><a href="#9-退出服务" class="headerlink" title="9.退出服务"></a>9.退出服务</h3><blockquote>
</blockquote>
<p><img src="/2020/06/18/mysql57/13.png" alt></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="1-存在data文件夹"><a href="#1-存在data文件夹" class="headerlink" title="1.存在data文件夹"></a>1.存在data文件夹</h3><ul>
<li>删除原本data，初始化命令自动生成新的data文件夹</li>
<li>data文件夹自己手动创建可能报错，最好还是由系统自动创建<blockquote>
</blockquote>
<img src="/2020/06/18/mysql57/7.png" alt></li>
</ul>
<h3 id="2-无法启动服务"><a href="#2-无法启动服务" class="headerlink" title="2.无法启动服务"></a>2.无法启动服务</h3><blockquote>
</blockquote>
<p><img src="/2020/06/18/mysql57/1.png" alt><br><img src="/2020/06/18/mysql57/8.png" alt></p>
<pre><code>更改注册表信息</code></pre><blockquote>
</blockquote>
<p><img src="/2020/06/18/mysql57/2.png" alt><br><img src="/2020/06/18/mysql57/3.png" alt></p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/2020/05/15/mybatis/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><pre><code>1. 什么是框架（Framework）？
    系统中可重用的代码部分，包括一组构件以及构件之间的交互逻辑
    软件开发中的一种解决方案，不同的框架解决不同的问题
    框架封装了很多技术细节，使用者可以方便实现功能，提高开发效率

2. 三层架构
    * 表现层：
        展示数据
    * 业务层：
        处理业务需求
    * 持久层：
        数据库交互

3. 持久层技术解决问题和方案
    1. 问题
        数据库的连接和访问，数据查询效率，操作繁琐，不能将注意力聚焦到SQL处理上
        JDBC,Spring JDBCTemplate，传统的数据库连接方法，一组解决数据库连接的规范

    2. MyBatis概述
        * 基于Java的持久层框架
        * 内部封装了jdbc的细节,使用者只需要关注SQL语句，不用关心加载驱动，数据库连接，Statement对象等过程
        * 使用ORM(Object Relation Mapping)思想实现了结果集的封装
            PS: ORM
                数据库表和实体类以及实体类的属性对应起来，可以操作实体类实现操作数据表
                    user表        User类
                    id          userId</code></pre><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="1-MyBatis入门"><a href="#1-MyBatis入门" class="headerlink" title="1. MyBatis入门"></a>1. MyBatis入门</h2><pre><code>1. 环境搭建
    1. new --&gt; project --&gt; maven 设置名称，导入坐标pom.xml
    2. 创建实体类和Dao的接口:Dao(data access object 数据访问对象)
    3. 创建mybatis的主配置文件
        * SqlMapConfig.xml ：&lt;property &gt; 标签名称需要匹配，ps:username 不是 user
    4. 创建映射配置文件
        * UserDao.xml :&lt;mapper namespace=&quot;UserDao的路径&quot;&gt;

    注意事项：
        1. 创建UserDao.xml UserDao.java，mybatis中将持久层的操作接口名称和映射文件也叫做：Mapper
            UserDao 和 UserMapper相同
        2. 在idea创建目录时，和包的创建不同
            包在创建时，com.mybatis_base_01.dao 三层结构
            目录：com.mybatis_base_01.dao 一级目录
        3. 映射配置文件位置必须和dao接口的包结构相同
        4. 映射配置文件的mapper标签的namespace属性取值为dao接口的全限定类名
        5. 映射配置文件的操作设置，id取值必须时dao接口的方法名

        在实现3，4，5后，dao的实现类由mybatis实现

2. 使用案例
    1. 配置文件
        * InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
    2. 创建SqlSessionFactory对象
        * SqlSessionFacotryBulider builder = new SqlSessionFacotryBuilder();
        * SqlSessionFacotry facotry = builder.build(in);
    3. 创建SqlSession对象
        * SqlSession session = facotry.openSession();
    4. 创建UserDao代理对象
        * UserDao userDao = session.getMapper(UserDao.class);
    5. 使用UserDao代理对象执行操作
        * List&lt;User&gt; userDao = userDao.findAll();
    6. 释放资源
        * session.close();
        * in.close();

3. 简单分析
    1. 配置文件
        Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); 
        * 使用类加载器，只能读取类路径的配置文件
        * 使用ServletContext对象的getRealPath()

    2. 创建SqlSessionFactory工厂
        * 使用了创建者模式：SqlSessionFacotryBuilder builder 构造者 builder.build(in) 建立工厂
        * 使用了工厂模式：SqlSessionFactory 降低类之间的依赖关系

    3. 创建SqlSeccion对象
    4. 创建接口实现类

4. 使用注解开发MyBatis
    1. 将UserDao.xml移除，在Dao接口的方法上使用@Select()注解，并且指定sql语句
    2. 在SqlMapConfig.xml中的Mapper配置时，使用class属性指定Dao接口的全限定类名

5. 自定义MyBatis分析
    Mybatis在使用代理Dao对象实现增删改查做了什么事？
        1. 创建代理对象
        2. 调用selectList()方法</code></pre><blockquote>
<pre><code>&lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis_test&quot;/&gt;
&lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
&lt;property name=&quot;password&quot; value=&quot;root2019&quot;/&gt;</code></pre></blockquote>
<pre><code>连接数据库的语句，可以产生Connnection对象</code></pre><blockquote>
<mappers>
<mapper resource="com/mybatis_base_03/dao/UserDao.xml">
</mapper></mappers>
</blockquote>
<blockquote>
<pre><code>&lt;mapper namespace=&quot;com.mybatis_base_03.dao.UserDao&quot;&gt; 
&lt;!--配置查询所有--&gt;
&lt;select id=&quot;findAll&quot; resultType=&quot;com.mybatis_base_03.domain.User&quot;&gt;
   select * from user
&lt;/select&gt;</code></pre></blockquote>
<pre><code>映射配置信息 -&gt; 全限定类名，以及执行的SQL语句。
解析.xml配置文件 -&gt; 有了上面的三个信息
    1. 根据配置数据库的语句，可以创建Connection对象
        注册驱动，创建连接对象
    2. 获取预处理对象PreparedStatement
        获取SQL语句
    3. 对结果进行封装
        根据实体类的全限定类名</code></pre><h3 id><a href="#" class="headerlink" title></a></h3><pre><code>6.自定义MyBatis中涉及的实体类和接口
    1. class Resources
    2. class SqlSessionBuilder
    3. interface SqlSessionfacotry
    4. interface SqlSession
    这个过程完成了两件事：
        创建接口代理对象，
        实现查询语句

MyBatis将JDBC的功能进行封装，形成功能调用。SqlMapConfig.xml,daoInterfaceClass.xml里面包含对数据库的连接与查询的语句以及返回的结果类型。

SqlMapConfig.xml中的&lt;property&gt;标签包含数据库的连接对象，&lt;mappers/mapper&gt;包含接口的文件位置。
daoInterfaceClass.xml包含数据库语句，返回数据类的全限定类名，以及方法的namespace(根据查查询语句以及namespace确定方法的唯一性)。

根据这两个配置文件，可以通过对.xml文件的解析，获取相应的配置文件信息，由此构建代理对象，g根据返回数据的类型获取数据，实现整个的查询过程。</code></pre><h2 id="MyBatis的CRUD"><a href="#MyBatis的CRUD" class="headerlink" title="MyBatis的CRUD"></a>MyBatis的CRUD</h2><h3 id="MyBatis的配置文件"><a href="#MyBatis的配置文件" class="headerlink" title="MyBatis的配置文件"></a>MyBatis的配置文件</h3><pre><code>1. pom.xml的配置信息
    * 坐标的导入
        1.mybatis的坐标导入
        2.mysql的驱动坐标导入
        3.log4j的坐标导入
            log4j.properties配置文件放在资源目录下
        4.junit单元测试的坐标导入

2. SqlMapConfig.xml的配置
    1. &lt;environments&gt;:配置数据库
        1. 数据库连接
        2. 数据库的事务类型
        3. 数据库的数据源
        4. 数据库的连接（driver url username password）</code></pre><blockquote>
<pre><code>&lt;!--配置环境--&gt;
&lt;environments default=&quot;mysql&quot;&gt;
 &lt;!--配置mysql的环境--&gt;
 &lt;environment id=&quot;mysql&quot;&gt;
  &lt;!--配置事务--&gt;
  &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
  &lt;!--配置连接池--&gt;
  &lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;!--mysql的连接信息--&gt;
    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis_test&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root2019&quot;/&gt;
  &lt;/dataSource&gt;
 &lt;/environment&gt;
&lt;/environments&gt;</code></pre></blockquote>
<pre><code>2. &lt;mappers&gt;:配置dao的数据接口
    1. recource:表示配置方式为.xml
    2. class:表示配置方式为注解
    &lt;!--配置映射文件的位置--&gt;</code></pre><blockquote>
<pre><code>&lt;mappers&gt;
    &lt;mapper resource=&quot;com/mybatis_base_04_crud/dao/IUserDao.xml&quot;&gt;&lt;/mapper&gt;
  &lt;/mappers&gt;</code></pre></blockquote>
<pre><code>3. DaoInterface.xml
    1.&lt;mapper&gt;中的namespase 与 &lt;select&gt;中的id构成方法的唯一标识
    2.&lt;select&gt;中的文本内容为要执行的语句
    3.&lt;select&gt;中的 resultType 返回值类型</code></pre><blockquote>
<pre><code>&lt;!--namespace 接口--&gt;
&lt;mapper namespace=&quot;com.mybatis_base_04_crud.dao.IUserDao&quot;&gt;

 &lt;select id=&quot;finaAll&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
       select * from user
  &lt;/select&gt;
&lt;/mapper&gt;</code></pre></blockquote>
<h3 id="MyBatis的数据操作"><a href="#MyBatis的数据操作" class="headerlink" title="MyBatis的数据操作"></a>MyBatis的数据操作</h3><h4 id="保存数据-Insert"><a href="#保存数据-Insert" class="headerlink" title="保存数据(Insert)"></a>保存数据(Insert)</h4><pre><code>1. Dao接口的方法
    在IUserDao.java中添加saveUser方法
2. daoInterace.xml中的配置
    在&lt;mapper&gt;中增加&lt;insert&gt;标签，选择参数化类型，对于数据填充，采用#{}方式</code></pre><blockquote>
<pre><code>&lt;!-- 保存用户 --&gt;
  &lt;!--参数类型 parameterType--&gt;
  &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
        insert into user(username,address,sex,birthday) value(#{username},#{address},#{sex},#{birthday})
 &lt;/insert&gt;
实体类的属性定义与数据库中的列名一致,setter和getter方法自动生成，可以直接使用属性名称来传递参数，否则可以使用.getUsername()来传递参数。    </code></pre></blockquote>
<pre><code>3. 调用方法
    在生成数据库的代理对象后，直接调用save方法就可以        

4. 注意事项
    在使用方法后，需要对数据进行提交，默认自动提交关闭，需要手动打开自动提交
    session.commit();</code></pre><h5 id="保存数据的同时返回id"><a href="#保存数据的同时返回id" class="headerlink" title="保存数据的同时返回id"></a>保存数据的同时返回id</h5><pre><code>1.daoInterface.xml
    在原本的&lt;insert&gt;标签内，增加&lt;selectKey&gt;标签</code></pre><blockquote>
<pre><code>&lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;
  select last_insert_id();
&lt;/selectKey&gt;
在执行结束之后，会将id返回到user的id属性之中
keyProperty=&quot;id&quot; 实体类的属性
keyColumn=&quot;id&quot; 数据表中的列名</code></pre></blockquote>
<h4 id="更新数据-Update"><a href="#更新数据-Update" class="headerlink" title="更新数据(Update)"></a>更新数据(Update)</h4><pre><code>1. Dao接口的方法
    void saveUser(User user);
2. daoInterace.xml</code></pre><blockquote>
<pre><code>&lt;!-- 更新 --&gt;
  &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
    update user set username = #{username},address=#{address},sex=#{sex},birthday=#{birthday} where id=#{id}
  &lt;/update&gt;</code></pre></blockquote>
<h4 id="删除数据-Delete"><a href="#删除数据-Delete" class="headerlink" title="删除数据(Delete)"></a>删除数据(Delete)</h4><pre><code>1. Dao接口的方法
    void deleteUser(Integer userId);
2. daoInterface.xml</code></pre><blockquote>
<pre><code>&lt;!-- 删除数据 --&gt;
  &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
    delete from user where id=#{uid}
  &lt;/delete&gt;</code></pre></blockquote>
<pre><code>3. 注意事项
    删除数据中只有一个元素，#{}中的元素只是起到一个占位符的作用，与名称无关</code></pre><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><h5 id="根据用户id"><a href="#根据用户id" class="headerlink" title="根据用户id"></a>根据用户id</h5><pre><code>1. dao接口的方法
    User finaById(Integer id);
2. daoInterface.xml
    需要传入参数，以及返回值类型</code></pre><blockquote>
<pre><code>   &lt;!-- 根据id查询一个 --&gt;
&lt;select id=&quot;findById&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
   select * from user where id=#{id}
&lt;/select&gt;</code></pre></blockquote>
<h5 id="根据用户name"><a href="#根据用户name" class="headerlink" title="根据用户name"></a>根据用户name</h5><pre><code>1. dao接口的方法
    List&lt;User&gt; findByName(String name);
2. daoInterface.xml</code></pre><blockquote>
<pre><code>&lt;!-- 根据名称模糊查询 --&gt;
&lt;select id=&quot;findByName&quot; parameterType=&quot;string&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
 select * from user where username like #{name}</code></pre>  
</blockquote>
<pre><code>3. 注意事项
    &apos;#{}中没有模糊查询的 “-” “%” 在调用传参数时，需要给出“%王%”,查询语句为预处理SQL语句
    &apos;%${value}%&apos;,参数为“王”，查询语句为拼接字符串</code></pre><h3 id="MyBatis中的参数-parameterType"><a href="#MyBatis中的参数-parameterType" class="headerlink" title="MyBatis中的参数(parameterType)"></a>MyBatis中的参数(parameterType)</h3><h4 id="参数的类型-parameterType"><a href="#参数的类型-parameterType" class="headerlink" title="参数的类型(parameterType)"></a>参数的类型(parameterType)</h4><pre><code>1. 简单数据类型
    int String ...

2. 传递pojo对象
    pojo对象：
        POJO简单理解为不包含业务逻辑的单纯用来存储数据的java类（实际就是普通JavaBean)

    OGNL表达式：</code></pre><p><em>Object Graphic Navigation Language</em><br>        (对象图形导航语言)</p>
<pre><code>    通过对象的取值方法来获取数据，在写法上，将get给忽略了
    比如：获取用户的名称
        类中的写法：user.getUsername()
        OGNL表达式：user.username()
    mybatis中可以直接使用username,不用书写user.
        因为在parameterType中已经提供属性所在的类

3. 传递pojo包装对象
    参数为被封装的数据，查询条件是综合的查询条件</code></pre><blockquote>
<pre><code>&lt;!-- 根据queryVo查询数据 --&gt;
&lt;select id=&quot;findByQueryVo&quot; parameterType=&quot;com.mybatis_base_04_crud.domain.QueryVo&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
  select * from user where username like #{user.username}
&lt;/select&gt;</code></pre></blockquote>
<pre><code>QueryVo内部封装user对象，在参数传递时#{}，中的参数为 QueryVo.user.username,可以写为 user.username,代表参数为QueryVo中数据对象user中的属性username</code></pre><h4 id="结果集的封装-resultType"><a href="#结果集的封装-resultType" class="headerlink" title="结果集的封装(resultType)"></a>结果集的封装(resultType)</h4><pre><code>实体类的属性名与数据库的列名不相同？
    1. 给数据库中的列名起别名
        将所有查询的数据字段的名称别名改为实体类对应的属性名称
        书写更为复杂，但是查询到的数据在数据库端被处理，效率更高
    select id as uesrId,username as userName, address as userAddress, sex as userSex,birthday as userBirthday from user;

    2. 使用resultMap进行字段对应</code></pre><blockquote>
<pre><code>&lt;!-- 配置 查询结果的列名和属性名一致 --&gt;
&lt;resultMap id=&quot;userMap&quot; type=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
    &lt;!-- 主键字段的一致 --&gt;
    &lt;id property=&quot;userId&quot; column=&quot;id&quot;/&gt;
    &lt;!-- 非主键字段的一致 --&gt;
    &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
    &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt;
    &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;
    &lt;result property=&quot;userBirthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;
&lt;/resultMap&gt;

&lt;!--select id as uesrId,username as userName, address as userAddress, sex as userSex,birthday as userBirthday from user;--&gt;
&lt;select id=&quot;finaAll&quot; resultMap=&quot;userMap&quot;&gt;
    select * from user;
&lt;/select&gt;</code></pre></blockquote>
<pre><code>resultMap中的id为映射标记，返回值必须更改为resultMap=&quot;userMap&quot;，进行绑定
id 数据库中的主键字段数据绑定
result 非主键字段的数据绑定
property 实体类中的属性名称
column 数据库中的字段名称

    3. 两种方法的不同    
        直接使用别名，运行效率更高，但编写效率较低
        使用resultMap，运行效率低，但是编写效率高</code></pre><h3 id="MyBatis实现DAO开发"><a href="#MyBatis实现DAO开发" class="headerlink" title="MyBatis实现DAO开发"></a>MyBatis实现DAO开发</h3><h4 id="使用Dao的实现类"><a href="#使用Dao的实现类" class="headerlink" title="使用Dao的实现类"></a>使用Dao的实现类</h4><pre><code>1. 创建IUserDaoImpl.java
2. 在实现类中实现方法
    创建Sqlsession对象，在方法中调用相应的查询语句</code></pre><blockquote>
<pre><code>@Override
public List&lt;UserfinaAll() {
    //生成SqlSession对象
    SqlSession session = factory.openSession();
    //调用session的selectList方法，实现查询列表
    List&lt;Userusers = session.selectList(&quot;com.mybatis_base_04_DAO.dao.IUserDao.finaAll&quot;);
    //方法中的参数 能获取到信息的key namespace + methodName
    //释放资源
    session.close();
    return users;
}    </code></pre></blockquote>
<pre><code>* MyBatis实际上使用代理Dao的方式，将创建Dao实现类的过程给隐藏，用户无法感知到创建Dao实现类的过程。
* 自己使用Dao实现类实际上就是创建SqlSession对象，通过调用session.selectList()方法查询数据。
* 方法中的参数：（namaspace+methodName , 外部传入的参数）</code></pre><h3 id="执行过程分析"><a href="#执行过程分析" class="headerlink" title="执行过程分析"></a>执行过程分析</h3><h4 id="dao实现类的执行过程分析"><a href="#dao实现类的执行过程分析" class="headerlink" title="dao实现类的执行过程分析"></a>dao实现类的执行过程分析</h4><pre><code>1. selectList


2. insert update delete
    insert update delete最终调用的都是update方法

3. selectOne
    selectOne内部调用selectList方法，返回值为列表的第一个元素</code></pre><h4 id="代理Dao实现类的执行过程分析"><a href="#代理Dao实现类的执行过程分析" class="headerlink" title="代理Dao实现类的执行过程分析"></a>代理Dao实现类的执行过程分析</h4><p><em>暂时未进行书写</em></p>
<h3 id="SqlMapConfig-xml中的标签属性"><a href="#SqlMapConfig-xml中的标签属性" class="headerlink" title="SqlMapConfig.xml中的标签属性"></a>SqlMapConfig.xml中的标签属性</h3><pre><code>1. &lt;properties&gt;标签
    * 配置properties 可以在标签内部配置数据库的连接信息，也可以引用外部配置文件信息
    * 使用&lt;properties&gt;标签，在环境的数据源中的对应数据使用 ${名称} 可以引用
    * 可能会出现：未声明的文件，直接进行引用就可以了        

    resource属性：
          用于指定配置文件的位置，按照类路径的写法来写，必须存放于类路径下

    url属性：
          要求按照url的写法来书写地址
          url Uniform Resource Locator 统一资源定位符
          写法：
            http://localhost:8080/mybatisserver/demo1Serelet
            协议 主机 端口 URI
           URI Uniform Resource Identifier 统一资源标识符 应用中唯一定位的资源</code></pre><blockquote>
<pre><code>&lt;properties url=&quot;file:///D:/2017217796/java_program/MyCode/mybatis_base_04_crud/src/main/resources/jdbcConfig.properties&quot;&gt;

&lt;/properties&gt;

&lt;!--mysql的连接信息--&gt;
&lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
&lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
&lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
&lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;        </code></pre></blockquote>
<pre><code>2. &lt;typeAliases&gt;标签
    1). &lt;typeAlias&gt;标签
        * typeAlias配置别名，只能配置domain中的实体类
        * type指定全限定属性名 alias指定别名 不在区分大小写</code></pre><blockquote>
<pre><code>&lt;typeAlias type=&quot;com.mybatis_base_04_crud.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;</code></pre></blockquote>
<pre><code>2). &lt;package&gt;标签
    * 用于指定要配置别名的包，当指定后，该包中的所有实体类都会被注册别名，且类名就是别名，不再区分大小写</code></pre><blockquote>
<pre><code>&lt;package name=&quot;com.mybatis_base_04_crud.domain&quot;/&gt;</code></pre></blockquote>
<pre><code>3. &lt;mappers&gt;标签
    * package指定接口所在的包，一但指定，就不需要写resource和class以及mapper</code></pre><blockquote>
<pre><code>&lt;package name=&quot;com.mybatis_base_04_crud.dao&quot;/&gt;</code></pre></blockquote>
<h2 id="MyBatis的连接池"><a href="#MyBatis的连接池" class="headerlink" title="MyBatis的连接池"></a>MyBatis的连接池</h2><h3 id="连接池的使用与分析"><a href="#连接池的使用与分析" class="headerlink" title="连接池的使用与分析"></a>连接池的使用与分析</h3><h4 id="连接池的含义"><a href="#连接池的含义" class="headerlink" title="连接池的含义"></a>连接池的含义</h4><pre><code>连接池是用于存储连接的一个容器
容器其实就是一个集合对象，该集合必须是线程安全的，不能两个线程拿到同一个连接
该集合必须实现队列的特性：先进先出

使用连接池可以减少获取连接的时间</code></pre><h4 id="MyBatis的连接池-1"><a href="#MyBatis的连接池-1" class="headerlink" title="MyBatis的连接池"></a>MyBatis的连接池</h4><pre><code>1. SqlMqpConfig.xml中的datasource标签，type属性表示使用何种连接池方式
    type的取值：
        POOLED : 采用传统的javax.sql.DataSource规范的连接池
        UNPOOLED ：采用传统的获取连接的方式，虽然也实现了javax.sql.DataSource接口，但是没有池的概念，每次使用都获取新的连接
        JNDI ：采用服务器提供的JNDI实现，获取DataSource对象，不同的服务器拿到的对象不一样，如果不是web或者maven的war工程，不能使用
        使用tomcat服务器，使用的连接池dbcp连接池</code></pre><blockquote>
<pre><code>&lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;!--mysql的连接信息--&gt;
    &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
&lt;/dataSource&gt;</code></pre></blockquote>
<p><img src="/2020/05/15/mybatis/datasource_0.png" alt="POOLED"><br><img src="/2020/05/15/mybatis/pooled_datasource_1.png" alt="POOLED"><br><img src="/2020/05/15/mybatis/pooled_datasource_2.png" alt="POOLED"></p>
<h4 id="补充JNDI数据库连接池"><a href="#补充JNDI数据库连接池" class="headerlink" title="补充JNDI数据库连接池"></a>补充JNDI数据库连接池</h4><h4 id="MyBatis中的事务"><a href="#MyBatis中的事务" class="headerlink" title="MyBatis中的事务"></a>MyBatis中的事务</h4><pre><code>1. MyBatis通过commit以及rollback来进行事务控制
2. 一般不设置自动提交，因为一旦多个事务提交，难以控制</code></pre><h2 id="MyBatis基于XML配置的动态SQL语句使用"><a href="#MyBatis基于XML配置的动态SQL语句使用" class="headerlink" title="MyBatis基于XML配置的动态SQL语句使用"></a>MyBatis基于XML配置的动态SQL语句使用</h2><h4 id="if-标签"><a href="#if-标签" class="headerlink" title="if 标签"></a>if 标签</h4><pre><code>* 根据条件来进行查询，此时条件可能不全，有可能缺少某些项，会根据条件具体生成查询语句
SQL语句中的名称不区分大小写，但是查询条件需要根据实体类相关，一般来说实体类的属性名与数据库的列名相同。</code></pre><blockquote>
<pre><code>&lt;!-- 根据条件查询 --&gt;
&lt;select id=&quot;findUserByCondition&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;
 select * from user where 1=1
 &lt;if test=&quot;userName != null&quot;&gt;
   and username like #{userName}
 &lt;/if&gt;</code></pre>   
</blockquote>
<pre><code>* test：判断输入的条件，如果条件满足，查询条件会包含if标签内部的语句
* 可以多个if标签一起使用
* 条件同时满足的时候使用 and ，可以在数据库语句中使用</code></pre><h4 id="where标签"><a href="#where标签" class="headerlink" title="where标签"></a>where标签</h4><pre><code>* 使用where标签将if标签包裹起来，在查询条件中就不用书写 where 1 = 1</code></pre><blockquote>
<pre><code>  &lt;!-- 根据条件查询 --&gt;
&lt;select id=&quot;findUserByCondition&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;
select * from user
&lt;where&gt;
  &lt;if test=&quot;userName != null&quot;&gt;
    and username like #{userName}
  &lt;/if&gt;
  &lt;if test=&quot;userSex != null&quot;&gt;
    and sex = #{userSex}
  &lt;/if&gt;
&lt;/where&gt;</code></pre>  
</blockquote>
<h4 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h4><blockquote>
<pre><code>&lt;!-- 根据QueryVo中的ids进行查询，集合尽心查询列表 --&gt;
&lt;select id=&quot;findUserInIds&quot; parameterType=&quot;queryvo&quot; resultMap=&quot;userMap&quot;&gt;
select * from user
&lt;where&gt;
  &lt;if test=&quot;ids != null and ids.size() 0&quot;&gt;
    &lt;foreach collection=&quot;ids&quot; open=&quot;and id in (&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;
      #{id}
    &lt;/foreach&gt;
  &lt;/if&gt;
&lt;/where&gt;</code></pre>  
</blockquote>
<pre><code>* 查询满足条件的集合元素:select * from user where id in (?)
* foreach:
* collection:代表要遍历的集合元素
* open:语句的开始部分
* close:语句的结束部分
* item:遍历的每个元素，生成的变量名
* separtor:分割符

其中&lt;foreach&gt;中的语句 #{}中的名称，需要与item一致

在进行多个数据一起插入的时候，可以使用foreach进行 values()的赋值</code></pre><h4 id="sql标签"><a href="#sql标签" class="headerlink" title="sql标签"></a>sql标签</h4><pre><code>* 抽取重复的SQL语句，避免重复书写语句
* 然后在语句中使用&lt;include&gt;来引用抽取的语句
* 如果后面还有需要拼接的条件，不能 书写分号</code></pre><blockquote>
<pre><code>&lt;!-- 抽取重复的语句 --&gt;
&lt;sql id=&quot;defaultUser&quot;&gt;
  select * from user
&lt;/sql&gt;

&lt;!--select id as uesrId,username as userName, address as userAddress, sex as userSex,birthday as userBirthday from user;--&gt;
&lt;select id=&quot;finaAll&quot; resultMap=&quot;userMap&quot;&gt;
  &lt;include refid=&quot;defaultUser&quot;&gt;&lt;/include&gt;
&lt;/select&gt;</code></pre></blockquote>
<h2 id="Mybatis的多表操作"><a href="#Mybatis的多表操作" class="headerlink" title="Mybatis的多表操作"></a>Mybatis的多表操作</h2><pre><code>表之间的关系：
    一对一
    多对一
    一对多
    多对多

举例：
    用户对于订单：一对多
    订单对于用户：多对一
        一个用户可能有多个订单
        多个订单属于一个用户

    一对一：
        一个人只能有一身份证号
        一个身份证号属于一个人

    多对多：
        一个学生被多个老师交过
        一个老师交过多个学生

在MyBatis中，认为订单与用户之间的关系，每拿出一个订单，只能属于一个用户
所以，所有的多对一，全都为一对一

案例：
    使用用户与账户之间的关系
        一个用户可以有多个账户
        一个账户只能属于一个用户(多个账户也是一个用户)

步骤：
    1. 建立两张表：用户表 账户表
        用户与账户具有关系：使用外键
    2. 建立两个实体类：用户实体 账户实体
    3. 建立两个配置文件
        用户配置文件
        账户配置文件
    4. 实现配置
        当查询用户时，可以出现账户信息
        查询账户时，可以显示出对应的用户信息</code></pre><h3 id="一对一查询的结果封装《association》"><a href="#一对一查询的结果封装《association》" class="headerlink" title="一对一查询的结果封装《association》"></a>一对一查询的结果封装《association》</h3><pre><code>1. 通过书写子类来进行配置查询
    * 建立新的结果集的封装类，将查询到的结果进行封装
    * 每次查询不同的数据需要书写不同的字类，太过于麻烦

2. 建立实体类之间的关系来进行数据封装
    * 主表与从表之间存在联系，主表实体和从表实体之间也存在联系
    * 从表包含主表实体的引用
    * 据此，创建resultMap，进行结果封装
    * 使用 association 进行一对一的结果封装</code></pre><blockquote>
<pre><code> &lt;!-- 定义封装account和user的resultMap --&gt;
&lt;resultMap id=&quot;accountuser&quot; type=&quot;account&quot;&gt;
&lt;id property=&quot;id&quot; column=&quot;aid&quot;&gt;&lt;/id&gt;
&lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;
&lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt;
  &lt;!-- 一对一的关系映射:配置封装user的信息 --&gt;
  &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
  &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
  &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;
  &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;
  &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt;
&lt;/association&gt;</code></pre>  
</blockquote>
<pre><code>在association中，如果不写javaType,报错：空指针异常
javatype:将数据封装到实体对象中</code></pre><h3 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询<collection></collection></h3><pre><code>* 一对多连接，主表的实体类需要包含从表实体类的集合引用，在配置文件中，使用collection标签来封装数据集合</code></pre><p><img src="/2020/05/15/mybatis/one2manyxml.png" alt="主体的配置文件"><br>        数据查询结果<br><img src="/2020/05/15/mybatis/one2many.png" alt="主体的配置文件"></p>
<pre><code>* 数据查询结果显示，数据为一对多情况，MyBatis将属于同一个用户的账户，封装到了账户的集合之中</code></pre><h3 id="多对多查询"><a href="#多对多查询" class="headerlink" title="多对多查询"></a>多对多查询</h3><pre><code>示例：用户与角色之间的关系
    一个用户可以拥有多个角色
    一个角色可以赋予多个用户

    典型的多对多

    1. 建立两张表：用户表 角色表
    2. 两者具有多对多的关系
        建立中间表，主键为两者的联合主键，中间表中是外键
    3. 建立两个实体类
        让用户和角色实体类能体现出多对多的关系
        两者分别包含对象集合引用
    4. 建立两个配置文件
    5. 实现配置
        查询用户时，同时得到包含的角色信息
        查询角色时，同时得到包含的用户信息</code></pre><p><img src="/2020/05/15/mybatis/many2many.png" alt="many2many的配置文件"><br><img src="/2020/05/15/mybatis/many2many_1.png" alt="many2many的配置文件"></p>
<pre><code>* 一个用户包含的所有角色信息，因为要包括所有的用户，不能使用内连接，应该使用外连接，在使用user_role表的时候，有可能列名相同,需要别名，在写配置resultMap时，注意别名</code></pre><h2 id="MyBatis延迟加载"><a href="#MyBatis延迟加载" class="headerlink" title="MyBatis延迟加载"></a>MyBatis延迟加载</h2><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><pre><code>在一对多的数据查询的时候，一个用户，100个账户
    在查询用户信息的时候，要不要将账户的信息查询出来
    在查询账户信息的时候，要不要将用户的信息查询出来

    在查询账户的时侯，用户下的账户的信息应该是，什么时候使用，什么时候查询
    在查询用户的时候，账户下的用户的信息应该是，随着账户的信息一起查询出来

1. 延迟加载
    在真正使用数据的时侯，才将数据查询出来；不使用的时候，不进行查询

2. 立即加载
    无论数据是否使用，一旦调用方法，马上进行查询

3. 使用时机
    一对一，多对一：立即加载（一般需要立刻看到信息）
    一对多，多对多：延迟加载（一般不需要立刻看到信息）</code></pre><h4 id="实现延迟加载"><a href="#实现延迟加载" class="headerlink" title="实现延迟加载"></a>实现延迟加载</h4><pre><code>1. 在一对一的时候实现延迟加载
    * 更改查询语句
        在此时，不需要将所有的数据全都查询出来，只需要将所有的账户查询出来，不需要带着用户信息
    * 修改结果集
        由于不需要用户信息，结果集的封装可以删除
    * 修改级联查询语句
        在&lt;association&gt;语句中，增加select属性，指明查询的唯一标识</code></pre><blockquote>
<pre><code>&lt;!-- 定义封装account和user的resultMap --&gt;
&lt;resultMap id=&quot;accountuserMap&quot; type=&quot;account&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
  &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;
  &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt;

&lt;!-- 一对一的关系映射:配置封装user的信息,
select 查询用户的唯一标识,在接口文件中，根据id查询用户的方法
column 用户根据id查询时，所需要的参数的值，此地将查询出来的uid作为参数传入
 --&gt;
&lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot; select=&quot;com.mybatis_base_06_lazyload.dao.IUserDao.findById&quot;&gt;

&lt;/association&gt;</code></pre>  
</blockquote>
<pre><code>* 修改SqlMapConfig.xml,打开延迟加载开关
    打开延迟加载的开关，关闭立即加载的开关</code></pre><blockquote>
<pre><code>&lt;!-- 配置参数。延迟加载 --&gt;
&lt;settings&gt;
  &lt;!-- 开启延迟加载的全局开关 --&gt;
  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;!-- 立即加载 --&gt;
  &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;
&lt;/settings&gt;</code></pre></blockquote>
<p><img src="/2020/05/15/mybatis/lazyload1.png" alt="一对一的延迟加载"></p>
<pre><code>2. 什么是按需？
    1. 在进行单独数据查询，或者是数据遍历时，才会将所有数据显示出来
    2. 根据用户的id，或者其他的要求进行数据查询

3. 一对多的数据查询    
    与一对一的延迟加载相似,查询语句，结果集，以及账户实体类中的按照id查询</code></pre><p><img src="/2020/05/15/mybatis/lazyload2.png" alt></p>
<h2 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h2><h3 id="缓存基本概念"><a href="#缓存基本概念" class="headerlink" title="缓存基本概念"></a>缓存基本概念</h3><pre><code>存在内存中的临时数据

1. 为什么使用缓存？
    减少和数据库的交互次数，提高执行效率

2. 什么数据能使用缓存，什么数据不能使用？
    1. 适用于缓存：
        经常查询并且不经常改变的
        数据的正确性对最终结果影响不大的

    2. 不适用缓存：
        经常改变的数据
        数据的正确性对最终结果影响很大的
            （商品的库存，银行的汇率，股市的股价）</code></pre><h3 id="MyBatis的缓存-1"><a href="#MyBatis的缓存-1" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h3><pre><code>1. 一级缓存：
    它是指Mybatis中的SqlSession对象的缓存
    当我们执行查询的时候，查询的结果会同时存入到SqlSession为我们提供的一块区域内
    该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去SqlSession中查询是否存在，有的话，直接拿来使用
    当SqlSession对象消失时，一级缓存同时消失

    1. 缓存同步问题
        如果调用session的insert update delete close() commit() clearcache()方法，会自动放弃当前的一级缓存，直接从数据库中查询数据

2. 二级缓存
    由MyBatis中SqlSessionFactory对象的缓存，同一个SqlSessionFactory对象创建的SqlSession对象共享其缓存。

    1. 二级缓存的使用步骤
        1. 让MyBatis支持二级缓存 SqlMapConfig.xml配置
        2. 让当前的映射文件支持二级缓存，IUserDao.xml
        3. 让当前的操作支持二级缓存，select标签</code></pre><h2 id="MyBatis注解开发"><a href="#MyBatis注解开发" class="headerlink" title="MyBatis注解开发"></a>MyBatis注解开发</h2><h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><pre><code>1. 在SqlMapConfig.xml中的mapper中，使用class,导入接口资源文件
2. 在接口类上，使用注解进行开发
3. 其余步骤与使用xml开发一致

注意：
    如果在与接口类的相同路径下的资源路径下，建立IUserDao.xml文件，不管有没有使用.xml文件，都会产生错误。</code></pre><h3 id="名称不一致"><a href="#名称不一致" class="headerlink" title="名称不一致"></a>名称不一致</h3><pre><code>1. 实体类名与数据库列名不一致
    1. 使用别名，将数据库中查询出来的数据进行设置别名
    2. 使用@Results注解，进行配置</code></pre><blockquote>
<pre><code>/**
 * 查询所有,获取所有的账户信息
 */
@Select(&quot;select * from user&quot;)
@Results(id= &quot;userMap&quot;,value = {
        @Result(id=true,column = &quot;id&quot;,property = &quot;userId&quot;),
        @Result(column = &quot;username&quot;,property = &quot;userName&quot;),
        @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;),
        @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;),
        @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;)
})
List&lt;UserfindAll();

@Select(&quot;select * from user where id=#{id}&quot;)
@ResultMap(value = {&quot;userMap&quot;})
User findById(Integer id);</code></pre></blockquote>
<pre><code>    * @Results中id是唯一标识，定义之后，可以在别的位置使用
        values代表结果对应的封装数组

    * @Result中，id代表是否为唯一标识，默认为false
        column:数据库列名
        property:实体类属性名

2. 定义了@Results注解
    想在别的地方使用，使用@resultMap注解
            @ResultMap(value = {&quot;userMap&quot;}) //完整写法
    values已经定义好的结果集封装</code></pre><h3 id="一对多查询注解版"><a href="#一对多查询注解版" class="headerlink" title="一对多查询注解版"></a>一对多查询注解版</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre><code>结果集的封装，主要关注@Result中的属性：one many
一对一：使用one 
一对多：使用many</code></pre><p><img src="/2020/05/15/mybatis/anno_one2many.png" alt="注解配置"></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><pre><code>1. mybatis-config 的properties配置属性</code></pre><p><img src="/2020/05/15/mybatis/error_1.png" alt="配置文件无法找到"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛云_Hexo</title>
    <url>/2020/05/12/%E4%B8%83%E7%89%9B%E4%BA%91-Hexo/</url>
    <content><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><pre><code>1. 注册七牛云,完成之后就可以进行创建空间，
2. 注意我们添加的资源为对象存储，访问控制为公开空间
3. 点击右上角进入密钥管理，复制当前使用的AK和SK，配置的时候会用得到</code></pre><h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h2><h3 id="2-1-安装插件，进入Hexo主目录，执行："><a href="#2-1-安装插件，进入Hexo主目录，执行：" class="headerlink" title="2.1. 安装插件，进入Hexo主目录，执行："></a>2.1. 安装插件，进入Hexo主目录，执行：</h3><pre><code>`npm install hexo-qiniu-sync --save`</code></pre><h3 id="2-2-配置站点文件-config-yml"><a href="#2-2-配置站点文件-config-yml" class="headerlink" title="2.2. 配置站点文件_config.yml:"></a>2.2. 配置站点文件_config.yml:</h3><blockquote>
<p>  #plugins:<br>      #- hexo-qiniu-sync<br>    qiniu:<br>      offline: false<br>      sync: true<br>      bucket: bucket_name<br>      access_key: AccessKey<br>      secret_key: SecretKey<br>      dirPrefix:<br>      urlPrefix: <a href="http://7xqb0u.com1.z0.glb.clouddn.com" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com</a><br>      local_dir: cdn<br>      update_exist: true<br>      image:<br>        folder: images<br>        extend:<br>      js:<br>        folder: js<br>      css:<br>        folder: css</p>
</blockquote>
<h3 id="2-3-参数"><a href="#2-3-参数" class="headerlink" title="2.3. 参数"></a>2.3. 参数</h3><ul>
<li><p>bucket ：修改为你刚才申请的七牛空间名称</p>
</li>
<li><p>access_key 、 secret_key : 上传密钥AccessKey、SecretKey。即3 第3步复制的AK和SK。</p>
</li>
<li><p>urlPrefix : 七牛空间地址的前缀。 重要！必填！ 因为现在七牛已经取消了二级域名，外链前缀类似设置中的 <a href="http://7xqb0u.com1.z0.glb.clouddn.com" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com</a> ，插件不能根据 bucket 自动生成外链前缀了。你可以进入自己创建的空间在域名设置中看到自己的七牛测试域名，也可以查看一个已上传的文件外链地址，确认前缀无误。这个参数的设置是保证解析成网页文件时，外链地址正确的关键之一！<br>  配置参数的说明：</p>
</li>
<li><p>offline ：是否离线。设置为 true 将在本地预览时使用本地地址渲染，省流量； false 将使用同步到七牛空间的静态资源渲染，方便检查资源链接是否正确。</p>
</li>
<li><p>sync ：是否同步到七牛，一般都是设置 true 啦</p>
</li>
<li><p>dirPrefix ：资源将上传到七牛空间的此目录下，可像我一样设置为空。该参数会影响外链的地址，如果设置为非空值，例如默认值 static ，则 urlPrefix 为保持一致需加上目录后缀 /static ，改为 <a href="http://7xqb0u.com1.z0.glb.clouddn.com/static" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com/static</a> 。</p>
</li>
<li><p>local_dir ：本地资源储存目录。在本例中，待上传的资源都储存在hexo主目录中的 cdn 文件夹（也就是与 source 目录平级）中。</p>
</li>
<li><p>update_exist ：设置为 true ，则会在文件更新之后重新上传并更新七牛空间上中的原有文件。</p>
</li>
<li><p>image/js/css ：子参数folder为不同静态资源种类的目录名称，一般不需要改动</p>
</li>
<li><p>image.extend ：使用 qnimg 标签引用图片的默认图片处理操作。可以使用 基本图片处理（imageView2）、高级图片处理（imageMogr2）、图片水印处理（watermark） 这三个图片处理接口，多个接口内容之间用 | 间隔。详见 七牛开发者中心-图片处理。</p>
</li>
</ul>
<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><pre><code>1.将图片上传到七牛云，查看照片获取照片的外链
2.在文章中引用照片外链，markdown格式:*![描述]（外链）*</code></pre><h2 id="4-感谢在使用七牛云时参考的大佬博客："><a href="#4-感谢在使用七牛云时参考的大佬博客：" class="headerlink" title="4. 感谢在使用七牛云时参考的大佬博客："></a>4. 感谢在使用七牛云时参考的大佬博客：</h2><ul>
<li><a href="http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/" target="_blank" rel="noopener">http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Inject</title>
    <url>/2020/05/09/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="SQL注入问题"><a href="#SQL注入问题" class="headerlink" title="SQL注入问题"></a>SQL注入问题</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>在拼接sql语句时，有一些特殊的SQL关键字参于字符串的拼接，导致SQL语句的逻辑发生变化，可能会造成安全性问题</code></pre><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><pre><code>1. 输入 a&apos;or&apos;a&apos;=&apos;a,条件改变
2. sql:select * from db where name and password = &apos;a&apos;or&apos;a&apos;=&apos;a&apos;,查询所有数据

原SQL语句拼接为: 

    String sql = &quot;select id from db where username=&apos;&quot;+username+&quot;&apos; and password=&apos;&quot;+password+&quot;&apos;&quot;;

用户输入的帐号密码分别为:

请输入您的帐号:
11111
请输入您的密码:
a&apos;or&apos;a&apos;=&apos;a
组成的SQL语句: 
select id from db where username=&apos;1111&apos; and password=a&apos;or&apos;a&apos;=&apos;a；</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><pre><code>使用预编译SQL语句,进行参数的传递

更改执行环境：Statement

使用新的环境: PreparedStatement

在通过连接对象，获取一个预编译的SQL环境(PreparedStatement)时, 需要传递一个SQL语句 ! 
在这个语句中 可以出现? , ? 表示准备填充的参数值!

使用步骤: 
    1. 通过连接对象, 获得一个预编译的SQL执行环境

        PreparedStatement state = conn.prepareStatement(sql);

        例如: 
            String sql = &quot;select id from db where username=? and password=?&quot;;

            PreparedStatement state = conn.prepareStatement(sql);    

    2. 向预编译参数列表中传递值: 

        预编译的SQL语句中可以包含【多个问号】, 每一个问号表示一个需要传递的值 
        我们通过PreparedStatement它的setXxx方法,来完成参数的传递
            传递参数时, 需要指定问号的索引, 问号的索引从1开始            

        例如:
            state.setString(1,username);
            state.setString(2,password);

    3. 执行语句:
            ResultSet result = state.executeQuery();</code></pre><h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><pre><code>填充预编译的参数: 
    * setXxx（问号索引,值）
        向预编译的SQL的?中传递值 
        参数1. 问号的索引,从1开始
        参数2. 填充到? 中的值

    * execute()
    * executeUpdate();
    * executeQuery();        </code></pre>]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Load</title>
    <url>/2020/05/09/SpringLoad/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code>在下载Spring时，碰到很多问题，在此记录下载流程，方便以后再次下载！</code></pre><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-搜索Spring官网-https-spring-io"><a href="#1-搜索Spring官网-https-spring-io" class="headerlink" title="1. 搜索Spring官网: https://spring.io/"></a>1. 搜索Spring官网: <a href="https://spring.io/" target="_blank" rel="noopener">https://spring.io/</a></h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_1.png" alt></p>
<h3 id="2-点击Projects"><a href="#2-点击Projects" class="headerlink" title="2. 点击Projects"></a>2. 点击Projects</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_2.png" alt></p>
<h3 id="3-点击Spring-Framework"><a href="#3-点击Spring-Framework" class="headerlink" title="3. 点击Spring Framework"></a>3. 点击Spring Framework</h3><h3 id="4-下拉界面，找到并点击-Spring-Framework-Artifacts"><a href="#4-下拉界面，找到并点击-Spring-Framework-Artifacts" class="headerlink" title="4. 下拉界面，找到并点击 Spring Framework Artifacts"></a>4. 下拉界面，找到并点击 Spring Framework Artifacts</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_3.png" alt></p>
<h3 id="5-找到并点击，http-repo-spring-io"><a href="#5-找到并点击，http-repo-spring-io" class="headerlink" title="5. 找到并点击，http://repo.spring.io"></a>5. 找到并点击，<a href="http://repo.spring.io" target="_blank" rel="noopener">http://repo.spring.io</a></h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_4.png" alt></p>
<h3 id="6-左边第二个图标，依次点击"><a href="#6-左边第二个图标，依次点击" class="headerlink" title="6.左边第二个图标，依次点击"></a>6.左边第二个图标，依次点击</h3><pre><code>libs-release-local ---&gt; org ---&gt; springframework ---&gt; spring</code></pre><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_5.png" alt><br><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_6.png" alt></p>
<h3 id="7-鼠标右键-Nature-Browser"><a href="#7-鼠标右键-Nature-Browser" class="headerlink" title="7.鼠标右键 Nature Browser"></a>7.鼠标右键 Nature Browser</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_7.png" alt></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2020/03/18/git/</url>
    <content><![CDATA[<h2 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h2><h3 id><a href="#" class="headerlink" title></a></h3><pre><code>1.什么是Git
    一种源代码管理工具（版本控制工具），方便对代码的管理

2.初始化Git仓库
    在放置代码的文件夹下，
    右键“git bash here”,输入命令&apos;git init&apos;,
    所有的文件放置在‘.git’文件夹下

3.配置身份信息
    声明当前的用户，“git config --global ”
    每次备份会将用户名和邮箱存储起来

    1.声明用户
        &apos;git config --global user.name &quot;用户名&quot;&apos;

    2.声明邮箱
        &apos;git config --global user.mail &quot;邮箱名&quot;&apos;
        邮箱不要求为现实邮箱，只要符合邮箱格式

4.将文件放置到Git
    自动将文件备份到隐藏文件夹‘.git’

    1.将代码添加到‘.git’仓库中（门口）
        &apos;git add &quot;文件路径名&quot;&apos;

    2.代码提交到‘.git’仓库中（房间）
        &apos;git commit -m “对文件的说明”&apos;
            -m message:必须要有文件说明

5.工作区 暂存区 版本库
    工作区：正在使用的文件夹
    暂存区：第一次添加的文件
    版本库：提交的源代码版本

6.查看当前状态
    &apos;git status&apos;
    文件是否放入版本库

7.批处理文件
    git add ./     :当前文件夹的所有修改过的内容放入暂存区
    git commit --all -m &quot;&quot;    :将所有的文件放入版本库

8.查看提交记录（日志）
    &apos;git log&apos; 显示提交的用户和时间
    简化提交日志
    &apos;git log --oneline&apos; :将日志简化为一条记录

9.恢复代码
    &apos;git reset --hard Head~0&apos;    ：回退到上次代码提交时的状态

10.根据版本号来进行回退
    &apos;git reset --hard &quot;版本号&quot;&apos;    ：将代码回退到某一次的提交时的状态

11.查看版本切换日志
    &apos;git reflog&apos;

12.创建分支，合并分支
    master:主分支

    1.创建分支
        &apos;git branch &quot;分支名&quot;&apos; 创建分支
        与master分支内容一样

    2.切换分支
        &apos;git checkout &quot;分支名&quot;&apos;    

    3.合并分支
        &apos;git merge &quot;分支名&quot;&apos;,当前分支与指定分支的合并

    4.查看分支
        &apos;git branch&apos;

13.手动合并分支
    合并后删除不需要的文件，再次将其进行提交

14.将代码提交到Github服务器上
    &apos;git push &quot;地址&quot; master&apos;
    exp:git push https://github.com/print3306/test007.git master

15.将代码从Github上下载
    &apos;git pull &quot;地址&quot; master&apos;
    exp:git pull https://github.com/print3306/test007.git master

    注意：在下载之前必须初始化一个仓库，pull会对数据进行合并

16.对数据的clone
    &apos;git clone &quot;地址&quot;&apos;
    远程仓库数据的复制，如果多次执行会覆盖本地内容

17.通过SSH来上传代码
    公钥和私钥：通过两者之间的联系验证身份
    生成公钥和私钥
        ssh-keygen -t rsa -C &quot;邮箱&quot;
        生成的公钥添加到Github的SSH上

18.本地和远程文件的版本不一样
    先将服务器上的数据下载下来，在本地修改，解决冲突后，再将最新版上传至服务器

19.简化push和pull
    增加远程变量，在当前的项目目录有效，变量代替地址
    git remote add &quot;变量名&quot; &quot;地址&quot;

    上传：git push &quot;变量名&quot; -u master
        本地当前分支和远程指定分支进行相关联,
        下一次只需要写上git push进行上传

    下载：git pull &quot;变量名&quot; -u master</code></pre>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL JDBC</title>
    <url>/2019/12/09/SQLjdbc/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>1. 基本概念
    Java DataBase Connectivity
    - java数据库连接，java操作数据库，使用同一套java代码操作不同的数据库
    - 本质：官方定义的操作所有关系型数据库的规则--接口，实现类由各个数据库厂商实现，提供数据库驱动jar包，我们可以使用这套接口（JDBC）编程，但真正执行的是驱动jar包中的实现类。
        Person接口   Worker类  Person p = new Worker();    p.eat();

2. 快速入门
    * 步骤：
        1. 导入驱动jar包
        2. 注册驱动
        3. 获取数据库的连接对象 Connection
        4. 定义SQL语句
        5. 获取执行SQL语句的对象 Statement = connection.statement()
        6. 处理SQL语句,接受返回结果 statememt.executeQuery(sql)
        7. 处理结果
        8. 释放资源

    * 代码：
        `
        //2.注册驱动
           Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);

           //3.获取数据库连接对象
        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/books?serverTimezone=UTC&quot;,&quot;uesrname&quot;,&quot;password&quot;);

        //4.定义SQL语句
        String sql = &quot;select * from admin&quot;;

        //5.获取执行SQL的对象
        Statement statement = connection.createStatement();

        //6.执行SQL
        boolean flag = statement.execute(sql);

        //7.处理
        System.out.println(flag);

        //8.释放资源
        statement.close();
        connection.close();
        `</code></pre><h2 id="对象详解"><a href="#对象详解" class="headerlink" title="对象详解"></a>对象详解</h2><pre><code>1. 详解各个对象
    1. DriverManager
        * 驱动管理对象
        * 功能：
            1. 注册驱动
                static void registerDriver(Driver driver):注册给定的驱动程序
                写代码：Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;)
                com.mysql.cj.jdbc.Driver,使用静态代码块，调用registerDriver方</code></pre><blockquote>
<pre><code>注册驱动:
 static {
      try {
            DriverManager.registerDriver(new Driver());
     } catch (SQLException var1) {
         throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);
     }
     }</code></pre></blockquote>
<pre><code>            PS：mysql5后的驱动jar包可以省略注册驱动的步骤

        2. 连接数据库
            * 方法：static Connection getConnection(String url, String user, String password)
            * 参数:
                * url:指定连接的路径
                    * 语法
                        jdbc:mysql://ip地址(域名)：端口号/数据库名称
                    * 例子
                        jdbc:mysql://localhost:3306/books?serverTimezone=UTC
                    * 细节
                        如果连接本机的mysql服务器，而且端口号3306，可以简写为jdbc:mysql:///数据库名称
                * user:
                    数据库用户名
                * password
                    密码

2. Connection
    * 数据库连接对象
    * 功能：
        1. 获取执行SQL的对象
            * Statement createStatement()
            * PreparedStatement preparedStatement()

        2. 管理事务
            * 开启事务
                void setAutoCommit(boolean autoCommit) :参数为false,开启事务
            * 提交事务
                commit()
            * 回滚事务
                rollback()

3. Statement
    * 执行SQL对象
    * 功能：
        1. 执行SQL语句
            * int executeUpdate(String sql):执行DML(增删改)语句，DDL语句，返回值：影响的行数，判断是否执行成功（&gt;0）
            * ResultSet executeQuery(String sql):执行查询语句

4. ResultSet
    * 结果集对象，封装查询结果
    * 功能：
        * boolean next():游标向前移动一行,并判断是否是最后一行，如果是，返回False
        * getType(参数)：获取数据,一次只能获取一列数据
            * Type：数据类型，int getInt()
            * 参数：
                1. int 列的编号，getInt(1)
                2. String 列名,getString(name)
        * 使用时：
            1. 游标向下移动
            2. 判断是否存在数据
            3. 获取数据
            代码：
                 while(resultSet.next()){
                    //获取数据
                 }

5. PreparedStatement
    * 执行SQL的对象
    * SQL注入问题：在拼接sql语句时，有一些特殊的关键字参于字符串的拼接，会造成安全性问题
        1. 输入用户随便，输入密码：a&apos;or&apos;a&apos;=&apos;a,条件恒为真，
        2. sql:select * from db where name and password,所有的用户名全都查询出来

    * 解决SQL注入问题：使用PreparedStatemmet类
    * 预编译SQL:参数使用 ？作为占位符
    * 步骤：
        1. 导入驱动jar包
        2. 注册驱动
        3. 获取数据库的连接对象 Connection
        4. 定义SQL语句
        5. 获取执行SQL语句的对象 PreparedStatement = connection.preparedStatement(sql)
            * 注意：sql使用?作为占位符， select * from user where name = ? and password = ?;
        6. 给？赋值
            * 方法：
            * setType(参数1，参数2)
            * 参数1：传递参数的位置
            * 参数2: 值
        7. 处理SQL语句,接受返回结果，prearedStatement.executeQuery()
        8. 处理结果
        9. 释放资源

    * 使用PreparedStatement对象
        * 防止SQL注入问题
        * 效率更高</code></pre><h2 id="抽取JDBC工具类"><a href="#抽取JDBC工具类" class="headerlink" title="抽取JDBC工具类"></a>抽取JDBC工具类</h2><pre><code>- JDBCUtils
* 目的：简化书写
* 分析：
    1. 获取连接
        * 不传递参数，并保证工具类的通用性
        * 解决：配置文件
            jdbc.properties
                url=...

            1. 创建Properties类
            Properties properties = new Properties();
            2. 加载properties文件
            properties.load(new FileReader(&quot;jdbc.properties&quot;));
            3. 获取配置
            url = properties.getProperty(&quot;url&quot;);
    2. 释放资源</code></pre><h2 id="登陆验证实例"><a href="#登陆验证实例" class="headerlink" title="登陆验证实例"></a>登陆验证实例</h2><pre><code>1. 需求
    * 通过键盘输入用户名和密码
    * 判断用户是否合法
        根据查询结果判断是否合法

2. 实现
    * 创建表，存储用户名和密码
        CREATE TABLE IF NOT EXISTS USER (
            id INT PRIMARY KEY AUTO_INCREMENT,
            NAME VARCHAR(32) NOT NULL,
            PASSWORD VARCHAR(32) NOT NULL
        );

    * 查询数据表，
        sql = &quot;select * from db where name = &apos;name&apos; and password = &apos;password&apos;&quot;
        如果存在数据，用户合法

3. 注意
    为了预防SQL注入，导致安全性问题，使用PreparedStatement类，使用预编译SQL,不使用静态拼接SQL,Statement类，效率更高而且更安全。</code></pre><h2 id="JDBC事务控制"><a href="#JDBC事务控制" class="headerlink" title="JDBC事务控制"></a>JDBC事务控制</h2><pre><code>1. 事务：一个包含多个步骤的业务操作，如果业务被事务管理，要么全部成功，要么全部失败

2. 操作
    1. 开启事务
    2. 提交事务
    3. 回滚事务

3. 使用Connection管理事务
    * 开启事务
        void setAutoCommit(boolean autoCommit) :参数为false,开启事务
        执行sql语句之前开启事务
    * 提交事务
        commit()
        SQL执行完毕时提交
    * 回滚事务
        rollback
        try catch中进行回滚，一旦发现异常，将数据回滚</code></pre><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：
    * 容器（集合），存放数据库连接的一个容器
    * 系统初始化后，容器被创建，会申请一些连接对象，在用户访问数据库时，从容器中获取连接对象，使用完毕归还容器资源

2. 优点：
    * 节约资源：访问时直接获取，不用重复申请资源
    * 用户访问高效：拿来即用

3. 实现：
    1. 标准接口：
        DataSourse javax.sql
        * 方法:
            * 获取连接：getConnnection()
            * 归还连接：如果Connection是从连接池获取的，调用connection.close()方法，不是关闭连接，而时归还连接

    2. 实现技术，由数据库厂商提供
        * C3P0: 数据库连接池技术
        * Druid: 

4. C3P0连接池技术
    * 步骤：
        1. 导入jar包，jdbc驱动和c3p0包
        2. 定义配置文件：
            * 名称：c3p0.properties 或者 c3p0-config.xml
            * 路径：src目录下
        3. 创建数据库连接池核心数据对象：ComboPoolDataSourse
        4. 获取连接对象：getConnection()

5. Druid连接池技术
    * 步骤：
        1. 导入jar包：druid-v.jar
        2. 定义配置文件：
            * properties形式
            * 可以叫任意名称，放在任意目录下
        3. 加载配置文件
            Properties properties = new Properties();
            InputStream is = DruidDemo08.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
            properties.load(is);
        3. 创建连接池对象，使用工厂类 DruidDataSourseFactory
        4. 获取连接对象

    * 定义工具类
        1. 定义工具类
        2. 提供静态代码块加载配置文件，初始化连接池对象
        3. 提供方法
            1. 获取连接方法，获取连接对象
            2. 释放资源
            3. 获取连接池对象</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装，提供了JDBCTemplate对象
* 步骤：
    1. 导入jar包
    2. 创建JDBCTemplate对象，依赖与数据源DataSourse
        JDBCTemplate template = new JDBCTemplate(ds)
    3. 调用方法完成CRUD的操作</code></pre>]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQL JDBC</title>
    <url>/2019/12/09/SQLjdbc/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>1. 基本概念
    Java DataBase Connectivity
    - java数据库连接，java操作数据库，使用同一套java代码操作不同的数据库
    - 本质：官方定义的操作所有关系型数据库的规则--接口，实现类由各个数据库厂商实现，提供数据库驱动jar包，我们可以使用这套接口（JDBC）编程，但真正执行的是驱动jar包中的实现类。
        Person接口   Worker类  Person p = new Worker();    p.eat();

2. 快速入门
    * 步骤：
        1. 导入驱动jar包
        2. 注册驱动
        3. 获取数据库的连接对象 Connection
        4. 定义SQL语句
        5. 获取执行SQL语句的对象 Statement = connection.statement()
        6. 处理SQL语句,接受返回结果 statememt.executeQuery(sql)
        7. 处理结果
        8. 释放资源

    * 代码：
        `
        //2.注册驱动
           Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);

           //3.获取数据库连接对象
        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/books?serverTimezone=UTC&quot;,&quot;uesrname&quot;,&quot;password&quot;);

        //4.定义SQL语句
        String sql = &quot;select * from admin&quot;;

        //5.获取执行SQL的对象
        Statement statement = connection.createStatement();

        //6.执行SQL
        boolean flag = statement.execute(sql);

        //7.处理
        System.out.println(flag);

        //8.释放资源
        statement.close();
        connection.close();
        `</code></pre><h2 id="对象详解"><a href="#对象详解" class="headerlink" title="对象详解"></a>对象详解</h2><pre><code>1. 详解各个对象
    1. DriverManager
        * 驱动管理对象
        * 功能：
            1. 注册驱动
                static void registerDriver(Driver driver):注册给定的驱动程序
                写代码：Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;)
                com.mysql.cj.jdbc.Driver,使用静态代码块，调用registerDriver方</code></pre><blockquote>
<pre><code>注册驱动:
 static {
      try {
            DriverManager.registerDriver(new Driver());
     } catch (SQLException var1) {
         throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);
     }
     }</code></pre></blockquote>
<pre><code>            PS：mysql5后的驱动jar包可以省略注册驱动的步骤

        2. 连接数据库
            * 方法：static Connection getConnection(String url, String user, String password)
            * 参数:
                * url:指定连接的路径
                    * 语法
                        jdbc:mysql://ip地址(域名)：端口号/数据库名称
                    * 例子
                        jdbc:mysql://localhost:3306/books?serverTimezone=UTC
                    * 细节
                        如果连接本机的mysql服务器，而且端口号3306，可以简写为jdbc:mysql:///数据库名称
                * user:
                    数据库用户名
                * password
                    密码

2. Connection
    * 数据库连接对象
    * 功能：
        1. 获取执行SQL的对象
            * Statement createStatement()
            * PreparedStatement preparedStatement()

        2. 管理事务
            * 开启事务
                void setAutoCommit(boolean autoCommit) :参数为false,开启事务
            * 提交事务
                commit()
            * 回滚事务
                rollback()

3. Statement
    * 执行SQL对象
    * 功能：
        1. 执行SQL语句
            * int executeUpdate(String sql):执行DML(增删改)语句，DDL语句，返回值：影响的行数，判断是否执行成功（&gt;0）
            * ResultSet executeQuery(String sql):执行查询语句

4. ResultSet
    * 结果集对象，封装查询结果
    * 功能：
        * boolean next():游标向前移动一行,并判断是否是最后一行，如果是，返回False
        * getType(参数)：获取数据,一次只能获取一列数据
            * Type：数据类型，int getInt()
            * 参数：
                1. int 列的编号，getInt(1)
                2. String 列名,getString(name)
        * 使用时：
            1. 游标向下移动
            2. 判断是否存在数据
            3. 获取数据
            代码：
                 while(resultSet.next()){
                    //获取数据
                 }

5. PreparedStatement
    * 执行SQL的对象
    * SQL注入问题：在拼接sql语句时，有一些特殊的关键字参于字符串的拼接，会造成安全性问题
        1. 输入用户随便，输入密码：a&apos;or&apos;a&apos;=&apos;a,条件恒为真，
        2. sql:select * from db where name and password,所有的用户名全都查询出来

    * 解决SQL注入问题：使用PreparedStatemmet类
    * 预编译SQL:参数使用 ？作为占位符
    * 步骤：
        1. 导入驱动jar包
        2. 注册驱动
        3. 获取数据库的连接对象 Connection
        4. 定义SQL语句
        5. 获取执行SQL语句的对象 PreparedStatement = connection.preparedStatement(sql)
            * 注意：sql使用?作为占位符， select * from user where name = ? and password = ?;
        6. 给？赋值
            * 方法：
            * setType(参数1，参数2)
            * 参数1：传递参数的位置
            * 参数2: 值
        7. 处理SQL语句,接受返回结果，prearedStatement.executeQuery()
        8. 处理结果
        9. 释放资源

    * 使用PreparedStatement对象
        * 防止SQL注入问题
        * 效率更高</code></pre><h2 id="抽取JDBC工具类"><a href="#抽取JDBC工具类" class="headerlink" title="抽取JDBC工具类"></a>抽取JDBC工具类</h2><pre><code>- JDBCUtils
* 目的：简化书写
* 分析：
    1. 获取连接
        * 不传递参数，并保证工具类的通用性
        * 解决：配置文件
            jdbc.properties
                url=...

            1. 创建Properties类
            Properties properties = new Properties();
            2. 加载properties文件
            properties.load(new FileReader(&quot;jdbc.properties&quot;));
            3. 获取配置
            url = properties.getProperty(&quot;url&quot;);
    2. 释放资源</code></pre><h2 id="登陆验证实例"><a href="#登陆验证实例" class="headerlink" title="登陆验证实例"></a>登陆验证实例</h2><pre><code>1. 需求
    * 通过键盘输入用户名和密码
    * 判断用户是否合法
        根据查询结果判断是否合法

2. 实现
    * 创建表，存储用户名和密码
        CREATE TABLE IF NOT EXISTS USER (
            id INT PRIMARY KEY AUTO_INCREMENT,
            NAME VARCHAR(32) NOT NULL,
            PASSWORD VARCHAR(32) NOT NULL
        );

    * 查询数据表，
        sql = &quot;select * from db where name = &apos;name&apos; and password = &apos;password&apos;&quot;
        如果存在数据，用户合法

3. 注意
    为了预防SQL注入，导致安全性问题，使用PreparedStatement类，使用预编译SQL,不使用静态拼接SQL,Statement类，效率更高而且更安全。</code></pre><h2 id="JDBC事务控制"><a href="#JDBC事务控制" class="headerlink" title="JDBC事务控制"></a>JDBC事务控制</h2><pre><code>1. 事务：一个包含多个步骤的业务操作，如果业务被事务管理，要么全部成功，要么全部失败

2. 操作
    1. 开启事务
    2. 提交事务
    3. 回滚事务

3. 使用Connection管理事务
    * 开启事务
        void setAutoCommit(boolean autoCommit) :参数为false,开启事务
        执行sql语句之前开启事务
    * 提交事务
        commit()
        SQL执行完毕时提交
    * 回滚事务
        rollback
        try catch中进行回滚，一旦发现异常，将数据回滚</code></pre><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：
    * 容器（集合），存放数据库连接的一个容器
    * 系统初始化后，容器被创建，会申请一些连接对象，在用户访问数据库时，从容器中获取连接对象，使用完毕归还容器资源

2. 优点：
    * 节约资源：访问时直接获取，不用重复申请资源
    * 用户访问高效：拿来即用

3. 实现：
    1. 标准接口：
        DataSourse javax.sql
        * 方法:
            * 获取连接：getConnnection()
            * 归还连接：如果Connection是从连接池获取的，调用connection.close()方法，不是关闭连接，而时归还连接

    2. 实现技术，由数据库厂商提供
        * C3P0: 数据库连接池技术
        * Druid: 

4. C3P0连接池技术
    * 步骤：
        1. 导入jar包，jdbc驱动和c3p0包
        2. 定义配置文件：
            * 名称：c3p0.properties 或者 c3p0-config.xml
            * 路径：src目录下
        3. 创建数据库连接池核心数据对象：ComboPoolDataSourse
        4. 获取连接对象：getConnection()

5. Druid连接池技术
    * 步骤：
        1. 导入jar包：druid-v.jar
        2. 定义配置文件：
            * properties形式
            * 可以叫任意名称，放在任意目录下
        3. 加载配置文件
            Properties properties = new Properties();
            InputStream is = DruidDemo08.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
            properties.load(is);
        3. 创建连接池对象，使用工厂类 DruidDataSourseFactory
        4. 获取连接对象

    * 定义工具类
        1. 定义工具类
        2. 提供静态代码块加载配置文件，初始化连接池对象
        3. 提供方法
            1. 获取连接方法，获取连接对象
            2. 释放资源
            3. 获取连接池对象</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装，提供了JDBCTemplate对象
* 步骤：
    1. 导入jar包
    2. 创建JDBCTemplate对象，依赖与数据源DataSourse
        JDBCTemplate template = new JDBCTemplate(ds)
    3. 调用方法完成CRUD的操作</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Inject</title>
    <url>/2020/05/09/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="SQL注入问题"><a href="#SQL注入问题" class="headerlink" title="SQL注入问题"></a>SQL注入问题</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>在拼接sql语句时，有一些特殊的SQL关键字参于字符串的拼接，导致SQL语句的逻辑发生变化，可能会造成安全性问题</code></pre><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><pre><code>1. 输入 a&apos;or&apos;a&apos;=&apos;a,条件改变
2. sql:select * from db where name and password = &apos;a&apos;or&apos;a&apos;=&apos;a&apos;,查询所有数据

原SQL语句拼接为: 

    String sql = &quot;select id from db where username=&apos;&quot;+username+&quot;&apos; and password=&apos;&quot;+password+&quot;&apos;&quot;;

用户输入的帐号密码分别为:

请输入您的帐号:
11111
请输入您的密码:
a&apos;or&apos;a&apos;=&apos;a
组成的SQL语句: 
select id from db where username=&apos;1111&apos; and password=a&apos;or&apos;a&apos;=&apos;a；</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><pre><code>使用预编译SQL语句,进行参数的传递

更改执行环境：Statement

使用新的环境: PreparedStatement

在通过连接对象，获取一个预编译的SQL环境(PreparedStatement)时, 需要传递一个SQL语句 ! 
在这个语句中 可以出现? , ? 表示准备填充的参数值!

使用步骤: 
    1. 通过连接对象, 获得一个预编译的SQL执行环境

        PreparedStatement state = conn.prepareStatement(sql);

        例如: 
            String sql = &quot;select id from db where username=? and password=?&quot;;

            PreparedStatement state = conn.prepareStatement(sql);    

    2. 向预编译参数列表中传递值: 

        预编译的SQL语句中可以包含【多个问号】, 每一个问号表示一个需要传递的值 
        我们通过PreparedStatement它的setXxx方法,来完成参数的传递
            传递参数时, 需要指定问号的索引, 问号的索引从1开始            

        例如:
            state.setString(1,username);
            state.setString(2,password);

    3. 执行语句:
            ResultSet result = state.executeQuery();</code></pre><h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><pre><code>填充预编译的参数: 
    * setXxx（问号索引,值）
        向预编译的SQL的?中传递值 
        参数1. 问号的索引,从1开始
        参数2. 填充到? 中的值

    * execute()
    * executeUpdate();
    * executeQuery();        </code></pre>]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Load</title>
    <url>/2020/05/09/SpringLoad/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code>在下载Spring时，碰到很多问题，在此记录下载流程，方便以后再次下载！</code></pre><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-搜索Spring官网-https-spring-io"><a href="#1-搜索Spring官网-https-spring-io" class="headerlink" title="1. 搜索Spring官网: https://spring.io/"></a>1. 搜索Spring官网: <a href="https://spring.io/" target="_blank" rel="noopener">https://spring.io/</a></h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_1.png" alt></p>
<h3 id="2-点击Projects"><a href="#2-点击Projects" class="headerlink" title="2. 点击Projects"></a>2. 点击Projects</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_2.png" alt></p>
<h3 id="3-点击Spring-Framework"><a href="#3-点击Spring-Framework" class="headerlink" title="3. 点击Spring Framework"></a>3. 点击Spring Framework</h3><h3 id="4-下拉界面，找到并点击-Spring-Framework-Artifacts"><a href="#4-下拉界面，找到并点击-Spring-Framework-Artifacts" class="headerlink" title="4. 下拉界面，找到并点击 Spring Framework Artifacts"></a>4. 下拉界面，找到并点击 Spring Framework Artifacts</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_3.png" alt></p>
<h3 id="5-找到并点击，http-repo-spring-io"><a href="#5-找到并点击，http-repo-spring-io" class="headerlink" title="5. 找到并点击，http://repo.spring.io"></a>5. 找到并点击，<a href="http://repo.spring.io" target="_blank" rel="noopener">http://repo.spring.io</a></h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_4.png" alt></p>
<h3 id="6-左边第二个图标，依次点击"><a href="#6-左边第二个图标，依次点击" class="headerlink" title="6.左边第二个图标，依次点击"></a>6.左边第二个图标，依次点击</h3><pre><code>libs-release-local ---&gt; org ---&gt; springframework ---&gt; spring</code></pre><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_5.png" alt><br><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_6.png" alt></p>
<h3 id="7-鼠标右键-Nature-Browser"><a href="#7-鼠标右键-Nature-Browser" class="headerlink" title="7.鼠标右键 Nature Browser"></a>7.鼠标右键 Nature Browser</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_7.png" alt></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2020/03/18/git/</url>
    <content><![CDATA[<h2 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h2><h3 id><a href="#" class="headerlink" title></a></h3><pre><code>1.什么是Git
    一种源代码管理工具（版本控制工具），方便对代码的管理

2.初始化Git仓库
    在放置代码的文件夹下，
    右键“git bash here”,输入命令&apos;git init&apos;,
    所有的文件放置在‘.git’文件夹下

3.配置身份信息
    声明当前的用户，“git config --global ”
    每次备份会将用户名和邮箱存储起来

    1.声明用户
        &apos;git config --global user.name &quot;用户名&quot;&apos;

    2.声明邮箱
        &apos;git config --global user.mail &quot;邮箱名&quot;&apos;
        邮箱不要求为现实邮箱，只要符合邮箱格式

4.将文件放置到Git
    自动将文件备份到隐藏文件夹‘.git’

    1.将代码添加到‘.git’仓库中（门口）
        &apos;git add &quot;文件路径名&quot;&apos;

    2.代码提交到‘.git’仓库中（房间）
        &apos;git commit -m “对文件的说明”&apos;
            -m message:必须要有文件说明

5.工作区 暂存区 版本库
    工作区：正在使用的文件夹
    暂存区：第一次添加的文件
    版本库：提交的源代码版本

6.查看当前状态
    &apos;git status&apos;
    文件是否放入版本库

7.批处理文件
    git add ./     :当前文件夹的所有修改过的内容放入暂存区
    git commit --all -m &quot;&quot;    :将所有的文件放入版本库

8.查看提交记录（日志）
    &apos;git log&apos; 显示提交的用户和时间
    简化提交日志
    &apos;git log --oneline&apos; :将日志简化为一条记录

9.恢复代码
    &apos;git reset --hard Head~0&apos;    ：回退到上次代码提交时的状态

10.根据版本号来进行回退
    &apos;git reset --hard &quot;版本号&quot;&apos;    ：将代码回退到某一次的提交时的状态

11.查看版本切换日志
    &apos;git reflog&apos;

12.创建分支，合并分支
    master:主分支

    1.创建分支
        &apos;git branch &quot;分支名&quot;&apos; 创建分支
        与master分支内容一样

    2.切换分支
        &apos;git checkout &quot;分支名&quot;&apos;    

    3.合并分支
        &apos;git merge &quot;分支名&quot;&apos;,当前分支与指定分支的合并

    4.查看分支
        &apos;git branch&apos;

13.手动合并分支
    合并后删除不需要的文件，再次将其进行提交

14.将代码提交到Github服务器上
    &apos;git push &quot;地址&quot; master&apos;
    exp:git push https://github.com/print3306/test007.git master

15.将代码从Github上下载
    &apos;git pull &quot;地址&quot; master&apos;
    exp:git pull https://github.com/print3306/test007.git master

    注意：在下载之前必须初始化一个仓库，pull会对数据进行合并

16.对数据的clone
    &apos;git clone &quot;地址&quot;&apos;
    远程仓库数据的复制，如果多次执行会覆盖本地内容

17.通过SSH来上传代码
    公钥和私钥：通过两者之间的联系验证身份
    生成公钥和私钥
        ssh-keygen -t rsa -C &quot;邮箱&quot;
        生成的公钥添加到Github的SSH上

18.本地和远程文件的版本不一样
    先将服务器上的数据下载下来，在本地修改，解决冲突后，再将最新版上传至服务器

19.简化push和pull
    增加远程变量，在当前的项目目录有效，变量代替地址
    git remote add &quot;变量名&quot; &quot;地址&quot;

    上传：git push &quot;变量名&quot; -u master
        本地当前分支和远程指定分支进行相关联,
        下一次只需要写上git push进行上传

    下载：git pull &quot;变量名&quot; -u master</code></pre>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/2020/05/15/mybatis/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><pre><code>1. 什么是框架（Framework）？
    系统中可重用的代码部分，包括一组构件以及构件之间的交互逻辑
    软件开发中的一种解决方案，不同的框架解决不同的问题
    框架封装了很多技术细节，使用者可以方便实现功能，提高开发效率

2. 三层架构
    * 表现层：
        展示数据
    * 业务层：
        处理业务需求
    * 持久层：
        数据库交互

3. 持久层技术解决问题和方案
    1. 问题
        数据库的连接和访问，数据查询效率，操作繁琐，不能将注意力聚焦到SQL处理上
        JDBC,Spring JDBCTemplate，传统的数据库连接方法，一组解决数据库连接的规范

    2. MyBatis概述
        * 基于Java的持久层框架
        * 内部封装了jdbc的细节,使用者只需要关注SQL语句，不用关心加载驱动，数据库连接，Statement对象等过程
        * 使用ORM(Object Relation Mapping)思想实现了结果集的封装
            PS: ORM
                数据库表和实体类以及实体类的属性对应起来，可以操作实体类实现操作数据表
                    user表        User类
                    id          userId</code></pre><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="1-MyBatis入门"><a href="#1-MyBatis入门" class="headerlink" title="1. MyBatis入门"></a>1. MyBatis入门</h2><pre><code>1. 环境搭建
    1. new --&gt; project --&gt; maven 设置名称，导入坐标pom.xml
    2. 创建实体类和Dao的接口:Dao(data access object 数据访问对象)
    3. 创建mybatis的主配置文件
        * SqlMapConfig.xml ：&lt;property &gt; 标签名称需要匹配，ps:username 不是 user
    4. 创建映射配置文件
        * UserDao.xml :&lt;mapper namespace=&quot;UserDao的路径&quot;&gt;

    注意事项：
        1. 创建UserDao.xml UserDao.java，mybatis中将持久层的操作接口名称和映射文件也叫做：Mapper
            UserDao 和 UserMapper相同
        2. 在idea创建目录时，和包的创建不同
            包在创建时，com.mybatis_base_01.dao 三层结构
            目录：com.mybatis_base_01.dao 一级目录
        3. 映射配置文件位置必须和dao接口的包结构相同
        4. 映射配置文件的mapper标签的namespace属性取值为dao接口的全限定类名
        5. 映射配置文件的操作设置，id取值必须时dao接口的方法名

        在实现3，4，5后，dao的实现类由mybatis实现

2. 使用案例
    1. 配置文件
        * InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
    2. 创建SqlSessionFactory对象
        * SqlSessionFacotryBulider builder = new SqlSessionFacotryBuilder();
        * SqlSessionFacotry facotry = builder.build(in);
    3. 创建SqlSession对象
        * SqlSession session = facotry.openSession();
    4. 创建UserDao代理对象
        * UserDao userDao = session.getMapper(UserDao.class);
    5. 使用UserDao代理对象执行操作
        * List&lt;User&gt; userDao = userDao.findAll();
    6. 释放资源
        * session.close();
        * in.close();

3. 简单分析
    1. 配置文件
        Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); 
        * 使用类加载器，只能读取类路径的配置文件
        * 使用ServletContext对象的getRealPath()

    2. 创建SqlSessionFactory工厂
        * 使用了创建者模式：SqlSessionFacotryBuilder builder 构造者 builder.build(in) 建立工厂
        * 使用了工厂模式：SqlSessionFactory 降低类之间的依赖关系

    3. 创建SqlSeccion对象
    4. 创建接口实现类

4. 使用注解开发MyBatis
    1. 将UserDao.xml移除，在Dao接口的方法上使用@Select()注解，并且指定sql语句
    2. 在SqlMapConfig.xml中的Mapper配置时，使用class属性指定Dao接口的全限定类名

5. 自定义MyBatis分析
    Mybatis在使用代理Dao对象实现增删改查做了什么事？
        1. 创建代理对象
        2. 调用selectList()方法</code></pre><blockquote>
<pre><code>&lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis_test&quot;/&gt;
&lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
&lt;property name=&quot;password&quot; value=&quot;root2019&quot;/&gt;</code></pre></blockquote>
<pre><code>连接数据库的语句，可以产生Connnection对象</code></pre><blockquote>
<mappers>
<mapper resource="com/mybatis_base_03/dao/UserDao.xml">
</mapper></mappers>
</blockquote>
<blockquote>
<pre><code>&lt;mapper namespace=&quot;com.mybatis_base_03.dao.UserDao&quot;&gt; 
&lt;!--配置查询所有--&gt;
&lt;select id=&quot;findAll&quot; resultType=&quot;com.mybatis_base_03.domain.User&quot;&gt;
   select * from user
&lt;/select&gt;</code></pre></blockquote>
<pre><code>映射配置信息 -&gt; 全限定类名，以及执行的SQL语句。
解析.xml配置文件 -&gt; 有了上面的三个信息
    1. 根据配置数据库的语句，可以创建Connection对象
        注册驱动，创建连接对象
    2. 获取预处理对象PreparedStatement
        获取SQL语句
    3. 对结果进行封装
        根据实体类的全限定类名</code></pre><h3 id><a href="#" class="headerlink" title></a></h3><pre><code>6.自定义MyBatis中涉及的实体类和接口
    1. class Resources
    2. class SqlSessionBuilder
    3. interface SqlSessionfacotry
    4. interface SqlSession
    这个过程完成了两件事：
        创建接口代理对象，
        实现查询语句

MyBatis将JDBC的功能进行封装，形成功能调用。SqlMapConfig.xml,daoInterfaceClass.xml里面包含对数据库的连接与查询的语句以及返回的结果类型。

SqlMapConfig.xml中的&lt;property&gt;标签包含数据库的连接对象，&lt;mappers/mapper&gt;包含接口的文件位置。
daoInterfaceClass.xml包含数据库语句，返回数据类的全限定类名，以及方法的namespace(根据查查询语句以及namespace确定方法的唯一性)。

根据这两个配置文件，可以通过对.xml文件的解析，获取相应的配置文件信息，由此构建代理对象，g根据返回数据的类型获取数据，实现整个的查询过程。</code></pre><h2 id="MyBatis的CRUD"><a href="#MyBatis的CRUD" class="headerlink" title="MyBatis的CRUD"></a>MyBatis的CRUD</h2><h3 id="MyBatis的配置文件"><a href="#MyBatis的配置文件" class="headerlink" title="MyBatis的配置文件"></a>MyBatis的配置文件</h3><pre><code>1. pom.xml的配置信息
    * 坐标的导入
        1.mybatis的坐标导入
        2.mysql的驱动坐标导入
        3.log4j的坐标导入
            log4j.properties配置文件放在资源目录下
        4.junit单元测试的坐标导入

2. SqlMapConfig.xml的配置
    1. &lt;environments&gt;:配置数据库
        1. 数据库连接
        2. 数据库的事务类型
        3. 数据库的数据源
        4. 数据库的连接（driver url username password）</code></pre><blockquote>
<pre><code>&lt;!--配置环境--&gt;
&lt;environments default=&quot;mysql&quot;&gt;
 &lt;!--配置mysql的环境--&gt;
 &lt;environment id=&quot;mysql&quot;&gt;
  &lt;!--配置事务--&gt;
  &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
  &lt;!--配置连接池--&gt;
  &lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;!--mysql的连接信息--&gt;
    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis_test&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root2019&quot;/&gt;
  &lt;/dataSource&gt;
 &lt;/environment&gt;
&lt;/environments&gt;</code></pre></blockquote>
<pre><code>2. &lt;mappers&gt;:配置dao的数据接口
    1. recource:表示配置方式为.xml
    2. class:表示配置方式为注解
    &lt;!--配置映射文件的位置--&gt;</code></pre><blockquote>
<pre><code>&lt;mappers&gt;
    &lt;mapper resource=&quot;com/mybatis_base_04_crud/dao/IUserDao.xml&quot;&gt;&lt;/mapper&gt;
  &lt;/mappers&gt;</code></pre></blockquote>
<pre><code>3. DaoInterface.xml
    1.&lt;mapper&gt;中的namespase 与 &lt;select&gt;中的id构成方法的唯一标识
    2.&lt;select&gt;中的文本内容为要执行的语句
    3.&lt;select&gt;中的 resultType 返回值类型</code></pre><blockquote>
<pre><code>&lt;!--namespace 接口--&gt;
&lt;mapper namespace=&quot;com.mybatis_base_04_crud.dao.IUserDao&quot;&gt;

 &lt;select id=&quot;finaAll&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
       select * from user
  &lt;/select&gt;
&lt;/mapper&gt;</code></pre></blockquote>
<h3 id="MyBatis的数据操作"><a href="#MyBatis的数据操作" class="headerlink" title="MyBatis的数据操作"></a>MyBatis的数据操作</h3><h4 id="保存数据-Insert"><a href="#保存数据-Insert" class="headerlink" title="保存数据(Insert)"></a>保存数据(Insert)</h4><pre><code>1. Dao接口的方法
    在IUserDao.java中添加saveUser方法
2. daoInterace.xml中的配置
    在&lt;mapper&gt;中增加&lt;insert&gt;标签，选择参数化类型，对于数据填充，采用#{}方式</code></pre><blockquote>
<pre><code>&lt;!-- 保存用户 --&gt;
  &lt;!--参数类型 parameterType--&gt;
  &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
        insert into user(username,address,sex,birthday) value(#{username},#{address},#{sex},#{birthday})
 &lt;/insert&gt;
实体类的属性定义与数据库中的列名一致,setter和getter方法自动生成，可以直接使用属性名称来传递参数，否则可以使用.getUsername()来传递参数。    </code></pre></blockquote>
<pre><code>3. 调用方法
    在生成数据库的代理对象后，直接调用save方法就可以        

4. 注意事项
    在使用方法后，需要对数据进行提交，默认自动提交关闭，需要手动打开自动提交
    session.commit();</code></pre><h5 id="保存数据的同时返回id"><a href="#保存数据的同时返回id" class="headerlink" title="保存数据的同时返回id"></a>保存数据的同时返回id</h5><pre><code>1.daoInterface.xml
    在原本的&lt;insert&gt;标签内，增加&lt;selectKey&gt;标签</code></pre><blockquote>
<pre><code>&lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;
  select last_insert_id();
&lt;/selectKey&gt;
在执行结束之后，会将id返回到user的id属性之中
keyProperty=&quot;id&quot; 实体类的属性
keyColumn=&quot;id&quot; 数据表中的列名</code></pre></blockquote>
<h4 id="更新数据-Update"><a href="#更新数据-Update" class="headerlink" title="更新数据(Update)"></a>更新数据(Update)</h4><pre><code>1. Dao接口的方法
    void saveUser(User user);
2. daoInterace.xml</code></pre><blockquote>
<pre><code>&lt;!-- 更新 --&gt;
  &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
    update user set username = #{username},address=#{address},sex=#{sex},birthday=#{birthday} where id=#{id}
  &lt;/update&gt;</code></pre></blockquote>
<h4 id="删除数据-Delete"><a href="#删除数据-Delete" class="headerlink" title="删除数据(Delete)"></a>删除数据(Delete)</h4><pre><code>1. Dao接口的方法
    void deleteUser(Integer userId);
2. daoInterface.xml</code></pre><blockquote>
<pre><code>&lt;!-- 删除数据 --&gt;
  &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
    delete from user where id=#{uid}
  &lt;/delete&gt;</code></pre></blockquote>
<pre><code>3. 注意事项
    删除数据中只有一个元素，#{}中的元素只是起到一个占位符的作用，与名称无关</code></pre><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><h5 id="根据用户id"><a href="#根据用户id" class="headerlink" title="根据用户id"></a>根据用户id</h5><pre><code>1. dao接口的方法
    User finaById(Integer id);
2. daoInterface.xml
    需要传入参数，以及返回值类型</code></pre><blockquote>
<pre><code>   &lt;!-- 根据id查询一个 --&gt;
&lt;select id=&quot;findById&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
   select * from user where id=#{id}
&lt;/select&gt;</code></pre></blockquote>
<h5 id="根据用户name"><a href="#根据用户name" class="headerlink" title="根据用户name"></a>根据用户name</h5><pre><code>1. dao接口的方法
    List&lt;User&gt; findByName(String name);
2. daoInterface.xml</code></pre><blockquote>
<pre><code>&lt;!-- 根据名称模糊查询 --&gt;
&lt;select id=&quot;findByName&quot; parameterType=&quot;string&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
 select * from user where username like #{name}</code></pre>  
</blockquote>
<pre><code>3. 注意事项
    &apos;#{}中没有模糊查询的 “-” “%” 在调用传参数时，需要给出“%王%”,查询语句为预处理SQL语句
    &apos;%${value}%&apos;,参数为“王”，查询语句为拼接字符串</code></pre><h3 id="MyBatis中的参数-parameterType"><a href="#MyBatis中的参数-parameterType" class="headerlink" title="MyBatis中的参数(parameterType)"></a>MyBatis中的参数(parameterType)</h3><h4 id="参数的类型-parameterType"><a href="#参数的类型-parameterType" class="headerlink" title="参数的类型(parameterType)"></a>参数的类型(parameterType)</h4><pre><code>1. 简单数据类型
    int String ...

2. 传递pojo对象
    pojo对象：
        POJO简单理解为不包含业务逻辑的单纯用来存储数据的java类（实际就是普通JavaBean)

    OGNL表达式：</code></pre><p><em>Object Graphic Navigation Language</em><br>        (对象图形导航语言)</p>
<pre><code>    通过对象的取值方法来获取数据，在写法上，将get给忽略了
    比如：获取用户的名称
        类中的写法：user.getUsername()
        OGNL表达式：user.username()
    mybatis中可以直接使用username,不用书写user.
        因为在parameterType中已经提供属性所在的类

3. 传递pojo包装对象
    参数为被封装的数据，查询条件是综合的查询条件</code></pre><blockquote>
<pre><code>&lt;!-- 根据queryVo查询数据 --&gt;
&lt;select id=&quot;findByQueryVo&quot; parameterType=&quot;com.mybatis_base_04_crud.domain.QueryVo&quot; resultType=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
  select * from user where username like #{user.username}
&lt;/select&gt;</code></pre></blockquote>
<pre><code>QueryVo内部封装user对象，在参数传递时#{}，中的参数为 QueryVo.user.username,可以写为 user.username,代表参数为QueryVo中数据对象user中的属性username</code></pre><h4 id="结果集的封装-resultType"><a href="#结果集的封装-resultType" class="headerlink" title="结果集的封装(resultType)"></a>结果集的封装(resultType)</h4><pre><code>实体类的属性名与数据库的列名不相同？
    1. 给数据库中的列名起别名
        将所有查询的数据字段的名称别名改为实体类对应的属性名称
        书写更为复杂，但是查询到的数据在数据库端被处理，效率更高
    select id as uesrId,username as userName, address as userAddress, sex as userSex,birthday as userBirthday from user;

    2. 使用resultMap进行字段对应</code></pre><blockquote>
<pre><code>&lt;!-- 配置 查询结果的列名和属性名一致 --&gt;
&lt;resultMap id=&quot;userMap&quot; type=&quot;com.mybatis_base_04_crud.domain.User&quot;&gt;
    &lt;!-- 主键字段的一致 --&gt;
    &lt;id property=&quot;userId&quot; column=&quot;id&quot;/&gt;
    &lt;!-- 非主键字段的一致 --&gt;
    &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
    &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt;
    &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;
    &lt;result property=&quot;userBirthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;
&lt;/resultMap&gt;

&lt;!--select id as uesrId,username as userName, address as userAddress, sex as userSex,birthday as userBirthday from user;--&gt;
&lt;select id=&quot;finaAll&quot; resultMap=&quot;userMap&quot;&gt;
    select * from user;
&lt;/select&gt;</code></pre></blockquote>
<pre><code>resultMap中的id为映射标记，返回值必须更改为resultMap=&quot;userMap&quot;，进行绑定
id 数据库中的主键字段数据绑定
result 非主键字段的数据绑定
property 实体类中的属性名称
column 数据库中的字段名称

    3. 两种方法的不同    
        直接使用别名，运行效率更高，但编写效率较低
        使用resultMap，运行效率低，但是编写效率高</code></pre><h3 id="MyBatis实现DAO开发"><a href="#MyBatis实现DAO开发" class="headerlink" title="MyBatis实现DAO开发"></a>MyBatis实现DAO开发</h3><h4 id="使用Dao的实现类"><a href="#使用Dao的实现类" class="headerlink" title="使用Dao的实现类"></a>使用Dao的实现类</h4><pre><code>1. 创建IUserDaoImpl.java
2. 在实现类中实现方法
    创建Sqlsession对象，在方法中调用相应的查询语句</code></pre><blockquote>
<pre><code>@Override
public List&lt;UserfinaAll() {
    //生成SqlSession对象
    SqlSession session = factory.openSession();
    //调用session的selectList方法，实现查询列表
    List&lt;Userusers = session.selectList(&quot;com.mybatis_base_04_DAO.dao.IUserDao.finaAll&quot;);
    //方法中的参数 能获取到信息的key namespace + methodName
    //释放资源
    session.close();
    return users;
}    </code></pre></blockquote>
<pre><code>* MyBatis实际上使用代理Dao的方式，将创建Dao实现类的过程给隐藏，用户无法感知到创建Dao实现类的过程。
* 自己使用Dao实现类实际上就是创建SqlSession对象，通过调用session.selectList()方法查询数据。
* 方法中的参数：（namaspace+methodName , 外部传入的参数）</code></pre><h3 id="执行过程分析"><a href="#执行过程分析" class="headerlink" title="执行过程分析"></a>执行过程分析</h3><h4 id="dao实现类的执行过程分析"><a href="#dao实现类的执行过程分析" class="headerlink" title="dao实现类的执行过程分析"></a>dao实现类的执行过程分析</h4><pre><code>1. selectList


2. insert update delete
    insert update delete最终调用的都是update方法

3. selectOne
    selectOne内部调用selectList方法，返回值为列表的第一个元素</code></pre><h4 id="代理Dao实现类的执行过程分析"><a href="#代理Dao实现类的执行过程分析" class="headerlink" title="代理Dao实现类的执行过程分析"></a>代理Dao实现类的执行过程分析</h4><h3 id="SqlMapConfig-xml中的标签属性"><a href="#SqlMapConfig-xml中的标签属性" class="headerlink" title="SqlMapConfig.xml中的标签属性"></a>SqlMapConfig.xml中的标签属性</h3><pre><code>1. &lt;properties&gt;标签
    * 配置properties 可以在标签内部配置数据库的连接信息，也可以引用外部配置文件信息
    * 使用&lt;properties&gt;标签，在环境的数据源中的对应数据使用 ${名称} 可以引用

    resource属性：
          用于指定配置文件的位置，按照类路径的写法来写，必须存放于类路径下

    url属性：
          要求按照url的写法来书写地址
          url Uniform Resource Locator 统一资源定位符
          写法：
            http://localhost:8080/mybatisserver/demo1Serelet
            协议 主机 端口 URI
           URI Uniform Resource Identifier 统一资源标识符 应用中唯一定位的资源</code></pre><blockquote>
<pre><code>&lt;properties url=&quot;file:///D:/2017217796/java_program/MyCode/mybatis_base_04_crud/src/main/resources/jdbcConfig.properties&quot;&gt;

&lt;/properties&gt;

&lt;!--mysql的连接信息--&gt;
&lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
&lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
&lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
&lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;        </code></pre></blockquote>
<pre><code>2. &lt;typeAliases&gt;标签
    1). &lt;typeAlias&gt;标签
        * typeAlias配置别名，只能配置domain中的实体类
        * type指定全限定属性名 alias指定别名 不在区分大小写</code></pre><blockquote>
<pre><code>&lt;typeAlias type=&quot;com.mybatis_base_04_crud.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;</code></pre></blockquote>
<pre><code>2). &lt;package&gt;标签
    * 用于指定要配置别名的包，当指定后，该包中的所有实体类都会被注册别名，且类名就是别名，不再区分大小写</code></pre><blockquote>
<pre><code>&lt;package name=&quot;com.mybatis_base_04_crud.domain&quot;/&gt;</code></pre></blockquote>
<pre><code>3. &lt;mappers&gt;标签
    * package指定接口所在的包，一但指定，就不需要写resource和class以及mapper</code></pre><blockquote>
<pre><code>&lt;package name=&quot;com.mybatis_base_04_crud.dao&quot;/&gt;</code></pre></blockquote>
<h2 id="MyBatis的连接池"><a href="#MyBatis的连接池" class="headerlink" title="MyBatis的连接池"></a>MyBatis的连接池</h2><h3 id="连接池的使用与分析"><a href="#连接池的使用与分析" class="headerlink" title="连接池的使用与分析"></a>连接池的使用与分析</h3><h4 id="连接池的含义"><a href="#连接池的含义" class="headerlink" title="连接池的含义"></a>连接池的含义</h4><pre><code>连接池是用于存储连接的一个容器
容器其实就是一个集合对象，该集合必须是线程安全的，不能两个线程拿到同一个连接
该集合必须实现队列的特性：先进先出

使用连接池可以减少获取连接的时间</code></pre><h4 id="MyBatis的连接池-1"><a href="#MyBatis的连接池-1" class="headerlink" title="MyBatis的连接池"></a>MyBatis的连接池</h4><pre><code>1. SqlMqpConfig.xml中的datasource标签，type属性表示使用何种连接池方式
    type的取值：
        POOLED : 采用传统的javax.sql.DataSource规范的连接池
        UNPOOLED ：采用传统的获取连接的方式，虽然也实现了javax.sql.DataSource接口，但是没有池的概念，每次使用都获取新的连接
        JNDI ：采用服务器提供的JNDI实现，获取DataSource对象，不同的服务器拿到的对象不一样，如果不是web或者maven的war工程，不能使用
        使用tomcat服务器，使用的连接池dbcp连接池</code></pre><blockquote>
<pre><code>&lt;dataSource type=&quot;POOLED&quot;&gt;
    &lt;!--mysql的连接信息--&gt;
    &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
&lt;/dataSource&gt;</code></pre></blockquote>
<p><img src="/2020/05/15/mybatis/datasource_0.png" alt="POOLED"><br><img src="/2020/05/15/mybatis/pooled_datasource_1.png" alt="POOLED"><br><img src="/2020/05/15/mybatis/pooled_datasource_2.png" alt="POOLED"></p>
<h4 id="补充JNDI数据库连接池"><a href="#补充JNDI数据库连接池" class="headerlink" title="补充JNDI数据库连接池"></a>补充JNDI数据库连接池</h4><h4 id="MyBatis中的事务"><a href="#MyBatis中的事务" class="headerlink" title="MyBatis中的事务"></a>MyBatis中的事务</h4><pre><code>1. MyBatis通过commit以及rollback来进行事务控制
2. 一般不设置自动提交，因为一旦多个事务提交，难以控制</code></pre><h2 id="MyBatis基于XML配置的动态SQL语句使用"><a href="#MyBatis基于XML配置的动态SQL语句使用" class="headerlink" title="MyBatis基于XML配置的动态SQL语句使用"></a>MyBatis基于XML配置的动态SQL语句使用</h2><h4 id="if-标签"><a href="#if-标签" class="headerlink" title="if 标签"></a>if 标签</h4><pre><code>* 根据条件来进行查询，此时条件可能不全，有可能缺少某些项，会根据条件具体生成查询语句
SQL语句中的名称不区分大小写，但是查询条件需要根据实体类相关，一般来说实体类的属性名与数据库的列名相同。</code></pre><blockquote>
<pre><code>&lt;!-- 根据条件查询 --&gt;
&lt;select id=&quot;findUserByCondition&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;
 select * from user where 1=1
 &lt;if test=&quot;userName != null&quot;&gt;
   and username like #{userName}
 &lt;/if&gt;</code></pre>   
</blockquote>
<pre><code>* test：判断输入的条件，如果条件满足，查询条件会包含if标签内部的语句
* 可以多个if标签一起使用
* 条件同时满足的时候使用 and ，可以在数据库语句中使用</code></pre><h4 id="where标签"><a href="#where标签" class="headerlink" title="where标签"></a>where标签</h4><pre><code>* 使用where标签将if标签包裹起来，在查询条件中就不用书写 where 1 = 1</code></pre><blockquote>
<pre><code>  &lt;!-- 根据条件查询 --&gt;
&lt;select id=&quot;findUserByCondition&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;
select * from user
&lt;where&gt;
  &lt;if test=&quot;userName != null&quot;&gt;
    and username like #{userName}
  &lt;/if&gt;
  &lt;if test=&quot;userSex != null&quot;&gt;
    and sex = #{userSex}
  &lt;/if&gt;
&lt;/where&gt;</code></pre>  
</blockquote>
<h4 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h4><blockquote>
<pre><code>&lt;!-- 根据QueryVo中的ids进行查询，集合尽心查询列表 --&gt;
&lt;select id=&quot;findUserInIds&quot; parameterType=&quot;queryvo&quot; resultMap=&quot;userMap&quot;&gt;
select * from user
&lt;where&gt;
  &lt;if test=&quot;ids != null and ids.size() 0&quot;&gt;
    &lt;foreach collection=&quot;ids&quot; open=&quot;and id in (&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;
      #{id}
    &lt;/foreach&gt;
  &lt;/if&gt;
&lt;/where&gt;</code></pre>  
</blockquote>
<pre><code>* 查询满足条件的集合元素:select * from user where id in (?)
* foreach:
* collection:代表要遍历的集合元素
* open:语句的开始部分
* close:语句的结束部分
* item:遍历的每个元素，生成的变量名
* separtor:分割符

其中&lt;foreach&gt;中的语句 #{}中的名称，需要与item一致

在进行多个数据一起插入的时候，可以使用foreach进行 values()的赋值</code></pre><h4 id="sql标签"><a href="#sql标签" class="headerlink" title="sql标签"></a>sql标签</h4><pre><code>* 抽取重复的SQL语句，避免重复书写语句
* 然后在语句中使用&lt;include&gt;来引用抽取的语句
* 如果后面还有需要拼接的条件，不能 书写分号</code></pre><blockquote>
<pre><code>&lt;!-- 抽取重复的语句 --&gt;
&lt;sql id=&quot;defaultUser&quot;&gt;
  select * from user
&lt;/sql&gt;

&lt;!--select id as uesrId,username as userName, address as userAddress, sex as userSex,birthday as userBirthday from user;--&gt;
&lt;select id=&quot;finaAll&quot; resultMap=&quot;userMap&quot;&gt;
  &lt;include refid=&quot;defaultUser&quot;&gt;&lt;/include&gt;
&lt;/select&gt;</code></pre></blockquote>
<h2 id="Mybatis的多表操作"><a href="#Mybatis的多表操作" class="headerlink" title="Mybatis的多表操作"></a>Mybatis的多表操作</h2><pre><code>表之间的关系：
    一对一
    多对一
    一对多
    多对多

举例：
    用户对于订单：一对多
    订单对于用户：多对一
        一个用户可能有多个订单
        多个订单属于一个用户

    一对一：
        一个人只能有一身份证号
        一个身份证号属于一个人

    多对多：
        一个学生被多个老师交过
        一个老师交过多个学生

在MyBatis中，认为订单与用户之间的关系，每拿出一个订单，只能属于一个用户
所以，所有的多对一，全都为一对一

案例：
    使用用户与账户之间的关系
        一个用户可以有多个账户
        一个账户只能属于一个用户(多个账户也是一个用户)

步骤：
    1. 建立两张表：用户表 账户表
        用户与账户具有关系：使用外键
    2. 建立两个实体类：用户实体 账户实体
    3. 建立两个配置文件
        用户配置文件
        账户配置文件
    4. 实现配置
        当查询用户时，可以出现账户信息
        查询账户时，可以显示出对应的用户信息</code></pre><h3 id="一对一查询的结果封装《association》"><a href="#一对一查询的结果封装《association》" class="headerlink" title="一对一查询的结果封装《association》"></a>一对一查询的结果封装《association》</h3><pre><code>1. 通过书写子类来进行配置查询
    * 建立新的结果集的封装类，将查询到的结果进行封装
    * 每次查询不同的数据需要书写不同的字类，太过于麻烦

2. 建立实体类之间的关系来进行数据封装
    * 主表与从表之间存在联系，主表实体和从表实体之间也存在联系
    * 从表包含主表实体的引用
    * 据此，创建resultMap，进行结果封装
    * 使用 association 进行一对一的结果封装</code></pre><blockquote>
<pre><code> &lt;!-- 定义封装account和user的resultMap --&gt;
&lt;resultMap id=&quot;accountuser&quot; type=&quot;account&quot;&gt;
&lt;id property=&quot;id&quot; column=&quot;aid&quot;&gt;&lt;/id&gt;
&lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;
&lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt;
  &lt;!-- 一对一的关系映射:配置封装user的信息 --&gt;
  &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
  &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
  &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;
  &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;
  &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt;
&lt;/association&gt;</code></pre>  
</blockquote>
<pre><code>在association中，如果不写javaType,报错：空指针异常
javatype:将数据封装到实体对象中</code></pre><h3 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询<collection></collection></h3><pre><code>* 一对多连接，主表的实体类需要包含从表实体类的集合引用，在配置文件中，使用collection标签来封装数据集合</code></pre><p><img src="/2020/05/15/mybatis/one2manyxml.png" alt="主体的配置文件"><br>        数据查询结果<br><img src="/2020/05/15/mybatis/one2many.png" alt="主体的配置文件"></p>
<pre><code>* 数据查询结果显示，数据为一对多情况，MyBatis将属于同一个用户的账户，封装到了账户的集合之中</code></pre><h3 id="多对多查询"><a href="#多对多查询" class="headerlink" title="多对多查询"></a>多对多查询</h3><pre><code>示例：用户与角色之间的关系
    一个用户可以拥有多个角色
    一个角色可以赋予多个用户

    典型的多对多

    1. 建立两张表：用户表 角色表
    2. 两者具有多对多的关系
        建立中间表，主键为两者的联合主键，中间表中是外键
    3. 建立两个实体类
        让用户和角色实体类能体现出多对多的关系
        两者分别包含对象集合引用
    4. 建立两个配置文件
    5. 实现配置
        查询用户时，同时得到包含的角色信息
        查询角色时，同时得到包含的用户信息</code></pre><p><img src="/2020/05/15/mybatis/many2many.png" alt="many2many的配置文件"><br><img src="/2020/05/15/mybatis/many2many_1.png" alt="many2many的配置文件"></p>
<pre><code>* 一个用户包含的所有角色信息，因为要包括所有的用户，不能使用内连接，应该使用外连接，在使用user_role表的时候，有可能列名相同,需要别名，在写配置resultMap时，注意别名</code></pre><h2 id="MyBatis延迟加载"><a href="#MyBatis延迟加载" class="headerlink" title="MyBatis延迟加载"></a>MyBatis延迟加载</h2><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><pre><code>在一对多的数据查询的时候，一个用户，100个账户
    在查询用户信息的时候，要不要将账户的信息查询出来
    在查询账户信息的时候，要不要将用户的信息查询出来

    在查询账户的时侯，用户下的账户的信息应该是，什么时候使用，什么时候查询
    在查询用户的时候，账户下的用户的信息应该是，随着账户的信息一起查询出来

1. 延迟加载
    在真正使用数据的时侯，才将数据查询出来；不使用的时候，不进行查询

2. 立即加载
    无论数据是否使用，一旦调用方法，马上进行查询

3. 使用时机
    一对一，多对一：立即加载（一般需要立刻看到信息）
    一对多，多对多：延迟加载（一般不需要立刻看到信息）</code></pre><h4 id="实现延迟加载"><a href="#实现延迟加载" class="headerlink" title="实现延迟加载"></a>实现延迟加载</h4><pre><code>1. 在一对一的时候实现延迟加载
    * 更改查询语句
        在此时，不需要将所有的数据全都查询出来，只需要将所有的账户查询出来，不需要带着用户信息
    * 修改结果集
        由于不需要用户信息，结果集的封装可以删除
    * 修改级联查询语句
        在&lt;association&gt;语句中，增加select属性，指明查询的唯一标识</code></pre><blockquote>
<pre><code>&lt;!-- 定义封装account和user的resultMap --&gt;
&lt;resultMap id=&quot;accountuserMap&quot; type=&quot;account&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
  &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;
  &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt;

&lt;!-- 一对一的关系映射:配置封装user的信息,
select 查询用户的唯一标识,在接口文件中，根据id查询用户的方法
column 用户根据id查询时，所需要的参数的值，此地将查询出来的uid作为参数传入
 --&gt;
&lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot; select=&quot;com.mybatis_base_06_lazyload.dao.IUserDao.findById&quot;&gt;

&lt;/association&gt;</code></pre>  
</blockquote>
<pre><code>* 修改SqlMapConfig.xml,打开延迟加载开关
    打开延迟加载的开关，关闭立即加载的开关</code></pre><blockquote>
<pre><code>&lt;!-- 配置参数。延迟加载 --&gt;
&lt;settings&gt;
  &lt;!-- 开启延迟加载的全局开关 --&gt;
  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;!-- 立即加载 --&gt;
  &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;
&lt;/settings&gt;</code></pre></blockquote>
<p><img src="/2020/05/15/mybatis/lazyload1.png" alt="一对一的延迟加载"></p>
<pre><code>2. 什么是按需？
    1. 在进行单独数据查询，或者是数据遍历时，才会将所有数据显示出来
    2. 根据用户的id，或者其他的要求进行数据查询

3. 一对多的数据查询    
    与一对一的延迟加载相似,查询语句，结果集，以及账户实体类中的按照id查询</code></pre><p><img src="/2020/05/15/mybatis/lazyload2.png" alt></p>
<h2 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h2><h3 id="缓存基本概念"><a href="#缓存基本概念" class="headerlink" title="缓存基本概念"></a>缓存基本概念</h3><pre><code>存在内存中的临时数据

1. 为什么使用缓存？
    减少和数据库的交互次数，提高执行效率

2. 什么数据能使用缓存，什么数据不能使用？
    1. 适用于缓存：
        经常查询并且不经常改变的
        数据的正确性对最终结果影响不大的

    2. 不适用缓存：
        经常改变的数据
        数据的正确性对最终结果影响很大的
            （商品的库存，银行的汇率，股市的股价）</code></pre><h3 id="MyBatis的缓存-1"><a href="#MyBatis的缓存-1" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h3><pre><code>1. 一级缓存：
    它是指Mybatis中的SqlSession对象的缓存
    当我们执行查询的时候，查询的结果会同时存入到SqlSession为我们提供的一块区域内
    该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去SqlSession中查询是否存在，有的话，直接拿来使用
    当SqlSession对象消失时，一级缓存同时消失

    1. 缓存同步问题
        如果调用session的insert update delete close() commit() clearcache()方法，会自动放弃当前的一级缓存，直接从数据库中查询数据

2. 二级缓存
    由MyBatis中SqlSessionFactory对象的缓存，同一个SqlSessionFactory对象创建的SqlSession对象共享其缓存。

    1. 二级缓存的使用步骤
        1. 让MyBatis支持二级缓存 SqlMapConfig.xml配置
        2. 让当前的映射文件支持二级缓存，IUserDao.xml
        3. 让当前的操作支持二级缓存，select标签</code></pre><h2 id="MyBatis注解开发"><a href="#MyBatis注解开发" class="headerlink" title="MyBatis注解开发"></a>MyBatis注解开发</h2><h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><pre><code>1. 在SqlMapConfig.xml中的mapper中，使用class,导入接口资源文件
2. 在接口类上，使用注解进行开发
3. 其余步骤与使用xml开发一致

注意：
    如果在与接口类的相同路径下的资源路径下，建立IUserDao.xml文件，不管有没有使用.xml文件，都会产生错误。</code></pre><h3 id="名称不一致"><a href="#名称不一致" class="headerlink" title="名称不一致"></a>名称不一致</h3><pre><code>1. 实体类名与数据库列名不一致
    1. 使用别名，将数据库中查询出来的数据进行设置别名
    2. 使用@Results注解，进行配置</code></pre><blockquote>
<pre><code>/**
 * 查询所有,获取所有的账户信息
 */
@Select(&quot;select * from user&quot;)
@Results(id= &quot;userMap&quot;,value = {
        @Result(id=true,column = &quot;id&quot;,property = &quot;userId&quot;),
        @Result(column = &quot;username&quot;,property = &quot;userName&quot;),
        @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;),
        @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;),
        @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;)
})
List&lt;UserfindAll();

@Select(&quot;select * from user where id=#{id}&quot;)
@ResultMap(value = {&quot;userMap&quot;})
User findById(Integer id);</code></pre></blockquote>
<pre><code>    * @Results中id是唯一标识，定义之后，可以在别的位置使用
        values代表结果对应的封装数组

    * @Result中，id代表是否为唯一标识，默认为false
        column:数据库列名
        property:实体类属性名

2. 定义了@Results注解
    想在别的地方使用，使用@resultMap注解
            @ResultMap(value = {&quot;userMap&quot;}) //完整写法
    values已经定义好的结果集封装</code></pre><h3 id="一对多查询注解版"><a href="#一对多查询注解版" class="headerlink" title="一对多查询注解版"></a>一对多查询注解版</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><pre><code>结果集的封装，主要关注@Result中的属性：one many
一对一：使用one 
一对多：使用many</code></pre><p><img src="/2020/05/15/mybatis/anno_one2many.png" alt="注解配置"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL 5.7.29</title>
    <url>/2020/06/18/mysql57/</url>
    <content><![CDATA[<h2 id="下载安装MySQL-5-7-29版本"><a href="#下载安装MySQL-5-7-29版本" class="headerlink" title="下载安装MySQL-5.7.29版本"></a>下载安装MySQL-5.7.29版本</h2><h3 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1.下载安装包"></a>1.下载安装包</h3><pre><code>官网下载安装包，离线安装方式</code></pre><p><img src="/2020/06/18/mysql57/0.png" alt></p>
<h3 id="2-my-ini"><a href="#2-my-ini" class="headerlink" title="2.my.ini"></a>2.my.ini</h3><pre><code>下载的安装包解压后，安装目录如果没有*my.ini*文件，新建该文件，内容：
其中，文件安装和data目录可以自定义</code></pre><p><img src="/2020/06/18/mysql57/5.png" alt></p>
<h3 id="3-创建服务"><a href="#3-创建服务" class="headerlink" title="3.创建服务"></a>3.创建服务</h3><p><img src="/2020/06/18/mysql57/6.png" alt></p>
<pre><code>mysql57为服务名</code></pre><h3 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4.初始化"></a>4.初始化</h3><p><code>mysqld --initialize</code></p>
<h3 id="5-启动服务"><a href="#5-启动服务" class="headerlink" title="5.启动服务"></a>5.启动服务</h3><p><code>net start mysql</code></p>
<h3 id="6-连接数据库"><a href="#6-连接数据库" class="headerlink" title="6.连接数据库"></a>6.连接数据库</h3><ul>
<li>临时密码：在***.err下<br><img src="/2020/06/18/mysql57/4.png" alt><br><img src="/2020/06/18/mysql57/9.png" alt><br><img src="/2020/06/18/mysql57/11.png" alt></li>
</ul>
<h3 id="7-更改密码"><a href="#7-更改密码" class="headerlink" title="7.更改密码"></a>7.更改密码</h3><p><img src="/2020/06/18/mysql57/12.png" alt></p>
<h3 id="8-断开连接"><a href="#8-断开连接" class="headerlink" title="8.断开连接"></a>8.断开连接</h3><p><code>exit</code></p>
<h3 id="9-退出服务"><a href="#9-退出服务" class="headerlink" title="9.退出服务"></a>9.退出服务</h3><p><img src="/2020/06/18/mysql57/13.png" alt></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="1-存在data文件夹"><a href="#1-存在data文件夹" class="headerlink" title="1.存在data文件夹"></a>1.存在data文件夹</h3><ul>
<li>删除原本data，初始化命令自动生成新的data文件夹</li>
<li>data文件夹自己手动创建可能报错，最好还是由系统自动创建<br><img src="/2020/06/18/mysql57/7.png" alt></li>
</ul>
<h3 id="2-无法启动服务"><a href="#2-无法启动服务" class="headerlink" title="2.无法启动服务"></a>2.无法启动服务</h3><p><img src="/2020/06/18/mysql57/1.png" alt><br><img src="/2020/06/18/mysql57/8.png" alt></p>
<pre><code>更改注册表信息</code></pre><p><img src="/2020/06/18/mysql57/2.png" alt><br><img src="/2020/06/18/mysql57/3.png" alt></p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Reflection（java反射机制）</title>
    <url>/2020/09/10/reflection/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><pre><code>1. 反射（reflection）：动态语言的关键
    * 反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性和方法
    * 加载完类之后，在堆内存的方法区产生一个Class对象（一个类只有一个Class对象），这个对象就包含完整的类的信息，可以通过这个Class对象看到类的结构，通过对象看到类的结构的过程，叫做反射

2. 使用反射的应用
    * 在运行时判断一个对象所属的类
    * 在运行时构造任意一个类的对象
    * 在运行时获取泛型的信息
    * 在运行时获取私有属性，私有方法
    * 在运行时父类的信息，父类上的泛型
    * 在运行时获取接口
    * 在运行时获取所在包，注解
    * 。。。

3. 相干的API
    * java.lang.Class
    * java.lang.reflect.Method    //方法
    * java.lang.reflect.Filed    //成员变量    
    * java.lang.reflect.Constructor        //构造器

4. 反射和封装性
    * 通过直接new对象，或反射的方式都可以调用公共的结构，具体使用位置？
        1. 建议直接使用new方式，编译的时候可以确定创建哪个对象
        2. 编译的时候无法确定创建哪个对象，根据传入的参数进行对象的创建，使用反射的方式：
            反射机制具有动态性

    * 有了反射机制，与对象的封装性，如何看待两种技术？
        1. 不矛盾
        2. 封装性：将对象的属性和方法进行权限限定，暴露出的接口表现用户可以使用的方法，建议用户使用的方法和属性，不建议使用私有方法[建不建议]
        3. 反射：可以使用的方法，用户强制使用私有的属性和方法[能不能]</code></pre><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><h3 id="java-lang-Class的理解"><a href="#java-lang-Class的理解" class="headerlink" title="java.lang.Class的理解"></a>java.lang.Class的理解</h3><pre><code>1. 类的加载过程
    程序在经过javac.exe命令之后，会生成一个或多个字节码文件（.class）文件，
    接着使用java.exe命令对某个字节码文件进行解释运行。相当于将字节码文件加载到内存，此过程叫做类的加载。
    加载到内存中的类，我们称为运行时类，此运行时类，就作为Class类的一个实例。

2. 换句话说，Class的实例就是一个运行时类的对象
3. 加载到内存的运行时类，会缓存一定的时间。在此时间之内，可以通过不同的方法获取运行时类</code></pre><h3 id="获取Class的实例方式"><a href="#获取Class的实例方式" class="headerlink" title="获取Class的实例方式"></a>获取Class的实例方式</h3><pre><code>1. 方式一：通过运行时类的.class属性获取Class实例
    Class clazz1 = Person.class();
    System.Out.Println(clazz1);

2. 方式二：通过运行时类的对象的.getClass()方法获取实例
    Person person = new Person();
    Class clazz2 = person.getClass();

3. 方式三：通过Class的.forName(&quot;运行时类的全限定类名&quot;)获取实例
    Class clazz3 = Class.forName(&quot;全限定类名&quot;)；

4. 方式四：通过类的加载器获取实例
     ClassLoader classLoader = Reflection.class.getClassLoader();
    Class clazz4 = classLoader.loadClass(&quot;全限定类名&quot;);

上述的四种Class实例的获取方式，方式一和方式二，都与具体的实现类绑定，在开发中一般使用Class类的.forName()方法获取Class实例对象。</code></pre><h3 id="Class对象的范围"><a href="#Class对象的范围" class="headerlink" title="Class对象的范围"></a>Class对象的范围</h3><pre><code>1. class:各种类对象
2. interface
3. []:数组 只要数组的类型和维度相同，就是一个Class对象
4. enum:枚举
5. annotation
6. 基本数据类型
7. void</code></pre><h2 id="ClassLoader-类加载器"><a href="#ClassLoader-类加载器" class="headerlink" title="ClassLoader(类加载器)"></a>ClassLoader(类加载器)</h2><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><pre><code>1. 加载：将类的字节码文件读入内存，并为其创建一个java.lang.Class对象，实现类的加载过程
2. 链接：静态变量初始化为默认值
3. 初始化：JVM使用构造器方法完成类变量的赋值和静态代码块的语句顺序合并产生数据</code></pre><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><pre><code>1. 将.class加载到内存，将这些静态数据转换成方法区运行时的数据结构，生成Class对象，作为方法区中类数据的访问入口
2. 类缓存：一旦某个类被加载到类加载器，会在类加载器中维持一段时间，JVM的垃圾回收机制可以回收Class对象

3. 分类
    * 引导类加载器：C++编写的，主要加载Java的核心类库，用户无法获取到该加载器
    * 扩展类加载器：加载java/lib/ect中的jar包
    * 系统类加载器：加载当前程序中的类</code></pre><blockquote>
<pre><code>//1.对于自定义类，使用系统级类加载器
ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
System.out.println(classLoader);

//2.调用系统类加载器的getParent()，获取扩展类加载器
ClassLoader classLoader1 = classLoader.getParent();
System.out.println(classLoader1);

//3.调用扩展类加载器getParent()，无法获取引导类加载器
//引导类加载器加载java的核心类库
ClassLoader classLoader2 = classLoader1.getParent();
System.out.println(classLoader2);</code></pre></blockquote>
<h2 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h2><h3 id="反射创建运行时类的对象"><a href="#反射创建运行时类的对象" class="headerlink" title="反射创建运行时类的对象"></a>反射创建运行时类的对象</h3><pre><code>1. 使用.newInstance()方法创建运行时类的对象
    newInstance:
        * 调用此方法，创建运行时类的方法
        * 内部调用运行时类的空参构造器
        * 如果没有空参构造器，产生异常

2. 满足两个条件
    * 运行时类必须提供空参的构造器
    * 访问权限不能为private,通常设置为public</code></pre><h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><pre><code>修饰符 返回类型 变量名；

1. 获取所有属性
    1. 获取当前运行时类的所有属性（getDeclaredFileds）
        * 不考虑权限问题，不会获取父类的属性</code></pre><blockquote>
<pre><code>Field[] fields1 = clazz.getDeclaredFields();
for(Field field:fields1){
    System.out.println(field);
}</code></pre></blockquote>
<pre><code>2. 获取属性包含父类的属性（getFileds）
    * 获取当前运行时类以及父类的所有权限为public的属性</code></pre><blockquote>
<pre><code>Field[] fields = clazz.getFields();
for(Field field:fields){
    System.out.println(field);
}        </code></pre></blockquote>
<pre><code>2. 获取属性的修饰符,数据类型，变量名</code></pre><blockquote>
<pre><code>Class clazz = Person.class;

//获取当前运行时类的所有属性
Field[] fields = clazz.getDeclaredFields();

for(Field field:fields){
//修饰符
//权限被分配了 整型数据,使用Modifier的方法可以翻译为字符串
int modifiers = field.getModifiers();
System.out.print(Modifier.toString(modifiers)+&quot;\t&quot;);
//数据类型
Class&lt;?type = field.getType();
System.out.print(type.getName()+&quot;\t&quot;);
//属性名
System.out.println(field.getName());
}</code></pre></blockquote>
<p><img src="/2020/09/10/reflection/fields.png" alt="运行时类的属性"></p>
<h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><pre><code>1. 获取当前运行类声明的所有方法</code></pre><blockquote>
<pre><code>Method[] methods = clazz.getMethods();
for(Method method:methods){
    System.out.println(method);
}</code></pre></blockquote>
<pre><code>2. 获取当前运行时类以及所有父类的声明为public权限的方法</code></pre><blockquote>
<pre><code>Method[] declaredMethods = clazz.getDeclaredMethods();
for(Method method:declaredMethods){
    System.out.println(method);
}</code></pre></blockquote>
<pre><code>3. 获取方法的修饰符，数据类型，方法名
    * @Anno
    * 权限修饰符 返回值类型 方法名(形参列表) Throws Exception{}

    Method[] declaredMethods = clazz.getDeclaredMethods();
    for(Method method:declaredMethods){
        System.out.println(&quot;-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&quot;);
        //1.注解获取
        Annotation[] methodAnnotations = method.getAnnotations();
        for(Annotation anno:methodAnnotations){
            System.out.print(anno+&quot;\t&quot;);
        }

        //2.权限修饰符
        System.out.print(Modifier.toString(method.getModifiers())+&quot;\t&quot;);
        //3.返回值类型
        System.out.print(method.getReturnType()+&quot;\t&quot;);
        //4.方法名
        System.out.print(method.getName());
        System.out.print(&quot;(&quot;);
        //5.形参列表参数
        Class[] parameterTypes = method.getParameterTypes();
        if(parameterTypes.length 0){
            for(int i = 0;i &lt; parameterTypes.length;i++){
                if(i == parameterTypes.length-1){
                    System.out.print(parameterTypes[i].getName()+&quot; args_&quot;+i);
                    break;
                }
                System.out.print(parameterTypes[i].getName()+&quot; args_&quot;+i+&quot; , &quot;);
            }
        }
        System.out.print(&quot;)&quot;);
        //6.获取抛出的异常
        Class[] exceptionTypes = method.getExceptionTypes();
        if(exceptionTypes.length 0){
            System.out.print(&quot; throws &quot;);
            for(int i = 0;i &lt; exceptionTypes.length;i++){
                if(i == exceptionTypes.length-1){
                    System.out.print(exceptionTypes[i].getName());
                    break;
                }
                System.out.print(exceptionTypes[i].getName()+&quot; , &quot;);
            }
        }
        System.out.println(&quot;{&quot;+&quot;\n&quot;+&quot;}&quot;);
    }</code></pre><h3 id="获取构造器的结构"><a href="#获取构造器的结构" class="headerlink" title="获取构造器的结构"></a>获取构造器的结构</h3><pre><code>1. 当前运行时类的所有的构造器</code></pre><blockquote>
<pre><code>Constructor&lt;?&gt;[] constructors = clazz.getConstructors();
for(Constructor c:constructors){
    System.out.println(c);
}</code></pre></blockquote>
<pre><code>2. 当前运行时类的所有public的构造器</code></pre><blockquote>
<pre><code>Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();
for(Constructor c:constructors){
    System.out.println(c);
}</code></pre></blockquote>
<h3 id="获取运行时类的父类"><a href="#获取运行时类的父类" class="headerlink" title="获取运行时类的父类"></a>获取运行时类的父类</h3><pre><code>1. getSuperClass():获取父类
2. getGenericSuperClass()：获取带有泛型的父类</code></pre><h2 id="调用运行时类的指定结构（方法和属性）"><a href="#调用运行时类的指定结构（方法和属性）" class="headerlink" title="调用运行时类的指定结构（方法和属性）"></a>调用运行时类的指定结构（方法和属性）</h2><pre><code>1. 获取指定的属性
    方法：
        getFiled():
            属性声明必须为public
        getDeclaredFiled()
            可以访问，但是如果想要访问私有属性，必须显式
            &lt;属性名&gt;.setAccessible(true);                

    1. 步骤
        * 获取Class对象
        * 创建Class对象的实例
        * 获取指定的属性
        * set方法
            * set(obj,value):obj：指明设置哪个对象的属性 value:设置的值
        * get方法
            * get(obj):obj：指明获取那个对象的属性

    2. 实例
        Class clazz = Person.class;
        Person p = (Person)clazz.newInstance();
        Filed filed = clazz.getDeclaredFiled(&quot;age&quot;);
        filed.setAccessible(true);
        filed.set(p,&quot;11111&quot;);

2. 获取指定的方法
    方法：
        getDeclaredMethod(name,param): 参数1：获取的方法的名称，参数2：获取的方法的形参列表
            可以访问，但是如果想要访问私有属性，必须显式
            &lt;方法名&gt;.setAccessible(true);

        &lt;方法名&gt;.invoke(obj,value):参数1:方法的调用者，参数2(可变形参)：赋值的实参
            invoke()方法的返回值为类中调用方法的返回值，
                如果调用的方法没有返回值，那么返回值为null

    1. 实例</code></pre><blockquote>
<pre><code>//1.获取指定的方法名
Method method = clazz.getDeclaredMethod(&quot;compareTo&quot;, String.class);
//2.确定当前方法是可以访问的
method.setAccessible(true);
//3.调用方法
method.invoke(p,&quot;HHHHH&quot;);   //p.show(&quot;HHHHH&quot;)</code></pre></blockquote>
<pre><code>2. 调用静态方法
    invoke(null)
    invoke(Person.class)</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2020/09/19/servlet/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="两种架构"><a href="#两种架构" class="headerlink" title="两种架构"></a>两种架构</h3><pre><code>1. C/S架构和B/S架构
    C/S：Client/Server，客户端和服务器
        * 必须在客户端安装特定软件
        * 图形显示效果好，但是在服务器的软件和功能升级的时候，客户端也必须一起升级

    B/S: Brower/Server，浏览器和服务器
        * 无需安装客户端，任何浏览器都可以进行访问
        * 涉及到升级的，只需要升级服务器就可以了
        * 需要使用HTTP协议</code></pre><h3 id="服务器简介"><a href="#服务器简介" class="headerlink" title="服务器简介"></a>服务器简介</h3><pre><code>1. 什么是web？
    Web（World Wide Web）称为万维网，简单理解就是网站，表示internet主机上供外界访问的资源。
    资源分类：
        * 静态资源：Web页面中供人们浏览的数据始终是不变的。（HTML,CSS）
        * 动态资源：Web页面中人们浏览的数据是根据程序产生的，不同的时间，甚至不同的设备访问看到的内容是不同的。（JSP,Servlet）

2. 什么是Web服务器？
    Web服务器是运行以及发布Web应用的一个容器，只有将开发的Web项目放置到该容器中，才能使网络中的用户通过浏览器访问。

3. 常见服务器
    * 开源：
        1. Tomcat,主流的服务器之一
        2. jetty,淘宝的使用
        3. resin,效率最高的
        用法相同，只有开启和关闭服务器的命令上有差别

4. Tomcat服务器：
    * Apache软件基金会的Jakarta的一个核心项目，免费开源，支持JSP和servlet规范。
    * 技术先进，性能稳定，比较主流的Web服务器

    1. 下载安装

    2. Tomcat的目录结构
        1. bin: 二进制可执行文件
        2. conf:
            * server.xml,Tomcat服务器的配置信息，修改端口号，字符编码等
            * web.xml，项目部署描述文件
        3. lib: Tomcat的类库，jar包，服务器运行需要的jar包
        4. logs: 日志文件
        5. temp: 临时文件，Tomcat停止后可以删除
        6. webapps: 所有部署的项目，每个文件夹都是一个项目，ROOT是一个特殊的项目，在没有写地址栏时，对应的就是ROOT项目。
        7. work: 运行生成的文件，最终运行的文件都在这里

    3. Tomcat的启动
        * 在安装目录下的bin,双击startup.bat,显示毫秒数，启动成功
        * 在浏览器内输入，http://localhost:8080,出现页面，则显示成功

    4. 停止Tomcat
        双击shutdown.bat即可关闭

    5. 修改默认端口号
        在conf文件夹的内部，打开server.xml,找到&lt;connector&gt;标签，可以修改默认端口号
        修改后，重启Tomcat可以使用修改后的端口

    6. 项目部署的访问静态资源
        Tomcat是Web服务器，项目存在于webapps内部，通过特定的URL访问

        * 创建项目
            在webapps中建立文件夹，myapp
                - 创建WEB—INF，存放项目的核心内容
                    * 创建.classes文件夹，存放.class文件
                    * 创建lib,存放jar文件
                    * 创建web.xml，项目配置文件
                - 静态资源，与WEB—INF同级目录

        * URL访问资源
            在浏览器输入：http://localhost:8080/myapp/hello.html,可以访问到资源

    7. Tomcat的响应流程
        一旦用户访问，服务器会到webapps查找对应的资源文件，找到之后，回响应用户请求，显示对应的资源文件


    8. Tomcat的常见错误
        * Tomcat闪退
            JAVA_HOME配置是否有问题

        * 404
            服务器访问资源不存在，产生404</code></pre><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="Servlet的基础概念"><a href="#Servlet的基础概念" class="headerlink" title="Servlet的基础概念"></a>Servlet的基础概念</h3><pre><code>1. 含义
    * Server Applet的简称，是服务器端的程序（代码，功能实现），可交互式的处理客户端发送到服务器的请求，并完成响应操作。
    * 动态网页技术

2. 作用
    * 接收客户端发送的请求，并完成相应的操作
    * 动态生成网页
    * 将包含操作结果的网页响应给客户端</code></pre><h3 id="Servlet开发步骤"><a href="#Servlet开发步骤" class="headerlink" title="Servlet开发步骤"></a>Servlet开发步骤</h3><pre><code>1. 搭建开发环境
    将Servlet相关的jar包(lib/servlet-api.jar)导入classpath中

2. 编写Servlet的实现类
    * 实现javax.servlet.Servlet接口
    * 重写方法
    * 在service()核心编写语句

3. 将编译生成的.class文件放在WEB-INF/classes文件下
4. 修改web.xml的配置信息</code></pre><blockquote>
</blockquote>
<pre><code>&lt;servlet&gt;
&lt;!-- 为指定的class起别名 --&gt;
  &lt;servlet-name&gt;my&lt;/servlet-name&gt;
  &lt;servlet-class&gt;MyServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;!-- 访问资源的映射。使用/来访问MyServlet资源 --&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;my&lt;/servlet-name&gt;
  &lt;!-- 访问路径，浏览器的访问路径 --&gt;
  &lt;url-patten&gt;/&lt;/url-patten&gt;
&lt;/servlet-mapping&gt;

url-patten:配置的内容就是浏览器地址栏输入的URL项目名称后资源的内容

5. 错误
    500 ：服务器端错误</code></pre><h3 id="使用IDEA开发部署Servlet"><a href="#使用IDEA开发部署Servlet" class="headerlink" title="使用IDEA开发部署Servlet"></a>使用IDEA开发部署Servlet</h3><pre><code>1. 步骤
    * 创建项目，选择Java EE 7，并勾选Web Application
    * 输入项目名称和保存位置，点击Finsh，完成项目创建

2. 文件目录结构
    * .idea: 项目配置文件
    * src:存放Java代码
    * web : 存放静态资源
        WEB-INF:项目配置文件，classes和jar文件
            web.xml:
        index.jsp:动态页面

3. 使用方式
    * 导入外部jar包，servlet-api.jar
    * 重写实现类实现Servlet接口
    * 将访问路径进行绑定，使用servlet 和 servlet-mapping进行路径绑定
    * 开启服务，进行结果查看

4. IDEA集成Tomcat服务器
    * File -&gt; Setting -&gt; ApplicatioServices -&gt; + ,导入Tomcat的解压缩位置
    * 点击Edit Configurations,将项目放置到Deployment中
    * 开启Tomcat

5. 手动导入第三方jar包
    * 在web目录下，WEB-INF建立lib文件夹，将需要导入的jar包复制，然后点击lib目录，使用右键，Add As Librarys

6. 导出war包
    * 项目完成后，可以打包成war包，将其放在Tomcat的webapps目录下，一旦开启服务器，可以自动解压，实现项目部署。
    * 步骤：
        1. Project Structure -&gt; Artifacts -&gt; + -&gt; Web Application:Archive -&gt; For 
        2. 构建项目，bulid -&gt; bulid Artifacts
        3. 会在项目的out文件夹下生成，war包，将该包复制到webapps中，在再次开启服务器时，会将该项目解压，部署

7. 热部署
    在不进行服务器重启的前提现，进行数据的更新
    整个项目从新部署，包括从新打上.war 文件。会清空session ，释放内存。

    * war包，项目最终完成，将其放在服务器的文件目录下，可以实现启动服务器的同时部署项目
    * IDEA的开发工具集成Tomcat,编译项目时，生成的文件会放置在out文件夹中，再次刷新浏览器，会得到最新的信息</code></pre><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><pre><code>1. 含义
    超文本传输协议（HyperText Transfer Protocol），是互联网的一种网络协议
    基于请求与响应模式的，无状态的，应用层的协议，运行于TCP协议之上

2. 特点    
    * 由于是基于请求和响应的，可以支持浏览器/服务器模式
    * 简单快速：
        客户端只向服务器发送请求方法和路径，服务器就可以发送响应数据，通信速度很快，请求的方法有GET,POST
    * 灵活：可以传输不同类型的数据
    * 无连接的：每次TCP连接只处理一个请求或多个，服务器处理完客户端的请求之后，会断开连接，可以减少开销
    * 无状态的：HTTP协议对于事务没有记忆能力

3. HTTP通信流程
    1. 客户端与服务器建立TCP连接（三次握手）
    2. 客户端发送请求
    3. 服务器接受请求，并响应
    4. 客户端与服务器关闭连接（四次挥手）

4. 请求报文
    当浏览器向服务器发出请求时，向服务器传递一个数据块，就是请求报文
    * 请求行 请求方法/地址 URI协议/版本
    * 请求头 Request Header：可以接受的数据，语言，端口号，以及当前浏览器信息    
    * 空行
    * 请求正文    

5. 响应报文
    当服务器响应浏览器的请求，向浏览器传递一个数据块，就是响应报文
    * 状态行 
    * 响应头 Respone Header
    * 空行
    * 响应正文    

6. 常见状态码</code></pre><table>
<thead>
<tr>
<th align="center">状态编码</th>
<th align="center">状态描述</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">OK</td>
<td align="center">客户端请求成功</td>
</tr>
<tr>
<td align="center">302</td>
<td align="center">Found</td>
<td align="center">临时重定向</td>
</tr>
<tr>
<td align="center">403</td>
<td align="center">Forbidden</td>
<td align="center">服务器收到请求，但是拒绝提供服务，在正文中给原因</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">Not Found</td>
<td align="center">请求的资源不存在</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">Internal Server Error</td>
<td align="center">服务器错误，无法完成请求</td>
</tr>
</tbody></table>
<h2 id="Servlet深入"><a href="#Servlet深入" class="headerlink" title="Servlet深入"></a>Servlet深入</h2><h3 id="Servlet核心接口和类"><a href="#Servlet核心接口和类" class="headerlink" title="Servlet核心接口和类"></a>Servlet核心接口和类</h3><pre><code>1. Servlet的实现类
    * 通过实现Servlet接口创建Servlet类
    * 继承GenericServlet类
    * 继承HttpServlet类

2.1 Servlet接口
    Servlet是Servlet API的最重要的接口，所有的Servlet都会与该接口相关联，或是直接实现该接口，或是间接继承该接口的实现类

    接口中的方法：
    void init()
    ServletConfig getServletConfig()
    void service(ServletRequest request,ServletRespone respone)
    String getServletInfo()
    void destroy()

2.2 GenericServlet抽象类
    提供了生命周期方法init和destroy的实现方法，我们只需要实现service方法就可以
    实现了Servlet接口，重写了除了service()之外的所有方法
    一旦我们继承了该抽象类，只需要重写该方法就行

2.3 HttpServlet抽象类
    具体处理HTTP协议服务器端程序，继承了GenericServlet抽象类，重写了service()方法，针对HTTP协议的抽象类
    doGet,doPost,doPut,doDelete等方法</code></pre><h3 id="Servlet的创建方式"><a href="#Servlet的创建方式" class="headerlink" title="Servlet的创建方式"></a>Servlet的创建方式</h3><pre><code>1. 实现Servlet的接口</code></pre><blockquote>
</blockquote>
<pre><code>public class MyServlet implements Servlet { 
@Override
public void init(ServletConfig servletConfig) throws ServletException {

}

@Override
public ServletConfig getServletConfig() {
    return null;
}

@Override
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    System.out.println(new Date());
}

@Override
public String getServletInfo() {
    return null;
}

@Override
public void destroy() {

}</code></pre><p>}</p>
<pre><code>2. 继承HttpServlet抽象类（推荐）</code></pre><blockquote>
<pre><code>可以重写doGet,doPost，对访问进行修改
public class MyServlet3 extends HttpServlet {
    可以重写Http访问有关的方法
    doGet,doPost
}</code></pre></blockquote>
<pre><code>3. 常见错误
    1. 404:未找到资源
        * 地址书写错误
        * 地址没有问题，将IDEA的out目录删除，然后重新运行
    2. servlet地址重复
        * both mapped to the url-patten which is not permitted
    3. servlet配置地址错误</code></pre><h3 id="Servlet的配置方式"><a href="#Servlet的配置方式" class="headerlink" title="Servlet的配置方式"></a>Servlet的配置方式</h3><pre><code>1. 使用web.xml（2.5之前）</code></pre><blockquote>
<pre><code>&lt;!-- 建立访问映射 --&gt;
  &lt;servlet&gt;
    &lt;!-- 名称 --&gt;
    &lt;servlet-name&gt;servlet&lt;/servlet-name&gt;
    &lt;!-- 全限定类名 --&gt;
    &lt;servlet-class&gt;com.servlet_02_start.servlet.MyServlet&lt;/servlet-class&gt;
    &lt;!-- 启动时加载 --&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/start&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;</code></pre></blockquote>
<pre><code>url-patten的匹配规则：</code></pre><table>
<thead>
<tr>
<th align="center">含义</th>
<th align="center">具体</th>
<th align="center">触发时机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">精确匹配</td>
<td align="center">/具体的名称</td>
<td align="center">只有url路径是具体的名称的时候才会出发Servlet</td>
</tr>
<tr>
<td align="center">后缀匹配</td>
<td align="center">*.xxx</td>
<td align="center">只要是以xxx结尾的就匹配</td>
</tr>
<tr>
<td align="center">通配匹配符</td>
<td align="center">/*</td>
<td align="center">匹配所有的请求,包括服务器的所有资源</td>
</tr>
<tr>
<td align="center">通配匹配符</td>
<td align="center">/</td>
<td align="center">匹配所有的请求,包括服务器的所有资源,不包括.jsp</td>
</tr>
<tr>
<td align="center">&gt;   <strong>通配符的匹配并不影响精确匹配的结果</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>load-on-startup标签
    * 元素标记容器是否在web应用启动的时候加载servlet
    * 值必须是整数，值越小，优先级越高，加载的时机越早，表示在初始化时被加载的顺序
    * 如果不写或者是负数，表示在servlet被使用的时候加载
    * 如果值相同，则按照顺序加载servlet,0优先级最高

2. 使用注解配置（Servlet3.0之后）
    类名之上添加，不用在.xml中配置
    @WebServlet注解
        属性：
            * name:servlet的名称，可以不写
            * value:配置url路径，可以配置多个
            * urlPattens:配置url路径，与value作用相同，但不能同时使用
            * loadOnStartup:表示配置创建servlet的时间，默认-1，表示在访问的时候创建

注解和web.xml之间没有冲突</code></pre><h2 id="Servlet应用"><a href="#Servlet应用" class="headerlink" title="Servlet应用"></a>Servlet应用</h2><h3 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h3><pre><code>获取客户端请求，所有的客户端的请求数据都存在于Request对象里</code></pre><h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><pre><code>1. get提交的数据会放在URL之后，以?分隔，URL和数据，参数之间以&amp;连接
2. get方式明文传递，数据量小，不安全
3. 效率高，浏览器默认为GET请求
4. 对应的方法为GET</code></pre><h4 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h4><pre><code>1. post请求把提交的数据放在HTTP的Body中
2. post密文传输，数据量大，安全
3. 效率相对不高
4. 对应的Servlet方法是doPost</code></pre><h4 id="Request的常用方法"><a href="#Request的常用方法" class="headerlink" title="Request的常用方法"></a>Request的常用方法</h4><pre><code>1. 方法</code></pre><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String getParameters(String name)</td>
<td align="center">组件名称</td>
<td align="center">根据表单组件名称获取数据</td>
</tr>
<tr>
<td align="center">void setCharacterEncoding(String chaset)</td>
<td align="center">设置字符编码</td>
<td align="center">指定请求的编码</td>
</tr>
</tbody></table>
<h4 id="Request的应用"><a href="#Request的应用" class="headerlink" title="Request的应用"></a>Request的应用</h4><pre><code>1. 从表单中使用get方法获取数据</code></pre><blockquote>
<pre><code>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    //1.获取用户的请求
    String username = req.getParameter(&quot;username&quot;);
    String password = req.getParameter(&quot;password&quot;);
    System.out.println(&quot;username:&quot;+username+&quot;  --&gt; &quot;+&quot;password:&quot;+password);
}
&lt;form action=&quot;register&quot; method=&quot;get&quot;&gt;
    用户名:&lt;label&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
&lt;/label&gt;&lt;br/&gt;
    密码:&lt;label&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;
&lt;/label&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;
&lt;/form&gt;</code></pre></blockquote>
<pre><code>通过浏览器的内容可看出，使用get方法提交的数据是明文，以?分隔URL和数据，以&amp;拼接参数

问题：get方法参数乱码
    客户端和服务器端的编码不一致，可以使用统一的编码格式，按照此编码进行数据的传输和接受

    Tomcat的7以及以下版本，客户端以UTF-8的编码格式进行数据传输，服务器以ISO8859-1的字符编码来接收数据，两边的编码方式不一样，导致乱码问题。

    可以在服务器接受收数据的时候以IOS8859-1来接收，在进行编码转换

    Tomcat的8版本解决了get方法的乱码问题

2. 使用post方法获取数据</code></pre><blockquote>
<pre><code>protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
  //设置统一编码
  req.setCharacterEncoding(&quot;UTF-8&quot;);     
    //1.获取用户的请求
    String username = req.getParameter(&quot;username&quot;);
    String password = req.getParameter(&quot;password&quot;);
    System.out.println(&quot;username:&quot;+username+&quot;  --&gt; &quot;+&quot;password:&quot;+password);
}
&lt;form action=&quot;register&quot; method=&quot;get&quot;&gt;
    用户名:&lt;label&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
&lt;/label&gt;&lt;br/&gt;
    密码:&lt;label&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;
&lt;/label&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;
&lt;/form&gt;</code></pre></blockquote>
<pre><code>通过浏览器的内容可看出，使用post方法提交的数据没有出现数据信息,只有接受的路径名称，更安全

问题：post中文乱码
    客户端的编码格式为UTF-8,在post使用的时候，将服务器的编码格式转化为UTF-8
    使用ServletRequest的setCharacterEncoding设置编码</code></pre><h2 id="Respone对象"><a href="#Respone对象" class="headerlink" title="Respone对象"></a>Respone对象</h2><pre><code>响应客户端请求，并向客户端输出信息    </code></pre><h3 id="Resopne的主要方法"><a href="#Resopne的主要方法" class="headerlink" title="Resopne的主要方法"></a>Resopne的主要方法</h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>setHeader(name,value)</td>
<td>设置响应信息头</td>
</tr>
<tr>
<td>setContentType(String)</td>
<td>设置响应文件类型,文件编码</td>
</tr>
<tr>
<td>setCharacterEncoding(String)</td>
<td>设置响应编码</td>
</tr>
<tr>
<td>getWriter()</td>
<td>获取字符输出流,返回数据</td>
</tr>
</tbody></table>
<h4 id="响应数据给客户端"><a href="#响应数据给客户端" class="headerlink" title="响应数据给客户端"></a>响应数据给客户端</h4><blockquote>
<pre><code>//响应数据给客户端
  resp.setCharacterEncoding(&quot;UTF-8&quot;);
  PrintWriter printWriter = resp.getWriter();
  printWriter.println(&quot;OK&quot;)</code></pre></blockquote>
<pre><code>问题：出现中文乱码
    和Request的乱码原因相同
    1. 方法一
    * 使用setCharacterEncoding(&quot;UTF-8&quot;)方法来进行服务端编码格式设置
    * 使用setHeader(&quot;Content-type&quot;,&quot;text/html;charset=UTF-8&quot;);
    2. 方法二
    * setContentType(&quot;text/html;charset=UTF-8&quot;),同时设置文件类型和编码格式，必须在获取输出流之前使用</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>问题
1. 在servlet中，调用业务逻辑和显示页面都在同一个servlet中，职能不单一，不利于后期维护
2. 可以将业务逻辑和显示信息分离

单独写类进行业务逻辑，和显示信息的打印
XxxController extend HttpServlet
XxxJsp extend HttpServlet

如何跳转到JSP
如何将查询到的数据传送给展示的servlet</code></pre><h3 id="转发（request）"><a href="#转发（request）" class="headerlink" title="转发（request）"></a>转发（request）</h3><pre><code>转发的作用在服务器端，将请求发送给服务器的其他资源，共同完后一次请求</code></pre><h4 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h4><pre><code>1. 页面跳转实现
    在调用业务逻辑的servlet中，编写
        request.getRequestDispatcher(&quot;/目标url-patten&quot;).forward(request,respone)

    页面跳转属于同一次请求，客户端察觉不到转发的过程，在服务器内部进行跳转，地址栏不发生改变</code></pre><h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><pre><code>1. forword表示同一次请求，在服务器内部内部跳转，可以共享同一次request作用域的数据

2. request作用域: 拥有存储数据的空间，作用范围是一次请求(可以进行多次转发)
    * 可以将数据存储到request内部，在一次请求的内部进行数据传递，任意位置获取数据
    * 可以传递任意数据类型(基本数据类型，对象，集合等)

3. request数据存储：以键值对存储数据
    * request.setAttribute(key,value)：key，String类型，value,Object类型
    * 将数据以键值对的方式存储在数据空间内部

4. 获取数据
    * request.getAttribute(key)
    * 通过String类型的key访问value
    * 需要转换数据类型</code></pre><h4 id="转发的注意事项"><a href="#转发的注意事项" class="headerlink" title="转发的注意事项"></a>转发的注意事项</h4><pre><code>1. 转发是服务器的行为
2. 转发浏览器只有一次请求
3. 浏览器地址不变
4. 转发两次的跳转信息不会丢失，可以使用request作用域传递数据
5. 转发只能将请求转发给同一个web中的组件</code></pre><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><pre><code>重定向作用在客户端，客户端将请求发送给服务器之后，服务器响应给客户端一个新的请求地址，客户端重新发送请求</code></pre><h4 id="页面跳转-1"><a href="#页面跳转-1" class="headerlink" title="页面跳转"></a>页面跳转</h4><pre><code>1. 实现
    * respone.sendRedirect(&quot;目标URI&quot;)
    * 表示服务器中的一个资源，资源在服务器中的路径(/项目/资源)

    客户端做了两次请求，地址栏发生了改变</code></pre><h4 id="数据传递-1"><a href="#数据传递-1" class="headerlink" title="数据传递"></a>数据传递</h4><pre><code>1. sendRedirect跳转时，地址栏发生改变，代表客户端重新发送的请求，属于两次请求

2. respone没有作用域，两次的request数据无法共享

3. 传递数据：
    使用拼接字符串进行数据传递(&quot;/webproject/b&quot;+&quot;?name=1&amp;password=1&quot;)

4. 获取数据
    使用request.getParameters,只能是string的数据类型</code></pre><h4 id="重定向注意实项"><a href="#重定向注意实项" class="headerlink" title="重定向注意实项"></a>重定向注意实项</h4><pre><code>1. 客户端的行为
2. 浏览器有两次请求
3. 浏览器地址栏发生改变
4. 两次跳转的传输信息会丢失(request范围)
5. 重定向可以指向任意资源，包括其他站点的资源</code></pre><h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><h3 id="生命周期的四个阶段"><a href="#生命周期的四个阶段" class="headerlink" title="生命周期的四个阶段"></a>生命周期的四个阶段</h3><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><pre><code>1. 当用户第一次访问servlet时，由容器调用servlet的构造方法创建servlet对象，也可以在容器启动之后进行创建，使用load_on_startup可以控制对象的创建时间    
2. 只进行一次实例化</code></pre><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre><code>1. 在初始化阶段，init()被调用，方法定义在javax.servlet.Servlet的接口中，以servletConfig对象作为参数
2. init()只执行一次</code></pre><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><pre><code>1. 当客户端有一个请求，容器就会将ServletRequest与响应ServletRespone转给对应的servlet对象，以参数的形式传给service()
2. service()执行多次</code></pre><h4 id="死亡"><a href="#死亡" class="headerlink" title="死亡"></a>死亡</h4><pre><code>1. 当容器停止或者重新启动都会销毁servlet对象
2. destroy()执行一次</code></pre><h3 id="Servlet的特性"><a href="#Servlet的特性" class="headerlink" title="Servlet的特性"></a>Servlet的特性</h3><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><pre><code>1. 问题
    servlet对象只创建一个实例对象，类似于单例模式，而Tomcat服务器容器可以同时多个线程并发访问同一个servlet,如果某个线程对成员变量进行修改，会造成线程安全问题

2. 解决线程安全问题
    * synchronized同步锁
        将存在线程安全问题的代码放入synchroized内部

        但是servlet只进行一次实例化，在线程进行访问的时候，对业务进行上锁，多个其他线程会等待释放锁，效率比较低

    * 实现SingleThreadModel接口
        servlet实现SingleThreadModel接口，每个线程会创建自己的servlet实例，请求不存在资源共享的问题，没有线程安全问题，但是servlet已经不使用

    * 使用局部变量，防止共享资源的出现
        推荐使用局部变量进行数据操作</code></pre><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h3 id="现有问题"><a href="#现有问题" class="headerlink" title="现有问题"></a>现有问题</h3><pre><code>1. HTTP协议是无状态的，不能保存每次提交的信息
2. 如果用户发来一个新的请求，服务器无法知道是否与上次的请求有关
3. 如果需要多次进行请求的操作，没有关联，难以进行下去</code></pre><h3 id="状态管理的概念"><a href="#状态管理的概念" class="headerlink" title="状态管理的概念"></a>状态管理的概念</h3><pre><code>将浏览器与web服务器的多次交互当作一个整体来处理，并且将多次的交互数据保存下来</code></pre><h3 id="状态管理的分类"><a href="#状态管理的分类" class="headerlink" title="状态管理的分类"></a>状态管理的分类</h3><pre><code>1. 客户端状态管理：
    将状态保存在客户端：Cookie
2. 服务器状态管理：
    将状态保存在服务端：Session</code></pre><h2 id="Cookie的使用"><a href="#Cookie的使用" class="headerlink" title="Cookie的使用"></a>Cookie的使用</h2><h3 id="什么是Cookie"><a href="#什么是Cookie" class="headerlink" title="什么是Cookie"></a>什么是Cookie</h3><pre><code>1. Cookie是浏览器访问Web服务器的某个资源时，由web服务器在HTTP响应消息头中附带传送给浏览器的一小段数据(服务器创建，保存在浏览器端)
2. 一旦Web浏览器保存了某个Cookie，在每次访问该web服务器都应该将这个cookie附加在HTTP请求头上回传给服务器
3. 一个Cookie主要由标识该信息的名称和值组成(key:value)

Cookie的原理
    * 在浏览器首次连接服务器，并得到服务器的响应数据，由服务器创建一个Cookie响应给浏览器，浏览器将响应的Cookie进行存储
    * 在以后的请求中，每次的请求数据中都会增加Cookie数据，而服务器收到请求后会首先进行Cookie的比对，如果存在Cookie,就获取Cookie，进行下面的操作</code></pre><h3 id="创建Cookie"><a href="#创建Cookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h3><pre><code>1. 创建Cookie</code></pre><blockquote>
<pre><code>//1.创建Cookie对象
  Cookie ck = new Cookie(&quot;zxl&quot;,&quot;123456&quot;);
//2.将Cookie响应给浏览器
  resp.addCookie(ck);</code></pre></blockquote>
<blockquote>
</blockquote>
<p><img src="/2020/09/19/servlet/cookie1.png" alt="cookie在浏览器"><br><img src="/2020/09/19/servlet/cookie2.png" alt="cookie在浏览器2"></p>
<pre><code>2. 常用的设置：
    1. setPath()：指定可以获取Cookie的路径
    2. setMaxAge():设置生命周期    
        * &gt;0:设置过期时间，以秒为单位，不随浏览器的关闭而结束
        * =0:浏览器关闭,Cookie结束
        * &lt;0:浏览器临时存储，一旦内存清理或者浏览器关闭，就不存在，默认-1</code></pre><p><img src="/2020/09/19/servlet/cookie_setting.png" alt="Cookie的设置"></p>
<h3 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h3><pre><code>获取Cookie必须包含创建cookie对象时允许访问的的路径，即在创建cookie的setPath</code></pre><blockquote>
<pre><code>//获取Cookie
Cookie[] cookies = req.getCookies()；
//2.获取需要的cookies
if(cookies != null){
   for(Cookie cookie:cookies){
      System.out.println(&quot;cookie&quot;+cookie.getName()+&quot;---&gt;&quot;+cookie.getValue());
   }
}</code></pre></blockquote>
<h3 id="修改Cookie"><a href="#修改Cookie" class="headerlink" title="修改Cookie"></a>修改Cookie</h3><pre><code>只需要保证Cookie的名称和路径一致，就可以覆盖原来的cookie，只是名称一样的，不会进行覆盖
其余步骤和创建cookie一样</code></pre><blockquote>
<pre><code>Cookie ck = new Cookie(&quot;1&quot;,&quot;1&quot;)；
ck.setPath(&quot;/webs&quot;)；
ck.setMaxAge(60*60)；
resq.addCookie(ck)；</code></pre></blockquote>
<h3 id="Cookie编码与解码"><a href="#Cookie编码与解码" class="headerlink" title="Cookie编码与解码"></a>Cookie编码与解码</h3><pre><code>Cookie是不需要中文的，只能包含ASCII码，如果需要使用unicode，需要进行编码和解码    </code></pre><p><img src="/2020/09/19/servlet/charset.png" alt="编码异常"></p>
<pre><code>* 编码可以使用java.net.URLEncoder的encode(String str,String encoding)
* 解码可以使用java.net.URLDecoder的decode(String str,String encoding)</code></pre><h4 id="创建-读取带有中文的Cookie"><a href="#创建-读取带有中文的Cookie" class="headerlink" title="创建 读取带有中文的Cookie"></a>创建 读取带有中文的Cookie</h4><p><img src="/2020/09/19/servlet/encode_decode.png" alt></p>
<h3 id="Cookie的优点和缺点"><a href="#Cookie的优点和缺点" class="headerlink" title="Cookie的优点和缺点"></a>Cookie的优点和缺点</h3><pre><code>1. 优点：
    * 可以配置到期规则
    * 简单：基于文本结构，包含简单的键值对
    * 数据持久性：Cookie默认在到期之前可以一直存在于浏览器

2. 缺点
    * 数据大小受限制：一般浏览器的Cookie在4k,8k字节的限制
    * 用户配置为禁用，会限制Cookie的使用
    * cookie可能被篡改，对安全性造成威胁</code></pre><h2 id="Session对象"><a href="#Session对象" class="headerlink" title="Session对象"></a>Session对象</h2><h3 id="Session概述"><a href="#Session概述" class="headerlink" title="Session概述"></a>Session概述</h3><pre><code>1. Session用于记录用户的状态，是指在一段时间内，单个客户端与Web服务器的一连串相关的交互过程
2. 在一个Session中，一个用户可能会多次请求同一个资源，也有可能访问不同的服务器资源

Session的原理：
    * 服务器会为每一个会话分配一个Session对象
    * 同一个浏览器的多次请求，同属于一个会话
    * 首次使用Session时，服务器会创建Session，并创建Cookie存储SessionId发回服务器

Session对象是由服务器创建的，存储于服务器端</code></pre><h3 id="Session使用"><a href="#Session使用" class="headerlink" title="Session使用"></a>Session使用</h3><pre><code>1. Session作用域：拥有存储数据的空间，作用范围是一次会话
    * 一次会话，是使用同一个浏览器发送的多次请求，一旦浏览器关闭，则会话结束
    * 可以将数据存入Session,在一次会话的任意位置进行获取
    * 可以传递任意数据类型（基本数据，字符串，数组，集合等）</code></pre><h4 id="获取Session对象"><a href="#获取Session对象" class="headerlink" title="获取Session对象"></a>获取Session对象</h4><pre><code>在浏览器首次连接服务器时，服务器自动创建Session对象，并创建Cookie返回sessionId
//1.通过request对象获取Session对象</code></pre><blockquote>
<pre><code>HttpSession session = request.getSession();
System.out.println(session.getId());</code></pre></blockquote>
<h3 id="Session数据传递"><a href="#Session数据传递" class="headerlink" title="Session数据传递"></a>Session数据传递</h3><h4 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h4><pre><code>* setAttribute(属性名，Object)
    session.setAttribute(key,value);以键值对的形式存储数据</code></pre><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><pre><code>* getAttribute(属性名)
    session.getAttribute(key);获取数据</code></pre><h4 id="移除数据"><a href="#移除数据" class="headerlink" title="移除数据"></a>移除数据</h4><pre><code>* removeAttribute(key)
    session.removeAttribute(key)</code></pre><h3 id="Session的生命周期"><a href="#Session的生命周期" class="headerlink" title="Session的生命周期"></a>Session的生命周期</h3><pre><code>* 开始：浏览器首次使用到Session的请求，会创建Session
* 结束：
        浏览器关闭，则无效
        Session超时，则无效（可以设置最大有效时间，单位秒）
            session.setMaxInactiveInter
        手工销毁，则失效
            session.invalidate();//退出登录，注销</code></pre><h3 id="Session超时设置"><a href="#Session超时设置" class="headerlink" title="Session超时设置"></a>Session超时设置</h3><pre><code>session.setMaxInactiveInterval(60);</code></pre><h3 id="禁用session解决"><a href="#禁用session解决" class="headerlink" title="禁用session解决"></a>禁用session解决</h3><pre><code>由于session是借助cookie来进行传递的，如果浏览器禁止cookie，浏览器不会接收session，在下一次连接的时候，会创建一个新的session

URL重写：
    浏览器在访问服务器的地址时，不再使用原来的地址，而是经过改写的地址，原来的地址后面增加了sessionId

实现：
    使用respone.encodeRedirectURL(String url)生成新的URL，根据是否禁用cookie来在尾部追加SessionId</code></pre><h3 id="Seeeion的案例"><a href="#Seeeion的案例" class="headerlink" title="Seeeion的案例"></a>Seeeion的案例</h3><pre><code>* 进行登录验证</code></pre><p><img src="/2020/09/19/servlet/session_exp_1.png" alt="Seeeion的案例_进行登录验证"><br>    * 进行邮箱验证<br><img src="/2020/09/19/servlet/session_exp_2.png" alt="Seeeion的案例_进行登录验证"></p>
<h3 id="Request-Session的区别"><a href="#Request-Session的区别" class="headerlink" title="Request,Session的区别"></a>Request,Session的区别</h3><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">创建时机</th>
<th align="center">数据类型</th>
<th align="center">数据存储</th>
<th align="center">数据获取</th>
<th align="center">数据移除</th>
<th align="center">传输方式</th>
<th align="center">作用范围</th>
<th align="center">生命周期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">rsquest</td>
<td align="center">建立连接</td>
<td align="center">任意数据类型</td>
<td align="center">setAttribute(String,Obiect)</td>
<td align="center">getAttribute</td>
<td align="center">removeAttribute</td>
<td align="center">转发</td>
<td align="center">一个请求，可以多次转发</td>
<td align="center">一次请求</td>
</tr>
<tr>
<td align="center">session</td>
<td align="center">首次连接</td>
<td align="center">任意数据类型</td>
<td align="center">setAttribute(String,Obiect)</td>
<td align="center">getAttribute</td>
<td align="center">removeAttribute</td>
<td align="center">转发，重定向</td>
<td align="center">一次会话，可以多次转发和重定向</td>
<td align="center">一次会话</td>
</tr>
<tr>
<td align="center">### 重定向和转发的区别</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">方式</td>
<td align="center">数据类型</td>
<td align="center">数据存储</td>
<td align="center">数据获取</td>
<td align="center">数据移除</td>
<td align="center">传输方式</td>
<td align="center">作用范围</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center">:-:</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">转发</td>
<td align="center">任意数据类型</td>
<td align="center">request.setAttribute()</td>
<td align="center">resquest.getAttribute()</td>
<td align="center">remove</td>
<td align="center">request.getRequestDispaher(URL).forword(reuqest,resq)</td>
<td align="center">同一web应用内部</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">重定向</td>
<td align="center">字符串</td>
<td align="center">respone.sendRedirect(URL)</td>
<td align="center">request.getParaeters()</td>
<td align="center">?</td>
<td align="center">resq.sendRedirect(URL)</td>
<td align="center">任意地址</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">* 转发和重定向都是数据传递的一种方式，如果需要进行数据的传输，可以使用转发，只是单纯的数据跳转，可以使用重定向</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h3><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">创建时机</th>
<th align="center">创建者</th>
<th align="center">创建方式</th>
<th align="center">存储位置</th>
<th align="center">获取</th>
<th align="center">赋值</th>
<th align="center">修改</th>
<th align="center">作用范围</th>
<th align="center">编码与解码</th>
<th align="center">使用限制</th>
<th align="center">解决思路</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Cookie</td>
<td align="center">由开发人员在服务中创建</td>
<td align="center">开发人员</td>
<td align="center">Cookie ck = new Cookie(string,object)</td>
<td align="center">存储在客户端</td>
<td align="center">request.getCookies()</td>
<td align="center">创建时赋值，也可以使用setValue，使用respone.addCookie()响应给浏览器</td>
<td align="center">新建，只要名称和路径相同，就可以覆盖</td>
<td align="center">可以使用setMaxAge设置超时，正数，以秒计算；0 连接关闭时；-1浏览器缓存清空</td>
<td align="center">URLEncoder.encode(),URLDecoder.decoede()</td>
<td align="center">缓存较小，禁用cookie</td>
<td align="center">使用重定向将数据传输</td>
</tr>
<tr>
<td align="center">Session</td>
<td align="center">浏览器首次连接服务器时，自动创建</td>
<td align="center">容器</td>
<td align="center">HttpSession session = req.getSession()</td>
<td align="center">存储在服务器</td>
<td align="center">request.getSession()</td>
<td align="center">sessio..setAttribute</td>
<td align="center">remove</td>
<td align="center">使用setMaxInacticveInter()设置超时,单位秒；关闭会话；手动清除session.invaloidate（）</td>
<td align="center">URLEncoder.encode(),URLDecoder.decoede()</td>
<td align="center">session借助于cookie来告知浏览器，如果禁用cookie，不会保存session的id,服务器不能识别session</td>
<td align="center">使用encoderRedirectURL()重定向，将数据加在访问路径之后</td>
</tr>
</tbody></table>
<pre><code>* cookie和session都是保存浏览器访问服务器的状态，使用方式和存储位置不一样
* cookie存储的数据都是字符串，需要使用respone.addCookie(),将数据响应给浏览器，可以一次响应多个Cookie
* sesssion可以存储任意类型数据，直接session.setAttribute(),一个会话只有一个Session，一个SessionId</code></pre><h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><pre><code>* 全局对象，拥有作用域，对应tomcat的一个web应用
* 当web服务器启动时，会为每一个web应用程序创建一个ServletContext对象，共享的存储区
* ServletContext在服务器启动的时候创建，服务器关闭的时候销毁</code></pre><h3 id="获取ServletContext"><a href="#获取ServletContext" class="headerlink" title="获取ServletContext"></a>获取ServletContext</h3><pre><code>1. 使用GenericServlet对象
    * getServletContext(),HttpServlet继承了GenericServlet,可以使用this.getServletContext()获取对象

2. HttPServletRequest对象
    * getServletContext()

3. HttpSession
    * getServletContext()</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><pre><code>1. 获取当前项目的真实路径：
    * context.getRealPath()

2. 获取项目的上下文名称：部署时的路径，项目的名称
    * context.getContextPath()

3. 全局容器 : 整个web应用都可以使用
    * 存储数据：setAttribute(string,object)
    * 获取数据：getAttribute(string)
    * 移除数据：removeAttribute(string)</code></pre><h3 id="ServletContext特点"><a href="#ServletContext特点" class="headerlink" title="ServletContext特点"></a>ServletContext特点</h3><pre><code>* 唯一性：一个项目只有一个ServletContext
* 生命周期：只要容器不关闭或者应用不卸载，servletContext一直存在</code></pre><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 统计当前项目的访问次数</code></pre><p><img src="/2020/09/19/servlet/servletcontext_count.png" alt="servletcontext"></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><pre><code>现有问题
    代码冗余，可以抽取代码，比如编码问题</code></pre><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><pre><code>过滤器(Filter)是位于客户端和服务器目标资源的一道过滤技术</code></pre><p><img src="/2020/09/19/servlet/filter_exe.png" alt="过滤器的执行流程"></p>
<h3 id="filter作用"><a href="#filter作用" class="headerlink" title="filter作用"></a>filter作用</h3><pre><code>1. 执行在servlet之前，客户端发送请求的时候，会先经过过滤器，再到达目标资源；响应的时候，会根据执行流程再次反向执行filter
2. 可以解决多个servlet的代码冗余问题，编码处理，登录验证</code></pre><h3 id="filter的编写"><a href="#filter的编写" class="headerlink" title="filter的编写"></a>filter的编写</h3><pre><code>Servlet API提供了一个Filter接口，只要实现了这个接口，就会成为过滤器（Filter）</code></pre><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><pre><code>1. 编写java的实现代码
2. 编写doFileter()方法
3. 让请求继续下去，使用FilterChain,拦截链
    filterChain.doFilter(req,resp):让请求继续下去

在响应的时候，也会将响应传递给过滤器，然后再传递给客户端</code></pre><h3 id="filter的配置"><a href="#filter的配置" class="headerlink" title="filter的配置"></a>filter的配置</h3><pre><code>1. 注解配置
    @WebFilter(value = &quot;/过滤的目标资源&quot;)

2. 在web.xml中配置filter
    使用filter filter-mapping</code></pre><h3 id="过滤器链和过滤优先级"><a href="#过滤器链和过滤优先级" class="headerlink" title="过滤器链和过滤优先级"></a>过滤器链和过滤优先级</h3><pre><code>1. 过滤器链
    * 客户端对服务器请求之后，服务器会执行一组过滤器，那么这组过滤器就叫做过滤器链。
    * 每个过滤器实现特定的功能当第一个过滤器的doFilter方法被调用的时候，web服务器会创建一个代表过滤器链的filterChain对象，在doFilter方法中，开发人员如果调用了FilterChain的doFilter方法，web服务器会检查是否还有其他的过滤器，如果还有，就会执行第二个过滤器，如果没有，就调用目标资源。

2. 过滤器链的优先级
    * 如果全是注解，会按照类全名称的字典顺序
    * 如果全是xml,按照filter的注册顺序，从上往下
    * 两者都有，xml的优先级高于注解
    * 同时配置，会执行多次过滤</code></pre><h3 id="filter拦截路径设置"><a href="#filter拦截路径设置" class="headerlink" title="filter拦截路径设置"></a>filter拦截路径设置</h3><pre><code>1. 精确拦截;
    /index.jsp
2. 后缀拦截:
    *.jsp，不需要加/
3. 通配符拦截
    /* ,/aaa/bbb/*
    不能使用/进行拦截</code></pre><h3 id="filter使用场景"><a href="#filter使用场景" class="headerlink" title="filter使用场景"></a>filter使用场景</h3><pre><code>1. 过滤器解决编码问题
    * 统一解决字符编码问题
2. 解决权限验证问题
    * 在过滤器中验证是否登录过服务器</code></pre><p><img src="/2020/09/19/servlet/errors_01.png" alt></p>
]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet路径有关的问题</title>
    <url>/2020/09/26/servlet_path/</url>
    <content><![CDATA[<h2 id="servlet中的转发，重定向，页面跳转中的路径问题"><a href="#servlet中的转发，重定向，页面跳转中的路径问题" class="headerlink" title="servlet中的转发，重定向，页面跳转中的路径问题"></a>servlet中的转发，重定向，页面跳转中的路径问题</h2><h3 id="转发的路径：request-gerRequestDispacher-“-“-forward-request-respone"><a href="#转发的路径：request-gerRequestDispacher-“-“-forward-request-respone" class="headerlink" title="转发的路径：request.gerRequestDispacher(“/“).forward(request,respone)"></a>转发的路径：request.gerRequestDispacher(“/“).forward(request,respone)</h3><pre><code>1. getRequestDispacher(url) : 只有相对路径，相对于项目路径，还是相对于当前文件路径
    *  ServletRequest接口中的参数路径不仅可以相对于当前Servlet上下文根，还可以相对与当前Servlet路径    
    *  因为在getRequestDispatcher(url)方法中封装了ServletContext.getRealPath()以获得相应的项目根路径，再通过字符串相加，从而可以获得一个完整的路径

2. 如果在静态页面中引用资源，可以直接写拦截路径，不需要增加/,默认在当前项目的文件夹下，如果增加/,会在当前目录的上一级目录中寻找资源
3. 如果使用 /xxxx/xx，则认为在当前项目的路径下寻找资源（在项目的路径下寻找资源）
4. 如果使用 xxxx/xxx,会将当前访问资源的上一级目录作为根目录，进行字符串拼接，寻找目标资源（在当前的路径下寻找资源）

5. 在使用的时候，可以按照访问的路径长短来进行转发资源的url书写
    * 在同一个访问路径下，可以直接使用文件名作为url参数，会得到想要的资源
    * 不在同一访问路径下，可以使用项目文件路径，就是在注解中使用的路径，也可以访问目标资源

总结：
    1. 如果是在静态页面，比如html,如果访问路径不加/，意味着在当前的项目路径下寻找资源；如果增加/,意味着在当前项目路径的上一级目录中寻找资源
    2. 如果是在servlet中进行转发，使用/xx,意味着从项目路径下寻找资源；不使用/，意味着从当前的访问路径中寻找资源
    3. res.getContextPath()查找当前的上下文路径，不能用在转发上</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/26/servlet_path/dispacher_1.png" alt="静态页面的访问形式"><br><img src="/2020/09/26/servlet_path/dispacher_2.png" alt="两种路径的区别"><br><img src="/2020/09/26/servlet_path/dispacher_url_use.png" alt="url的格式，使用方式"></p>
<h3 id="重定向的路径：respone-sendRedirect-url"><a href="#重定向的路径：respone-sendRedirect-url" class="headerlink" title="重定向的路径：respone.sendRedirect(url)"></a>重定向的路径：respone.sendRedirect(url)</h3><pre><code>1. sendRedirect(url):只有相对于项目路径的url
    * 通过使用 req.getContextPath()+&quot;/xxx/xxx&quot;进行资源的访问</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/26/servlet_path/sendredirect_1.png" alt="sendRedirect"></p>
<h3 id="表单提交地址"><a href="#表单提交地址" class="headerlink" title="表单提交地址"></a>表单提交地址</h3><pre><code>* 不需要增加/,默认在当前项目的文件夹下，如果增加/,会在当前目录的上一级目录中寻找资源</code></pre>]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2020/09/09/spring/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-什么是spring："><a href="#1-什么是spring：" class="headerlink" title="1. 什么是spring："></a>1. 什么是spring：</h3><pre><code>1. 分层的Java SE/EE的轻量级开源框架
2. 提供了展现层Spring MVC 和持久层Spring JDBC以及业务层事务管理的众多技术
3. 展现层和持久层的中间部分，业务层</code></pre><h3 id="2-spring的核心："><a href="#2-spring的核心：" class="headerlink" title="2. spring的核心："></a>2. spring的核心：</h3><pre><code>1. IoC（Inversion of Control）: 控制反转
2. AOP（Aspect Oriented Programming）: 面向切面编程</code></pre><h3 id="3-发展历程和优势"><a href="#3-发展历程和优势" class="headerlink" title="3.发展历程和优势"></a>3.发展历程和优势</h3><pre><code>spring优势：
    1. 方便解耦，简化开发
    2. AOP编程的支持
    3. 声明式事务的支持
    4. 方便程序的测试
    5. 方便集成各种优秀的框架</code></pre><h2 id="程序的耦合和解耦"><a href="#程序的耦合和解耦" class="headerlink" title="程序的耦合和解耦"></a>程序的耦合和解耦</h2><h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><pre><code>1. 什么是耦合：
    程序之间的依赖关系：
        * 类之间的依赖关系
        * 方法之间的依赖关系

2. 开发中的做法：
    编译期不依赖，运行时依赖

3. 方法：
    1. 使用读取配置文件来获取要创建的对象的全限定名称
        使用类加载器，获取配置文件的输入流
    2. 使用反射（reflection）来创建对象，而不是使用new关键字
        * 使用反射，如果字符串写死，以后无法再次使用别的数据库配置</code></pre><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><pre><code>1. 什么是解耦：
    降低程序之间的依赖关系

2. 解耦的方式：使用工厂模式创建Bean对象
      * bean: 可重用组件
      * javaBean &gt; 实体类
      * javaBean 用java语言编写的可重用组件
      * beanfactory：创建bean对象的工厂

3. 如何创建工厂模式
    1. 读取配置文件来反射bean对象
    2. 配置文件来创建service和dao
        唯一标识=全限定类名，key = value，根据对应的value创建实例对象</code></pre><h2 id="IoC（Inversion-of-Control）"><a href="#IoC（Inversion-of-Control）" class="headerlink" title="IoC（Inversion of Control）"></a>IoC（Inversion of Control）</h2><pre><code>1. 概念：
    把创建对象的权力交给框架，是框架的重要特征，包括依赖注入（Dependency Injection,DI）和依赖查找（Dependency Lookup）

2. 作用
    * 降低程序之间的耦合度
    * 将类中的对象创建工作交给spring框架来完成，只要获取该对象就可以了
    * 使用依赖注入进行属性值的填充，在创建对象的同时完成赋值</code></pre><h3 id="基于XML的IoC配置"><a href="#基于XML的IoC配置" class="headerlink" title="基于XML的IoC配置"></a>基于XML的IoC配置</h3><h4 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h4><pre><code>1. 步骤
    * 读取配置文件创建IoC容器（ApplicationContext）
    * 根据id，获取容器中的文件

2. 配置文件的内容
    * 主要是&lt;bean&gt;标签，id:查找对象的唯一标识符，class:要创建的对象的全限定类名

3. 读取配置文件创建容器
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    根据类路径下的xml配置文件创建容器，配置文件需要放置在类路径下

    ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;bean.xml&quot;);
    可以加载磁盘任意路径下的配置文件

    ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class);
    根据类上有@Configuration的类创建容器

4. 根据id获取对象
    as.getBean(&quot;id&quot;);</code></pre><h4 id="BeanFactory和ApplicationContext"><a href="#BeanFactory和ApplicationContext" class="headerlink" title="BeanFactory和ApplicationContext"></a>BeanFactory和ApplicationContext</h4><pre><code>1. Beanfactory接口
    * 创建核心容器时，创建对象的方式采用延迟加载的方式，什么时候根据ID获取对象的时候，什么时候开始创建真正的对象
     * 多例模式适用

2. ApplicationContext接口
    * 创建核心容器时，创建对象的方式采用立即加载的方式，只要一读取完配置文件马上创建配置文件中的对象
     * 单例模式时适用：只创建一个对象

3. 具体的使用
    BeanFactory是顶层接口，功能不如ApplicationContext，实际使用的接口为ApplicationContext接口

    ApplicationContext可以根据配置文件的不同，选择合适的加载方式
    可以感知到对象的单例还是多例，从而选择不同的方式创建对象</code></pre><h4 id="spring对bean对象的管理细节"><a href="#spring对bean对象的管理细节" class="headerlink" title="spring对bean对象的管理细节"></a>spring对bean对象的管理细节</h4><h5 id="1-创建bean的三种方式"><a href="#1-创建bean的三种方式" class="headerlink" title="1. 创建bean的三种方式"></a>1. 创建bean的三种方式</h5><pre><code>1. 使用默认构造函数创建：
   在spring的配置文件中使用bean标签，配以id 和 class属性，且没有其他的属性和标签时
   采用的就是默认构造函数创建bean对象(Class类的实例反射)，如果此时没有默认构造函数，则无法创建</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_IoC_bean.service.impl.AccountServiceImpl&quot;/&gt;</code></pre></blockquote>
<pre><code>2. 使用普通工厂中的方法创建对象
    使用某个类中的方法创建对象，并存入spring容器中</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.spring_03_IoC_bean.factory.InstanceFactory&quot;/&gt;
&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;/&gt;</code></pre></blockquote>
<pre><code>3. 使用工厂的静态方法创建对象（
    使用某个类的静态方法创建对象(可以不创建该对象)，并将其存入spring容器</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_IoC_bean.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;/&gt;</code></pre></blockquote>
<h5 id="2-bean对象的作用范围"><a href="#2-bean对象的作用范围" class="headerlink" title="2. bean对象的作用范围"></a>2. bean对象的作用范围</h5><pre><code>1. bean标签的scope属性规定bean对象的范围
2. 类型
    * singleton: 单例模式（默认）
    * prototype：多例模式
    * requset:web应用的一次请求
    * session：web应用中的一次会话
    * global-session：web应用中的全局会话</code></pre><h5 id="3-bean对象的生命周期"><a href="#3-bean对象的生命周期" class="headerlink" title="3. bean对象的生命周期"></a>3. bean对象的生命周期</h5><pre><code>1. 单例对象：singleton
  出生：当容器创建时，对象出生
  活着：只要容器还在，对象活着
  死亡：容器销毁，对象死亡
2. 多例对象：prototype
  出生：当使用对象时，spring框架创建
  活着：只要在使用的时候一直存在
  死亡：只有在对象长时间不用，且没有其他的对象引用的时候，由垃圾回收机制回收</code></pre><h4 id="依赖注入（dependency-injection-DI）"><a href="#依赖注入（dependency-injection-DI）" class="headerlink" title="依赖注入（dependency injection:DI）"></a>依赖注入（dependency injection:DI）</h4><pre><code>1. 什么是依赖？    
    当前类中引用到其他类的对象，叫做依赖。
    在spring框架中，依赖对象由框架提供，我们只需要提供配置文件的说明（IoC方式）

2. spring降低程序之间的依赖关系?
    IoC控制反转
    依赖注入

3. 依赖注入的数据类型：
    1. 基本数据类型和String类型
    2. 其他bean对象
    3. 复杂类型（集合类型）

4. 依赖注入的方式：
    1. 通过默认构造函数注入依赖
    2. 使用set方法注入 ***
    3. 通过注解注入</code></pre><h5 id="1-通过默认构造函数注入"><a href="#1-通过默认构造函数注入" class="headerlink" title="1. 通过默认构造函数注入"></a>1. 通过默认构造函数注入</h5><pre><code>标签：constructor-arg
位置：bean中的内部
属性含义：
    type: 指定要注入的数据类型，该数据类型是构造函数的某个或者某些参数的类型
    index: 指定要注入数据给构造函数的参数指定索引的位置的赋值
    name: 用于指定给构造函数的指定名称的参数赋值（主要方式）
    ===================指定给构造函数的那个参数赋值=======================

    value: 提供基本类型和String类型的数据
    ref: 指定其他的bean类型的数据，在spring的IoC的核心容器中的bean对象

优势：
    在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功
缺点：
    改变了bean对象的实例化方式，在我们创建对象时，即使用不到这些数据，也必须提供数据</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;李某&quot;/&gt;
    &lt;constructor-arg name=&quot;age&quot; value=&quot;23&quot;/&gt;
    &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;
&lt;/bean&gt;</code></pre></blockquote>
<blockquote>
<pre><code>&lt;!-- 配置一个日期对象 --&gt;
&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;/&gt;</code></pre></blockquote>
<h5 id="2-使用set进行依赖注入"><a href="#2-使用set进行依赖注入" class="headerlink" title="2. 使用set进行依赖注入"></a>2. 使用set进行依赖注入</h5><pre><code>标签：property
位置：bean标签内部
参数：
    name:    指定注入的时候的方法的名称
    value:     指定基本数据类型和String类型
    ref:     指定其他的bean类型的数据，只要是在spring核心容器中的bean对象都可以

优势：创建bean对象的时候，可以直接使用默认构造函数
   缺点：
      如果某个成员必须有值，获取对象的set方法可能没有执行</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService2&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl2&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;22&quot;/&gt;
    &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;
&lt;/bean&gt;</code></pre></blockquote>
<blockquote>
<pre><code>&lt;!-- 配置一个日期对象 --&gt;
&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;/&gt;</code></pre></blockquote>
<h5 id="3-使用注解进行依赖注入"><a href="#3-使用注解进行依赖注入" class="headerlink" title="3. 使用注解进行依赖注入"></a>3. 使用注解进行依赖注入</h5><pre><code>@Autowired
@Qualifier
@Resource
@Value
进行依赖注入</code></pre><h5 id="4-注入复杂数据类型"><a href="#4-注入复杂数据类型" class="headerlink" title="4. 注入复杂数据类型"></a>4. 注入复杂数据类型</h5><pre><code>List Set      
Map Properties

标签：property
位置：property内部
其中：只要数据集合的结构相同，可以使用同一种标签进行依赖注入
    list set arrsy: 都可以使用&lt;list&gt;,&lt;array&gt;,&lt;set&gt;，序列格式
    map property:&lt;map&gt;,&lt;pros&gt;，键值对格式</code></pre><blockquote>
<pre><code>private String[] myStr;
private List&lt;StringmyList;
private Set&lt;StringmySet;
private Map&lt;String,StringmyMap;
private Properties myProp;</code></pre></blockquote>
<pre><code>具体的调用方法</code></pre><blockquote>
<pre><code>&lt;bean id=&quot;accountService3&quot; class=&quot;com.spring_03_DI.service.impl.AccountServiceImpl3&quot;&gt;
&lt;property name=&quot;myStr&quot;&gt;
  &lt;array&gt;
    &lt;value&gt;AAA&lt;/value&gt;
    &lt;value&gt;VVVDDD&lt;/value&gt;
    &lt;value&gt;SS&lt;/value&gt;
    &lt;value&gt;SSDDD&lt;/value&gt;
  &lt;/array&gt;
&lt;/property&gt;
&lt;!-- map --&gt;
&lt;property name=&quot;myMap&quot;&gt;
  &lt;map&gt;
    &lt;entry key=&quot;1&quot; value=&quot;11111&quot;/&gt;
    &lt;entry key=&quot;2&quot; value=&quot;22222&quot;/&gt;
  &lt;/map&gt;
&lt;/property&gt;</code></pre>  
</blockquote>
<h3 id="基于注解的IoC配置"><a href="#基于注解的IoC配置" class="headerlink" title="基于注解的IoC配置"></a>基于注解的IoC配置</h3><pre><code>使用注解和xml开发要实现的功能都是一致的：降低程序之间的耦合，将xml中对应的功能交由注解来实现</code></pre><h4 id="1-用于创建bean对象的注解"><a href="#1-用于创建bean对象的注解" class="headerlink" title="1. 用于创建bean对象的注解"></a>1. 用于创建bean对象的注解</h4><pre><code>* 与xml配置文件中的&lt;bean&gt;标签的作用相同：创建一个bean对象，将其放置在容器中
* 如果想让spring知道存在组件，需要使用spring中的包扫描，将需要创建bean对象的包传入&lt;context&gt;标签中

1. @Component:组件注解
    * 作用：将当前对象存入spring容器中(写在类名上)
    * 属性：value:
            用于指定获取容器中bean的id，当我们不写时，默认是当前类名，首字母小写    

2. @Controller:一般用于表现层
3. @Service：一般用于业务层
4. @Repository:一般用于持久层
以上的三个注解和@Component的作用和属性完全一致，是spring框架为我们明确提供的三层注解，让我们的三层结构更加清晰</code></pre><h4 id="2-用于数据注入的注解"><a href="#2-用于数据注入的注解" class="headerlink" title="2. 用于数据注入的注解"></a>2. 用于数据注入的注解</h4><pre><code>* 与xml配置文件的&lt;property&gt;作用一致：进行数据注入

1. @Autowired:自动按照类型注入
     * 只要IoC容器中有唯一的bean对象和要注入的变量类型相同，就可以自动注入
     * 如果IoC容器中没有任何bean对象和要注入的变量类型相同，无法自动注入
     * 如果IoC容器中有多个bean对象和要注入的变量类型相同，
     * 首先圈定类型相同的bean对象的范围，然后会在进行变量名称的比对,如果名称相同，就可以注入数据</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/autowired.png" alt="autowired注解">         </p>
<pre><code>2. @Qualifier
    * 先按照类型自动注入，如果包含有多个相同类型的bean对象，会按照名称进行数据注入
    * 在按照类型注入的基础上，再按照名称注入，在给类成员的注入的时候不能单独使用，但是在给方法注入的时候可以，，将@Qualifier()中的名称所对应的Bean对象注入到方法中
    * 参数：
        value:用于指定注入的bean的id

3. @Resource
    * 直接按照bean的id进行注入，可以单独使用
    * 参数：
        name:用于指定注入的bean的id

注意：
     以上的三种注入方式只能注入其他的bean类型的数据，基本类型和String类型无法通过上述方法注入
          集合类型只能通过xml方式注入

4. @Value
    * 注入基本数据类型和String类型
    * 参数：    
        value:用于指定数据的值，可以使用SpEL（spring的El表达式）                      SpEL的写法：${表达式}</code></pre><h4 id="3-用于改变作用范围的注解"><a href="#3-用于改变作用范围的注解" class="headerlink" title="3. 用于改变作用范围的注解"></a>3. 用于改变作用范围的注解</h4><pre><code>* 与xml文件中的&lt;bean&gt;标签的scope属性作用相同

1. @Scope
    * 参数：
        value:singleton prototype</code></pre><h4 id="4-用于改变生命周期的注解"><a href="#4-用于改变生命周期的注解" class="headerlink" title="4. 用于改变生命周期的注解"></a>4. 用于改变生命周期的注解</h4><pre><code>1. @PreDestroy
    * 销毁容器
2. @PostConstruct
    * 初始化容器</code></pre><h3 id="使用IoC的一个简单案例"><a href="#使用IoC的一个简单案例" class="headerlink" title="使用IoC的一个简单案例"></a>使用IoC的一个简单案例</h3><pre><code>1. 环境配置
    使用DBUtils进行Dao数据交互
    spring框架
    mybatis进行JDBC连接
    c3p0作为数据源</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/IoC_exp_pom.png" alt="pom.xml"></p>
<pre><code>2. bean文件结构
    1. xml配置</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/Ioc_xml_exp.png" alt="xml配置的bean"></p>
<pre><code>2. annotation配置</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/IoC_anno_exp.png" alt="annotation配置的bean"></p>
<blockquote>
<p>注解的形式以及文件结构<br><img src="/2020/09/09/spring/Ioc_structure.png" alt="annotation的结构"></p>
</blockquote>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><pre><code>在案例中，配置文件存在annotation和xml同时存在，下面将其改造为纯注解方式

1. 改变xml中的组件扫描
    @Configurtion:
        * 作用：用于指定当前类是配置类
         * 当配置类作为AnnotationConfigApplicationContext()的参数时可以不写@Configuration，由扫描器直接扫描该配置类
         * 如果是子配置类，而且子配置类的字节码没有作为参数传入，必须写@Configuration

    @ComponentScan
        * 作用：用于指定spring在创建容器是需要扫描的包
        * 参数：value basePackages作用一样（@Alisafor）    
                类似&lt;context:component-scan base-package=&quot;com.spring_04_exp&quot;/&gt;

    一旦这个类上写了@Configuration 和@ComponentScan ,spring就会自动扫描配置包，并且创建对象将其放入容器，只需要拿到这个bean对象就可以了。

2. 根据方法的返回值创建Bean对象
    @Bean
        * 作用：把当前方法的返回值作为Bean对象存入spring容器中
        * 参数：name:
            用于指定bean的id,当不写时，方法名作为默认值
        * 使用注解配置方法时，spring框架会在容器中查找相对于的bean容器，查找方法与@AutoWired相同

3. 配置文件的读取
    @PropetySource
        * 作用：读取配置文件，用于指定properties文件的位置
        * 参数：value
            文件的名称:文件的路径
        * classpath关键字，表示在类路径下

4. 导入其他的配置类
    @Import
        * 作用：用于导入其他的配置类
        * 参数：value
            用于指定其他配置类的的字节码
        * 当我们使用Import注解时，拥有Import的配置类就是父配置类，写在value中的就是子配置类</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/09/spring/anno_withoutxml_1.png" alt="配置类"><br><img src="/2020/09/09/spring/anno_withoutxml_2.png" alt="配置类"></p>
<pre><code>5. spring整合junit
    1. 程序的入口
        main方法
    2. JUnit单元测试
        没有main方法也能执行，其实junit中集成了main方法
        该方法就会判断当前测试类中有哪些方法上由@Test方法
        junit就会让Test注解执行该方法
    3. junit不知道spring框架
        在执行测试方法的时候，junit根本不知道由spring框架
        所以不会读取配置文件/创建spring容器

    4. 当测试方法执行时，没有IoC容器，就算写了@Autowired注解，也无法注入

    5. 解决方式    
        1. 导入spring整合test的jar包
        2. 使用junit的main方法替换为spring提供的main方法
            1. @Runwith
                * 作用：改变junit的main方法，使用spring框架提供的main方法，可以创建容器
                * 替换的方法的类的字节码
        3. 告诉spring运行器，spring和IoC容器的创建基于xml还是注解
            2. @ContextConfiguration
                * 作用：指定spring和IoC容器的创建基于xml还是注解
                * 参数：
                    locations : 指定xml文件的位置，加上classpath关键字，表示在类路径下
                    classes: 指定配置类位置，字节码文件

    6. 出现问题
        1. spring框架的5.x版本整合junit必须在4.12版本以上
        2. spring-context以及spring-test的版本号要一致
        3. 如果一直无法导入jar包，可以先将本地maven仓库对应的jar包删除，重新导入坐标</code></pre><h2 id="spring的AOP"><a href="#spring的AOP" class="headerlink" title="spring的AOP"></a>spring的AOP</h2><h3 id="完善account的案例"><a href="#完善account的案例" class="headerlink" title="完善account的案例"></a>完善account的案例</h3><h4 id="进行账户之间的转账"><a href="#进行账户之间的转账" class="headerlink" title="进行账户之间的转账"></a>进行账户之间的转账</h4><pre><code>1. 增加新的转账方法
2. 防止转账异常，应该在持久层增加事务控制
3. 将事务控制放在业务层控制
4. 增加数据库连接工具类
5. 为了保证每次连接都只有一个事务控制，将连接和线程绑定
6. 增加事务管理工具类 
7. 改变连接池对象，增加数据注入

增加很多冗余代码，配置文件变得更为复杂</code></pre><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><pre><code>1. 优势
    * 字节码随用随创建，随用随代理
    * 在不改变源码的时候对方法进行增强</code></pre><h4 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><pre><code>1. 涉及的类
    * Proxy类
    * JDK官方

2. 创建代理对象的方法
    * Proxy.newProxyInstance()

3. 要求
    * 被代理对象至少要实现一个接口，如果没有，不能使用

4. newProxyInstance()的参数
    * ClassLoader:类加载器
        用于加载代理对象的字节码，和被代理对象使用相同的类加载器：固定写法

    * Class[]:字节码数组
        用于指定代理和被代理对象实现相同的方法，代理谁就写谁的接口：固定写法

    * InvacationHandler
        用于指定增强的代码
        让我们写任何实现代理，一般在某个实现方法上进行改变
        一般情况下，为匿名内部类，但是不是必须的
        此接口的实现类，都是谁用谁写

5. InvacationHandler的实现方法的参数</code></pre><blockquote>
<pre><code>实现类中需要重写invoke方法,执行被代理对象的任何方法都会经过该方法
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
   return null;
 }
    * proxy : 被代理对象的引用
    * method : 当前执行的方法
    * args : 当前方法执行的参数
    * 返回类型：和被代理对象的相同方法有相同的返回值类型</code></pre></blockquote>
<h4 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h4><pre><code>1. 导入jar包
    cglib包

2. 涉及的类
    * Enhancer类
    * 第三方cglib库

3. 创建代理对象的方法
    * Enhancer.create()方法

4. create方法的参数
    * Class:被代理对象的字节码
    * Callback:
        * 用于提供增强的方法
         * 如何代理对象，该接口的实现类，通常情况下为匿名内部类，但不是必须的
         * 此接口的方法都是谁用谁写
         * 实现该接口的子接口的实现类，MethodInterceptor方法拦截器

5. MethodInterceptor方法的参数</code></pre><blockquote>
<pre><code>方法的重写
@Override
public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
    return null;
}
参数：
    * 执行被代理对象的方法都经过该方法
    * @param o 被代理对象
    * @param method 当前执行的方法
    * @param objects 当前方法执行的对象
    *                和基于接口的方法的invoke参数相同
    * @param methodProxy 当前执行方法的代理对象
    * @return 和当前方法的返回值类型相同
    * @throws Throwable    </code></pre></blockquote>
<h4 id="动态代理在案例中的使用"><a href="#动态代理在案例中的使用" class="headerlink" title="动态代理在案例中的使用"></a>动态代理在案例中的使用</h4><pre><code>1. 创建代理工厂类，在获取AccountService的基础上，对原有的方法进行增强，增加事务控制</code></pre><blockquote>
<pre><code>public class BeanFactory {
    private IAccountService accountService;
    private TransactionManager transactionManager;</code></pre></blockquote>
<pre><code>public void setTransactionManager(TransactionManager transactionManager) {
    this.transactionManager = transactionManager;
}</code></pre><blockquote>
</blockquote>
<pre><code>public final void setAccountService(IAccountService accountService) {
    this.accountService = accountService;
}</code></pre><blockquote>
</blockquote>
<pre><code>/**
 * 获取代理对象的返回方法
 * @return
 */
public IAccountService getAccountService(){
    return (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(),
            accountService.getClass().getInterfaces(), new InvocationHandler() {
                /**
                 * 增强方法,对事务进行增强
                 */
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    Object rtValue = null;
                    try {
                        //1.开启事务
                        transactionManager.beginTransaction();
                        //2.执行操作
                        rtValue = method.invoke(accountService,args);
                        //3.提交事务
                        transactionManager.commitTransaction();
                        //4.返回结果
                        return rtValue;
                    } catch (Exception e) {
                        //5.回滚事务
                        transactionManager.rollbackTransaction();
                        throw new RuntimeException(e);
                    } finally {
                        //6.释放资源
                        transactionManager.releaseTransaction();
                    }
                }
           });
     }
  }

2. bean.xml的配置
    * 增加新的bean对象，beanFactory
    * 使用工厂的方法，创建代理类对象，由于代理类对象的数据类型和被代理对象的数据类型相同，在测试的时候需要对注入的数据进行指定</code></pre><p><img src="/2020/09/09/spring/proxy.png" alt="代理类对象的配置文件"></p>
<pre><code>3. 测试类</code></pre><p><img src="/2020/09/09/spring/proxy_test.png" alt="动态代理的测试类"></p>
<h3 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h3><pre><code>1. Aspect Oriented Programming:面向切面编程
    通过预编译和运行期动态代理的方式，实现程序功能的统一维护的一种技术。AOP是OOP编程的延续，是函数式编程的一种衍生泛型，可以使用AOP对业务逻辑进行隔离，降低程序之间的耦合性，提高代码的可重用率。

    简单来说，将重复的代码抽取出来，在需要使用的时候，通过动态代理的方式，在不修改源码的基础上，对已有的方法进行增强。

2. AOP的优势
    1. 作用
        * 在程序的运行期间不改变源码的基础上，对已有的方法进行增强

    2. 优势
        * 减少重复代码
        * 提高开发效率
        * 方便维护

3. 实现方式
    动态代理
    spring会根据是否实现了接口，动态的选择实现代理的方式

4. AOP的相关术语
    * Joinpoint(连接点)：
        所谓连接点是指那些被拦截到的点，在spring中，只支持对方法类型的连接点。
        （业务层接口中的所有方法），连接业务和增强方法的点

    * Pointcut(切入点)：
        被增强的方法，叫做切入点，我们对于哪些joinpoint方法进行增强的定义

    切入点都是连接点，但不是所有的连接点都是切入点

    * Advice(通知/增强):
        拦截到Joinpoint之后所作的事情叫做通知。
        通知的类型：
            前置通知，后置通知，异常通知，最后通知，环绕通知</code></pre><p><img src="/2020/09/09/spring/advice.png" alt="advice_types"></p>
<pre><code>    * Target(目标对象)：
        代理的目标对象，即被代理对象

    * Weaving(织入)：
        把增强应用到目标对象来创建新的代理对象的过程。
        spring采用动态代理技术进行织入

    * Proxy(代理)：
        一个类被AOP织入后，产生一个代理对象

    * Aspect(切面)：
        切入点和通知的结合，切入点和通知的有序组合
5. 明确
    1. 开发阶段：
        核心业务代码，大部分程序员
        把公共代码抽取出来，制作成通知（最后才做）
        在配置文件中，声明切入点和通知的关系，即切面，

    2. 运行阶段：
        spring框架监控切入点的执行，一旦检测到切入点方法正在执行，则立即使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理的对应位置，将通知的功能织入，完成代码的逻辑运行。</code></pre><h3 id="基于XML的AOP配置"><a href="#基于XML的AOP配置" class="headerlink" title="基于XML的AOP配置"></a>基于XML的AOP配置</h3><pre><code>1. 配置步骤
    1. 把通知的bean交给spring来管理（由spring来统一控制）
    2. 使用aop:config标签表明开始aop配置,开始配置
    3. 使用aop:aspect:配置切面
          id：给切面提供唯一属性
          ref:通知类的bean的id

    4. 在aop:aspect标签的内部使用对应的标签配置通知的类型
         现在的示例的通知类型是printlog方法在切入点的执行，为前置类型
            aop:before表示配置前置通知
                  method属性用于指定那个方法是前置通知

    5. pointcut属性：指定切入点表达式，该表达式的含义：对业务层的那些方法增强
        写法；关键字：execution(表达式)
          表达式：
              访问修饰符 返回值 包名.包名...类名.方法名（参数列表）
          标准表达式：
              execution(public void com.spring_AOP_xml.service.impl.AccountServiceImpl.saveAccount())</code></pre><p><img src="/2020/09/09/spring/xml_AOP.png" alt="XML配置AOP"></p>
<pre><code>2. 切入点表达式的化简
    1. 通配表达式写法：* *..*.*(..),所有包下的方法都被增强
    * 步骤
        public void com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        1. 访问修饰符可以省略：
            void com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        2. 返回值类型可以使用通配符*代替：
            * 
    com.spring_AOP_xml.service.impl.IAccountServiceImpl.saveAccount()
        3. 包名可以使用*.来代替，有几级包，需要写几个 
            * *.*.*.*.IAccountServiceImpl.saveAccount()
            使用*..可以表示当前包和子包，代表所有的包
        4. 类名和方法名可以使用*来表示
            * *..*.*()
        5. 参数：
            基本数据类型：直接写类型  int
            引用数据类型: 包名.类名  java.lang.String
            可以使用*来代表有无参数
                * *..*.*()和* *..*.*(*)不一样
            可以使用 ..来表示有无参数
        所以：
            * *..*.*(..):表示对所有类上的所有方法都进行增强

    2. 开发中：对业务层上的所有方法都进行增强
        * com.spring_AOP_xml.service.impl.*.*(..)

    3. 通用切入点表达式简化最终版：
        aop:pointcut标签：写在&lt;aop:aspect&gt;标签内部，但只能在当前标签内部使用，也可以写在外部，所有切面都可以使用，此时必须出现在切面之前
            id 切入点的唯一表示 
            expression：指定表达式内容
          &lt;aop:pointcut id=&quot;pc1&quot; expression=&quot;execution(* com.spring_AOP_xml.service.impl.*.*(..))&quot;/&gt;

        使用方式：
            &lt;aop:after method=&quot;printLog&quot; pointcut-ref=&quot;pc1&quot;/&gt;

3. 通知的类型（advice）
    前置通知：切入点方法执行之前
    后置通知：切入点方法正常执行之后执行
    异常通知：切入点方法异常的时候执行
    最终通知：无论怎样都会执行

    后置通知和异常通知只会执行一个</code></pre><p><img src="/2020/09/09/spring/advice_types.png" alt="通知类型"></p>
<pre><code>环绕通知：
    * 问题：
        在配置环绕通知之后，业务层方法没有执行，环绕通知执行了
    * 分析：
        没有对切入点的方法的明确调用
    * 解决：
        spring提供了一个接口，ProceedingJoinPoint的方法中proceed(),明确切入点方法的调用，该方法可以传入环绕通知参数，在程序执行期间，spring框架会为我们创建实现类。</code></pre><p><img src="/2020/09/09/spring/around_advice.png" alt="aroundadvice"></p>
<pre><code>* 环绕通知是spring框架为我们提供的一种方式：可以手动控制增强代码执行的方式</code></pre><h3 id="基于注解的AOP配置"><a href="#基于注解的AOP配置" class="headerlink" title="基于注解的AOP配置"></a>基于注解的AOP配置</h3><pre><code>1. 加入context扫描
2. 配置注解产生对象
3. 改变增强类的信息，切面的方法
4. 在bean.xml中增加开启注解配置AOP的标签
    &lt;aop:aspectj-autoproxy/&gt;:有这个标签才使用注解配置AOP</code></pre><p><img src="/2020/09/09/spring/AOP_anno.png" alt="通知和切面类注解">    </p>
<h2 id="JdbcTemlate"><a href="#JdbcTemlate" class="headerlink" title="JdbcTemlate"></a>JdbcTemlate</h2><h3 id="spring中的JdbcTemplate"><a href="#spring中的JdbcTemplate" class="headerlink" title="spring中的JdbcTemplate"></a>spring中的JdbcTemplate</h3><pre><code>1. 概念    
    * spring框架的提供的一个对象，是对原始Java API的简单封装，spring为我们提供了很多操作模板类。
    * 操作关系型数据库：
    * 操作nosql数据库
    * 操作消息队列:

    使用的时候需要导入spring-jdbc-5.1.10.RELEASE.jar
                    spring-tx-5.1.10.RELEASE.jar(事务相关)

2. 作用
    * 用于和数据库进行交互的，实现数据的CRUD

3. 如果重复的代码过多
    可以抽取重复代码，形成父类，使AccountDaoImpl继承该父类，也可以实现Dao的实现类</code></pre><blockquote>
<p>   Dao的两种实现方式:<br><img src="/2020/09/09/spring/dao_xml.png" alt="dao的xml配置方式"><br><img src="/2020/09/09/spring/dao_anno.png" alt="dao的annotation配置方式"></p>
</blockquote>
<h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h2><h3 id="spring的事务"><a href="#spring的事务" class="headerlink" title="spring的事务"></a>spring的事务</h3><pre><code>1. 明确
    * Java EE体系进行开发，事务处理位于业务层，spring提供分层设计业务层的事务处理方法
    * spring框架为我们提供一组事务控制的接口，位于spring-tx-5.1.10.RELEASE.jar
    * spring的事务控制基于AOP的，可以使用配置的控制和编程，主要使用配置事务

2. 事务API
    * platformTransactionManager</code></pre><h3 id="基于xml的事务控制"><a href="#基于xml的事务控制" class="headerlink" title="基于xml的事务控制"></a>基于xml的事务控制</h3><pre><code>1. 使用
    1. 配置事务管理器（DataSourceTransactionManager）
    2. 配置事务通知(tx:advice)
          此时需要导入事务的约束,tx的名称约束，同时也需要aop的支持
          使用tx:advice配置事务通知 
            id:唯一标志 
            transaction-manager:提供事务管理器使用
    3. 配置aop的通用切入点表达式
    4. 建立事务通知和切入点表达式的关联
    5. 配置事务的属性：事务的通知tx:advice的内部
        * isolation: 指定事务的隔离级别，默认值式DEFAULT,
        * propagation: 事务的传播行为REQUESTED 表示一定会有事务，增删改的选择，查询可以选择SUPPORTS
        * read-only: 事务是否只读，默认为false
        * time-out: 事务的超时时间,默认-1，表示永不超时，如果指定，以秒为单位
        * rollback-for: 指定一个异常，当产生该异常时，事务回滚，产生其他异常，事务不回滚，没有默认值，表示任何异常都会回滚
        * no-rollback-for：指定一个异常，当产生该异常时，事务不回滚，产生其他异常，事务回滚，没有默认值，表示任何异常都会回滚

2. 使用实例</code></pre><p><img src="/2020/09/09/spring/tran_xml.png" alt="基于xml的声明式事务"></p>
<h3 id="基于注解的事务配置"><a href="#基于注解的事务配置" class="headerlink" title="基于注解的事务配置"></a>基于注解的事务配置</h3><pre><code>1. 步骤
    1. 配置事务管理器（DataSourceTransactionManager）
    2. 开启spring对注解事务的支持（tx:annotation-driven）
    3. 使用注解@transactional对需要事务的地方进行定义
        xml中的事务属性，均可以在@Transactional的属性中配置

    如果查询和增删改的方法数量差不多，需要对增删改的方法单独配置事务支持

2. 实例</code></pre><p><img src="/2020/09/09/spring/tran_anno.png" alt="基于注解的声明式事务"></p>
<h3 id="使用纯注解的事务配置"><a href="#使用纯注解的事务配置" class="headerlink" title="使用纯注解的事务配置"></a>使用纯注解的事务配置</h3><p><img src="/2020/09/09/spring/tx_without_xml.png" alt="纯注解的声明式事务"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2020/09/18/springMVC/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><pre><code>1. B/S，浏览器/服务器模式的开发中，服务端程序一般分为三层，展示层，业务层和持久层。
    * 展示层：WEB层，用来与客户端进行数据交互的，表现层采用MVC的设计
    * 业务层：处理业务逻辑
    * 持久层：与数据库进行交互

2. MVC?
    MVC(Model View Controller):模型视图控制器，一种设计模式
    * Model: javabean,通常代指数据模型，用于封装数据
    * View:  jsp,jsp或者html,用于展示数据
    * Controller: servlet,处理用户交互的部分，处理程序逻辑的部分

3. SpringMVC框架
    1. 优势：

4. SpringMVC和Struts2的区别</code></pre><h3 id="SpringMVC的入门案例"><a href="#SpringMVC的入门案例" class="headerlink" title="SpringMVC的入门案例"></a>SpringMVC的入门案例</h3><pre><code>1. 项目环境搭建
    1. 选择maven工程的archetype
    2. 选择webapp模板
    3. 填写项目名称等信息
    4. 添加archetypeCagalog internal加快项目创建的速度
    5. 使用webapp在main目录下创建java和resources目录，并使用mark directory as声明</code></pre><blockquote>
<p><img src="/2020/09/18/springMVC/maven_createproject_quickstart.png" alt="maven_createproject_quickstart"></p>
</blockquote>
<blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/change_directory.png" alt="change_directory"></p>
<pre><code>2. 配置MVC项目的步骤
    1. 配置前端控制器，在servlet上配置控制器,主要是访问路径以及拦截</code></pre><blockquote>
</blockquote>
<pre><code>&lt;!-- 配置前端控制器 --&gt;
&lt;servlet&gt;
  &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre><blockquote>
<pre><code>&lt;!-- 配置过滤器 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;:初始化参数
              &lt;param-name&gt;encoding&lt;/param-name&gt;
              &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;</code></pre></blockquote>
<pre><code>2. 配置TomCat服务器
    配置项目路径，端口等服务器信息配置</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/quickstart_tomcat.png" alt="tomcat设置"></p>
<pre><code>3. 配置视图解析器
    在项目配置文件中配置视图解析器，配置前缀路径以及后缀文件名</code></pre><h3 id="SpringMVC实例解析"><a href="#SpringMVC实例解析" class="headerlink" title="SpringMVC实例解析"></a>SpringMVC实例解析</h3><pre><code>1. SpringMVC的流程的说明
    * 启动服务器，加载配置文件
        1. DispacherServet被创建
        2. springmvc.xml被加载
        3. HelloController被加载到容器
        4. 开启注解扫描的包，配置视图解析器，开启MVC注解
    * 发送http请求，后台处理</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/quickstart_1.png" alt><br><img src="/2020/09/18/springMVC/quickstart_2.png" alt></p>
<pre><code>2. springMVC的三大组件(容器)
    * 处理器映射器：HandlerMapping
    * 处理器适配器：HandlerAdapter
    * 视图解析器：ViewResolver

    在开启springMVC的注解时，会自动加载处理器映射器，处理器适配器</code></pre><h2 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h2><h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><pre><code>1. @RequestMapping：建立请求和方法之间的关联
    path,value:请求路径的字符串

2. 使用位置
    * 放在方法上，可以直接使用路径来请求数据，二级目录
    * 放在类上，类上的路径为一级目录，可以先访问一级目录再访问二级目录的方法</code></pre><p><img src="/2020/09/18/springMVC/requestmapping.png" alt></p>
<pre><code>3. RequestMapping的属性: 任意两个属性之间是&amp;&amp;的关系
    1. value,path: 互为别名，都是指定请求的路径,请求的URL
    2. mathod: 用于指定请求的方法，method={RequestMethod.GTE,RequestMethod.POST}等
    3. params: 指定限制请求参数的条件，支持简单的表达式，要求请求参数中的key和value必须和配置一样
        * params={&quot;accountName&quot;},请求参数中必须要有accountName
        * params={&quot;money!100&quot;},请求参数money不能是100
    4. headers: 发送的请求中必须包含的请求头</code></pre><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><pre><code>1. 含义
    把请求中指定名称的参数传给控制器的形参（形参赋值）

2. 使用位置
    * 只能定义在参数上
    * 在请求的参数名称和方法上的形参名称不一样时，使用注解进行映射

3. 属性
    1. name,value: 请求中的参数名称
    2. required: 默认true，请求中的参数名称必须与name属性的值相同</code></pre><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><pre><code>1. 含义
    用于获取请求体内容，直接使用得到的是 key=value&amp;key=value 的数据    
    get请求方式不适用，参数不在请求体

2. 属性
    required:是否必须要有请求体，默认为true。当取值为true时，使用get方式报错，为false时，使用get获取数据为null

3. 使用
    注解定义在参数上
    直接注解将请求体内部的数据以键值对的方式赋给指定的形参</code></pre><h4 id="PathVarible"><a href="#PathVarible" class="headerlink" title="@PathVarible"></a>@PathVarible</h4><pre><code>1. 含义
    绑定url中的占位符，url中有/delete/{id},{id}就是占位符

2. 属性
    * value: 指定占位符的名称
    * required: 必须包含占位符

3. 使用
    * 只能作用在参数上
    * value的名称必须和访问路径下的占位符的名称一致
    * 访问时只需要在访问路径的占位符上添加数据就可以了</code></pre><h5 id="RESTful编程风格"><a href="#RESTful编程风格" class="headerlink" title="RESTful编程风格"></a>RESTful编程风格</h5><pre><code>1. Representational State Transfer：
    表述性状态转换

2. 请求地址相同，但是具体的请求方法不同
    * 获取：GET
    * 创建：POST
    * 更新：PUT
    * 删除：DELETE</code></pre><h5 id="HiddentHttpMethodFilter"><a href="#HiddentHttpMethodFilter" class="headerlink" title="@HiddentHttpMethodFilter"></a>@HiddentHttpMethodFilter</h5><pre><code>1. 说明
    浏览器form表单只支持GET,POST请求，DELETE以及PUT不支持，这个过滤器可以将浏览器的请求改为指定的请求方式</code></pre><h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h4><pre><code>1. 说明
    获取请求头

2. 属性
    * name,value: 指定需要获取请求头中的那个属性名称
    * required: 默认true,是否必须有此属性名称

3. 使用
    * 只能作用在参数上
    * 必须指定想要获取的标签的名称</code></pre><h4 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h4><pre><code>1. 说明
    把指定的Cookie名称的值传入控制器方法参数

2. 属性
    * value: 指定Cookie的名称
    * required: 是否必须有此cookie

3. 使用
    * 作用在参数上
    * 需要指定cookie的key</code></pre><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h4><pre><code>1. 说明
    可以出现在方法和参数上
    * 方法：当前方法会在控制器的方法执行之前先执行，可以修饰没有返回值的方法，也可以修饰有返回值的方法
    * 参数：获取指定的参数给属性赋值

2. 属性
    * value: 用于获取数据的key,数据类型可以是JavaBean,也可以是集合

3. 使用
    * 当表单提交的字段不完整，可以保证没有提交的数据使用数据库原本的字段数据    </code></pre><h4 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h4><pre><code>1. 说明
    用于多次执行控制器方法之间的参数共享

2. 属性
    * value: 指定存入的属性名称
    * type: 指定存入的数据类型

3. 使用
    * 只能作用在类上
    * 可以借助Model来将数据存入Request域中</code></pre><h2 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>1. 绑定机制
    1. 表单提交的数据都是key=value格式的，username=hh&amp;password=oooo
    2. SpringMVC的参数绑定过程是把表单提交的数据作为控制器中的参数进行绑定的
    3. 表单的name和参数的名称必须是一样的（不一致可以使用@RequestParam）

2. 支持的数据类型
    1. 基本数据类型和字符串类型
    2. 实体类型（javaBean）
    3. 集合数据类型（List,Map）

3. 基本数据类型和字符串类型
    * 表单中的name属性和参数列表的名称一致，可以直接进行封装
    * 表单中的name属性和参数列表的名称不一致

4. 实体类型
    1. 简单的JavaBean
        * 表单中的name属性和实体类的属性名称一致，框架会自动封装
        * 使用@RequestParam进行映射

    2. 包含其他的JavaBean引用
        * 将引用的其他JavaBean的属性名称连同该对象的属性作为表单的name属性

5. 集合数据类型
    将集合的引用以及属性进行数据封装</code></pre><p><img src="/2020/09/18/springMVC/connection.png" alt="集合的参数封装"></p>
<h4 id="数据转换器"><a href="#数据转换器" class="headerlink" title="数据转换器"></a>数据转换器</h4><pre><code>1. 说明
    表单传输的数据都是字符串类型，SpringMVC框架进行了数据类型转换
    string-&gt; Integer, Double,...
    字符串转换为Date时，格式不正确，需要显式指定自定义类型转换器

2. 使用接口
    将S类型的数据转换为T类型
    public interface Converter&lt;S,T&gt;{
        T converter(S); S:source,T:target
    }
    将指定的数据类型进行转换，实现converter

3. 使用步骤
    1. 编写Converter接口的实现类，实现converter方法
    2. 配置自定义类型转换器
        * springMVC项目配置文件中配置，将自定义配置类加入ConversionServiceFactortBean中
    3. 配置转换器服务</code></pre><p><img src="/2020/09/18/springMVC/defaultconversion.png" alt="自定义类型转换器"></p>
<h2 id="Servlet-API"><a href="#Servlet-API" class="headerlink" title="Servlet API"></a>Servlet API</h2><h3 id="获取原生的Servlet-API"><a href="#获取原生的Servlet-API" class="headerlink" title="获取原生的Servlet API"></a>获取原生的Servlet API</h3><pre><code>1. 获取方式
    使用参数获取的方式，将希望获取到的对象作为参数绑定到路径

2. 实例
    @RequestMapping(&quot;/servletAPI&quot;)
    public String testServletAPI(HttpServletRequest request){

    }</code></pre><h2 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><pre><code>因为配置了视图解析器，包含String类型返回值，会自动解析我们配置的静态资源，会到指定的路径寻找返回值名称相同的文件
1. 字符串代表一个静态或者动态页面
2. 在方法中获取需要的数据，使用Request域来获取，将其填充在页面上显示</code></pre><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><pre><code>1. 默认值，返回一个和当前方法相同的访问路径的一个jsp文件</code></pre><p><img src="/2020/09/18/springMVC/void_01.png" alt="默认返回值void"></p>
<pre><code>2. 可以使用servlet的请求转发，重定向
    * 转发：request.getRequestDispatcher(&quot;/WEB-INF/pages/xx.jsp&quot;).forward(req,resp);
        自已手动转发的路径必须写当前项目的全路径，视图解析器不再自动寻找路径

    * 重定向：response.sendRedirect(req.getContextPath()+&quot;/WEB-INF/pages/xx.jsp&quot;)

    转发在当前的web项目内部进行，不需要带项目名称；重定向，不知道项目路径，需要加上项目路径

3. 直接进行响应
    直接使用输出流来响应数据</code></pre><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><pre><code>1. 说明
    ModelAndView对象为spring提供的一个对象，可以用来调整具体的JSP视图

2. 使用
    创建ModelAndView对象，使用addObject(key,Object)添加数据
    使用setViewName()指定返回的页面

    返回值String类型的与ModelAndView的实现机制相同，String基于ModelAndView来实现的</code></pre><p><img src="/2020/09/18/springMVC/model.png" alt></p>
<h3 id="使用关键字来进行转发和重定向"><a href="#使用关键字来进行转发和重定向" class="headerlink" title="使用关键字来进行转发和重定向"></a>使用关键字来进行转发和重定向</h3><pre><code>1. 需要使用视图解析器来进行资源的获取
    如果没有配置视图解析器，需要手动配置转发和重定向的路径

2. 基于返回值为字符串的方式
    * &quot;forward:success&quot; : 转发到配置好的路径下的指定后缀的页面
    * &quot;rediect:success&quot; ：重定向

3. 注意
    使用关键字，会使用UrlBaseViewReslover进行视图解析，会使用到配置的视图解析器</code></pre><h3 id="JSON数据：ResponseBody响应"><a href="#JSON数据：ResponseBody响应" class="headerlink" title="JSON数据：ResponseBody响应"></a>JSON数据：ResponseBody响应</h3><h4 id="过滤静态资源"><a href="#过滤静态资源" class="headerlink" title="过滤静态资源"></a>过滤静态资源</h4><pre><code>1. 问题
    在配置前端控制器的时候，使用了通配符 / 来进行URL拦截，DispatcherServlet拦截了除了.jsp之外的所有资源，静态资源也会被拦截，从而不能使用。如果希望不拦截静态资源，可以再springmvc.xml中配置。

2. 解决</code></pre><blockquote>
<pre><code>&lt;!-- 配置静态资源过滤: js下的文件不进行拦截 --&gt;
&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt; &lt;!-- js文件 --&gt;
&lt;mvc:resources mapping=&quot;/images/**&quot; location=&quot;/images/&quot;/&gt;
&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot;/&gt;</code></pre></blockquote>
<pre><code>location: webapp目录下的所有指定文件
mapping: 表示以/static开头的所有的请求路径</code></pre><h4 id="响应json格式数据"><a href="#响应json格式数据" class="headerlink" title="响应json格式数据"></a>响应json格式数据</h4><pre><code>1. 导入必须的包
    jackson-databind jackson-core jackson-annotations,可以由框架进行数据的赋值

2. 使用@ResponseBody
    将查询到的数据封装到json格式的页面中，完成异步请求，响应json格式数据</code></pre><h3 id="响应数据总结"><a href="#响应数据总结" class="headerlink" title="响应数据总结"></a>响应数据总结</h3><table>
<thead>
<tr>
<th align="center">返回值类型</th>
<th align="center">跳转页面</th>
<th align="center">要求</th>
<th align="center">使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String</td>
<td align="center">指定的返回字符串表示的页面</td>
<td align="center">使用视图解析器配置需要解析的页面</td>
<td align="center">在对应的文件夹下创建和返回值名称相同的页面</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">默认返回和访问路径相同的目录结构下的文件</td>
<td align="center">可以使用重定向和转发，Model来进行页面跳转，或者直接响应数据</td>
<td align="center">配合转发和重定向来使用</td>
</tr>
<tr>
<td align="center">ModelAndView</td>
<td align="center">使用setViewName()指定跳转的页面</td>
<td align="center">需要使用addAttribute()添加元素</td>
<td align="center">ModelMap</td>
</tr>
<tr>
<td align="center">关键字字符串</td>
<td align="center">使用关键字 redirect forward进行转发和重定向</td>
<td align="center">在返回值为字符串的格式下</td>
<td align="center">和String类似</td>
</tr>
<tr>
<td align="center">json格式数据</td>
<td align="center">返回json格式的数据</td>
<td align="center">使用第三方库来进行解析和包装</td>
<td align="center">使用@ResponseBody</td>
</tr>
</tbody></table>
<pre><code>* ModelAndView和String的实现机制类似
* 使用转发和重定向可以访问的资源范围不仅局限在定义的资源文件
* void的返回类型，可以使用上述三种方式来响应数据
* json格式的数据应该和ajax(异步 JavaScript XML)配合来使用</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="传统的文件上传"><a href="#传统的文件上传" class="headerlink" title="传统的文件上传"></a>传统的文件上传</h3><pre><code>1. form表单的要求
    * enctype的属性要求，multipart/form-data
    * method：post</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/file_upload.png" alt="文件上传1"></p>
<pre><code>2. 解析工具
    * 第三方jar包：commons-fileupload-1.4,commons-io-2.6</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/file_pom.png" alt="导入jar包"></p>
<pre><code>3. 步骤
    将本地文件上传至服务器
    * 编写文件上传的jsp文件
    * 导入第三方库，处理上传后的文件
    * 一旦提交表单，所有的数据会存在于request对象的域中，将数据传送给方法，进行处理</code></pre><blockquote>
<pre><code>//1.指定文件上传位置
    String path = request.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);
    System.out.println(path);
    //2.判断文件路径是否存在
    File file = new File(path);
    if (!file.exists()){
        //文件不存在，创建目录
        file.mkdirs();
    }
    //3.解析request对象，获取上传文件项
    DiskFileItemFactory fileItemFactory = new DiskFileItemFactory();
    ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);
    List&lt;FileItem&gt; fileItems = null;
    //4.解析
    try {
        fileItems = servletFileUpload.parseRequest(request);
        //遍历
        for(FileItem item:fileItems){
            //判断当前的item是否为上传文件项
            if(item.isFormField()){
                //普通表单
            }else {
                //上传文件
                //获取上传文件的名称
                String name = item.getName();
                //设置文件名称唯一,防止相同的文件名产生的覆盖
                String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
                name = uuid+&quot;_&quot;+name;
                //完成上传,指定路径上传文件
                item.write(new File(path,name));
                //删除临时文件
                item.delete();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }</code></pre></blockquote>
<h3 id="springMVC的文件上传"><a href="#springMVC的文件上传" class="headerlink" title="springMVC的文件上传"></a>springMVC的文件上传</h3><pre><code>1. 说明
    * springMVC框架提供了MultipartFile对象，该对象表示要上传的文件，要求变量名称必须和表单file标签的name属性名称相同
    * 由前端控制器获取请求，将请求传送给文件解析器来进行request对象的解析，获取文件上传项，再由控制器将获取到的文件上传项作为参数绑定到对应的方法上，在方法中只需要进行文件的上传就可以，不需要关注文件的解析和获取工作
    * 注意：
        参数绑定：方法的参数必须和file的name属性相同</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/springmvc_upload.png" alt="springMVC文件上传的原理"><br><img src="/2020/09/18/springMVC/springmvc_upload1.png" alt="springMVC文件上传的部分源码"></p>
<pre><code>一旦配置上传文件的大小，不能超过限制</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/springmvc_upload_error.png" alt="springMVC文件大小上传限制"></p>
<pre><code>2. 步骤
    * 书写文件上传表单
    * 配置文件解析器
        CommonsMultipartResoler,其中id属性必须为 multipartReslover
            可以进行依赖注入

    * 方法书写</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/springmvc_upload2.png" alt="springMVC文件上传"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>springMVC的框架只是将解析文件的过程进行了封装，本质上还是使用FileItemFactory等进行文件解析，在方法中可以直接调用上传文件项

1. 通用上传文件步骤
    1. 获取上传文件目录，可以使用file.mkdirs()进行创建
    2. 对request域进行文件解析，获取文件项(FileItem)[文件解析器]
    3. 生成唯一Id,防止文件覆盖，UUID.randomUUID().toString().replace(&quot;_&quot;,&quot;&quot;);
    4. 文件上传，transferTo(new File(path,name));将文件上传到指定的路径下，生成指定文件名称的文件
    5. 清理临时文件</code></pre><h3 id="跨服务器方式的文件上传"><a href="#跨服务器方式的文件上传" class="headerlink" title="跨服务器方式的文件上传"></a>跨服务器方式的文件上传</h3><pre><code>1. 分服务器的目的
    不同的功能服务器将其分开，方便开发
        * 应用服务器
        * 数据库服务器
        * 缓存服务器

2. 步骤
    * 导入跨服务器传输文件的第三方jar包，jersey-core,jersey-client
    * 编写业务程序
        1. 确定上传的文件路径，文件服务器上的路径
        2. 获取上传文件项的UUID,生成唯一ID
        3. 获取客户端对象（客户端-服务器的方式建立连接）
            Client client = Client.create();
        4. 建立连接，
            WebResource resource = client.resource(path);
        5. 上传文件
            resource.put(upload.getBytes());</code></pre><p><img src="/2020/09/18/springMVC/file_upload3.png" alt="跨服务器上传"></p>
<pre><code>3. 出现的错误
    1. 500：Method Not Allowed
        可以在文件服务器的文件目录下建立文件夹改变Tomcat服务器的readonly属性，Tomcat服务器的安装目录下的conf文件中的web.xml，属性值改为false</code></pre><p><img src="/2020/09/18/springMVC/e1.png" alt></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><pre><code>Controller调用service,service调用dao,异常向上抛出，最终由DispatcherServlet找异常处理器进行处理。</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/error_process.png" alt="异常处理流程"><br><img src="/2020/09/18/springMVC/exception_1.png" alt="异常抛出演示"></p>
<h3 id="springMVC的异常处理"><a href="#springMVC的异常处理" class="headerlink" title="springMVC的异常处理"></a>springMVC的异常处理</h3><pre><code>1. 步骤
    * 编写自定义异常处理类 （提示信息）
    * 编写异常处理器，必须实现异常处理器接口，HandlerExceptionResolver
    * 配置异常处理器（决定跳转页面）
        在springmvc.xml中增加bean标签，将异常处理器加载到容器中</code></pre><p><img src="/2020/09/18/springMVC/exception_2.png" alt="异常抛出"></p>
<h2 id="拦截器（Interceptor）"><a href="#拦截器（Interceptor）" class="headerlink" title="拦截器（Interceptor）"></a>拦截器（Interceptor）</h2><pre><code>springMVC的拦截器和servlet的Filter过滤器的作用类似，用于对处理器（controller）进行预处理和后处理。
    Interceptor chain : 拦截器链，对一组拦截器按照一定的顺序进行访问

interceptor和filter的区别
* interceptor: 只能在springMVC中，在配置/*之后，只会拦截访问的控制器方法，如果访问的是jsp,css,html不会进行拦截
* filter: servlet规范的部分，所有的java web都可以使用，在配置之后，对所有要访问的资源进行拦截

编写拦截器必须实现 HandlerInterceptor接口</code></pre><h3 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h3><pre><code>1. 步骤
    * 编写自定义拦截器类（implements HandlerInterceptor）
    * 在容器中注册该拦截器类
    * 声明需要拦截的对象

2. 注册拦截器
    * 可以编写多个拦截器，构成拦截器链
    * &lt;mvc:mapping path=&quot;&quot;&gt;：指定要拦截的请求路径</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/inter_1.png" alt></p>
<pre><code>3. 拦截的方法</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/springMVC/inter_2.png" alt></p>
<pre><code>* preHandler: 预处理，在controller方法执行之前执行
    return true: 放行，继续执行后面的拦截器
    return false: 不放行，可以使用转发和重定向来进行页面跳转

* postHandler: 后处理，在controller方法执行结束，跳转页面之前执行

* afterCompletion: 页面执行结束后，执行这个方法</code></pre>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM</title>
    <url>/2020/09/18/ssm/</url>
    <content><![CDATA[<h2 id="SSM框架的整合"><a href="#SSM框架的整合" class="headerlink" title="SSM框架的整合"></a>SSM框架的整合</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>SSM,spring springmvc mybatis三大框架的整合，可以使用多种方式，这里使用xml+注解的方式</code></pre><h3 id="整合的思路"><a href="#整合的思路" class="headerlink" title="整合的思路"></a>整合的思路</h3><pre><code>1. 以spring框架为核心，进行其他的框架的整合(针对各个框架的使用范围进行整合)</code></pre><p><img src="/2020/09/18/ssm/ssm_1.png" alt></p>
<h4 id="导入的坐标版本"><a href="#导入的坐标版本" class="headerlink" title="导入的坐标版本"></a>导入的坐标版本</h4><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_version.png" alt="使用的坐标版本"></p>
<h4 id="日志文件的配置"><a href="#日志文件的配置" class="headerlink" title="日志文件的配置"></a>日志文件的配置</h4><pre><code>1. pom.xml
    * log4j
    * slf4j-api
    * slf4j-log4j12
        完成日志文件的配置，将标准日志转为log4j格式日志</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_log.png" alt="日志文件的配置"></p>
<pre><code>2. log4j.propreties配置文件</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_log2.png" alt="日志文件的配置"></p>
<h4 id="spring框架的配置"><a href="#spring框架的配置" class="headerlink" title="spring框架的配置"></a>spring框架的配置</h4><pre><code>1. pom.xml配置
    * spring-context: 容器，扫描数据
    * spring-aop
    * spring-tx
    * spring-test:单元测试
    * spring-jdbc
    * aspectjweaver:切入点，切面
    * jstl: Java EL表达式</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_spring1.png" alt="spring的配置1"></p>
<pre><code>2. applicationContext.xml的配置
    * 配置需要扫描的包，指定不需要扫描的MVC层的包，MVC的数据由springMV来进行数据扫描</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_spring2.png" alt="spring的配置2"></p>
<pre><code>3. 配置完上述的配置文件
    可以使用spring的注解，进行对象注册</code></pre><h4 id="springMVC的整合"><a href="#springMVC的整合" class="headerlink" title="springMVC的整合"></a>springMVC的整合</h4><pre><code>1. pom.xml配置
    * spring-web
    * spring-webmvc
    * servlet-api
    * jsp-api</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_springmvc1.png" alt="springmvc的配置"></p>
<pre><code>2. web.xml配置
    * DispatcherServlet：前端控制器
    * CharacterEncodingFilter: 字符编码过滤器

3. springmvc.xml配置
    * 开启注解扫描：controller由springmvc来进行扫描
    * 开启视图解析器：InternalViewResolver
    * 配置静态资源过滤：mvc:resources
    * 配置开启springmvc注解支持
    * 配置监听器</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/ssm_springmvc2.png" alt="springmvc的配置"></p>
<pre><code>4. spring整合springMVC
    在启动服务器的时候，加载web.xml文件的时候，只加载了springMVC的配置文件，没有读取spring的配置文件来进行容器的创建以及加载。

    使用监听器：ContextLoaderListener,来监听ServletContext实例的创建，一旦创建，就会扫描spring的配置文件，进行spring容器的创建

    监听器的默认配置文件：/WEB-INF/applicationContext.xml
        1. 在/WEB-INF/复制文件
        2. 使用&lt;context-param&gt;进行容器扫描路径的配置</code></pre><p><img src="/2020/09/18/ssm/ssm_listener.png" alt="spring整合springmvc"></p>
<pre><code>5. 监听器的配置
    使用spring框架的监听器，在创建ServletContext的时候，同时扫描spring的配置文件，可以通知框架注册实例，以供数据注入</code></pre><h4 id="MyBatis的整合"><a href="#MyBatis的整合" class="headerlink" title="MyBatis的整合"></a>MyBatis的整合</h4><pre><code>1. pom.xml文件的配置
    * mybatis
    * mysql-connector-java
    * c3p0

2. SqlMapConfig.xml配置
    * typeAlisaes：为实体类创建别名，使用package
    * 数据库连接环境
    * mappers: 配置映射文件

3. 整合思路
    * 将数据的DAO层的代理对象存入容器
    * 步骤
        1. 在applicationContext.xml文件编写使用MyBatis的文件步骤
        2. 编写数据库连接池bean对象
        3. 配置SqlSessionFactoryBean对象
        4. 配置扫描的映射文件所在的包

4. 出现的错误</code></pre><blockquote>
</blockquote>
<p><img src="/2020/09/18/ssm/erroer_1.png" alt="web.xml或使用此应用程序部署的jar文件中解析"><br><img src="/2020/09/18/ssm/error_2.png" alt="classnotfound:org.apache.jsp."></p>
<h4 id="spring的声明式事务控制"><a href="#spring的声明式事务控制" class="headerlink" title="spring的声明式事务控制"></a>spring的声明式事务控制</h4><pre><code>1. 配置事务管理器
2. 配置事务通知
    * 配置事务的使用位置，传播级别。。
3. 配置AOP
    * 配置切入点表达式
    * 配置事务</code></pre>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛云_Hexo</title>
    <url>/2020/05/12/%E4%B8%83%E7%89%9B%E4%BA%91-Hexo/</url>
    <content><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><pre><code>1. 注册七牛云,完成之后就可以进行创建空间，
2. 注意我们添加的资源为对象存储，访问控制为公开空间
3. 点击右上角进入密钥管理，复制当前使用的AK和SK，配置的时候会用得到</code></pre><h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h2><h3 id="2-1-安装插件，进入Hexo主目录，执行："><a href="#2-1-安装插件，进入Hexo主目录，执行：" class="headerlink" title="2.1. 安装插件，进入Hexo主目录，执行："></a>2.1. 安装插件，进入Hexo主目录，执行：</h3><pre><code>`npm install hexo-qiniu-sync --save`</code></pre><h3 id="2-2-配置站点文件-config-yml"><a href="#2-2-配置站点文件-config-yml" class="headerlink" title="2.2. 配置站点文件_config.yml:"></a>2.2. 配置站点文件_config.yml:</h3><blockquote>
<p>  #plugins:<br>      #- hexo-qiniu-sync<br>    qiniu:<br>      offline: false<br>      sync: true<br>      bucket: bucket_name<br>      access_key: AccessKey<br>      secret_key: SecretKey<br>      dirPrefix:<br>      urlPrefix: <a href="http://7xqb0u.com1.z0.glb.clouddn.com" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com</a><br>      local_dir: cdn<br>      update_exist: true<br>      image:<br>        folder: images<br>        extend:<br>      js:<br>        folder: js<br>      css:<br>        folder: css</p>
</blockquote>
<h3 id="2-3-参数"><a href="#2-3-参数" class="headerlink" title="2.3. 参数"></a>2.3. 参数</h3><ul>
<li><p>bucket ：修改为你刚才申请的七牛空间名称</p>
</li>
<li><p>access_key 、 secret_key : 上传密钥AccessKey、SecretKey。即3 第3步复制的AK和SK。</p>
</li>
<li><p>urlPrefix : 七牛空间地址的前缀。 重要！必填！ 因为现在七牛已经取消了二级域名，外链前缀类似设置中的 <a href="http://7xqb0u.com1.z0.glb.clouddn.com" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com</a> ，插件不能根据 bucket 自动生成外链前缀了。你可以进入自己创建的空间在域名设置中看到自己的七牛测试域名，也可以查看一个已上传的文件外链地址，确认前缀无误。这个参数的设置是保证解析成网页文件时，外链地址正确的关键之一！<br>  配置参数的说明：</p>
</li>
<li><p>offline ：是否离线。设置为 true 将在本地预览时使用本地地址渲染，省流量； false 将使用同步到七牛空间的静态资源渲染，方便检查资源链接是否正确。</p>
</li>
<li><p>sync ：是否同步到七牛，一般都是设置 true 啦</p>
</li>
<li><p>dirPrefix ：资源将上传到七牛空间的此目录下，可像我一样设置为空。该参数会影响外链的地址，如果设置为非空值，例如默认值 static ，则 urlPrefix 为保持一致需加上目录后缀 /static ，改为 <a href="http://7xqb0u.com1.z0.glb.clouddn.com/static" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com/static</a> 。</p>
</li>
<li><p>local_dir ：本地资源储存目录。在本例中，待上传的资源都储存在hexo主目录中的 cdn 文件夹（也就是与 source 目录平级）中。</p>
</li>
<li><p>update_exist ：设置为 true ，则会在文件更新之后重新上传并更新七牛空间上中的原有文件。</p>
</li>
<li><p>image/js/css ：子参数folder为不同静态资源种类的目录名称，一般不需要改动</p>
</li>
<li><p>image.extend ：使用 qnimg 标签引用图片的默认图片处理操作。可以使用 基本图片处理（imageView2）、高级图片处理（imageMogr2）、图片水印处理（watermark） 这三个图片处理接口，多个接口内容之间用 | 间隔。详见 七牛开发者中心-图片处理。</p>
</li>
</ul>
<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><pre><code>1.将图片上传到七牛云，查看照片获取照片的外链
2.在文章中引用照片外链，markdown格式:*![描述]（外链）*</code></pre><h2 id="4-感谢在使用七牛云时参考的大佬博客："><a href="#4-感谢在使用七牛云时参考的大佬博客：" class="headerlink" title="4. 感谢在使用七牛云时参考的大佬博客："></a>4. 感谢在使用七牛云时参考的大佬博客：</h2><ul>
<li><a href="http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/" target="_blank" rel="noopener">http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>

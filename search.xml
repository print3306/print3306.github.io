<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQL注入</title>
    <url>/2020/05/08/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="SQL注入问题"><a href="#SQL注入问题" class="headerlink" title="SQL注入问题"></a>SQL注入问题</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>在拼接sql语句时，有一些特殊的SQL关键字参于字符串的拼接，导致SQL语句的逻辑发生变化，可能会造成安全性问题</code></pre><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><pre><code>1. 输入 a&apos;or&apos;a&apos;=&apos;a,条件改变
2. sql:select * from db where name and password = &apos;a&apos;or&apos;a&apos;=&apos;a&apos;,查询所有数据

原SQL语句拼接为: 

    String sql = &quot;select id from db where username=&apos;&quot;+username+&quot;&apos; and password=&apos;&quot;+password+&quot;&apos;&quot;;

用户输入的帐号密码分别为:

请输入您的帐号:
11111
请输入您的密码:
a&apos;or&apos;a&apos;=&apos;a
组成的SQL语句: 
select id from db where username=&apos;1111&apos; and password=a&apos;or&apos;a&apos;=&apos;a；</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><pre><code>使用预编译SQL语句,进行参数的传递

更改执行环境：Statement

使用新的环境: PreparedStatement

在通过连接对象，获取一个预编译的SQL环境(PreparedStatement)时, 需要传递一个SQL语句 ! 
在这个语句中 可以出现? , ? 表示准备填充的参数值!

使用步骤: 
    1. 通过连接对象, 获得一个预编译的SQL执行环境

        PreparedStatement state = conn.prepareStatement(sql);

        例如: 
            String sql = &quot;select id from db where username=? and password=?&quot;;

            PreparedStatement state = conn.prepareStatement(sql);    

    2. 向预编译参数列表中传递值: 

        预编译的SQL语句中可以包含【多个问号】, 每一个问号表示一个需要传递的值 
        我们通过PreparedStatement它的setXxx方法,来完成参数的传递
            传递参数时, 需要指定问号的索引, 问号的索引从1开始            

        例如:
            state.setString(1,username);
            state.setString(2,password);

    3. 执行语句:
            ResultSet result = state.executeQuery();</code></pre><h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><pre><code>填充预编译的参数: 
    * setXxx（问号索引,值）
        向预编译的SQL的?中传递值 
        参数1. 问号的索引,从1开始
        参数2. 填充到? 中的值

    * execute()
    * executeUpdate();
    * executeQuery();        </code></pre>]]></content>
  </entry>
  <entry>
    <title>hello_hexo</title>
    <url>/2019/12/07/hello-hexo/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLjdbc</title>
    <url>/2020/05/02/SQLjdbc/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>1. 基本概念
    Java DataBase Connectivity
    - java数据库连接，java操作数据库，使用同一套java代码操作不同的数据库
    - 本质：官方定义的操作所有关系型数据库的规则--接口，实现类由各个数据库厂商实现，提供数据库驱动jar包，我们可以使用这套接口（JDBC）编程，但真正执行的是驱动jar包中的实现类。
        Person接口   Worker类  Person p = new Worker();    p.eat();

2. 快速入门
    * 步骤：
        1. 导入驱动jar包
        2. 注册驱动
        3. 获取数据库的连接对象 Connection
        4. 定义SQL语句
        5. 获取执行SQL语句的对象 Statement = connection.statement()
        6. 处理SQL语句,接受返回结果 statememt.executeQuery(sql)
        7. 处理结果
        8. 释放资源

    * 代码：
        `
        //2.注册驱动
           Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);

           //3.获取数据库连接对象
        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/books?serverTimezone=UTC&quot;,&quot;uesrname&quot;,&quot;password&quot;);

        //4.定义SQL语句
        String sql = &quot;select * from admin&quot;;

        //5.获取执行SQL的对象
        Statement statement = connection.createStatement();

        //6.执行SQL
        boolean flag = statement.execute(sql);

        //7.处理
        System.out.println(flag);

        //8.释放资源
        statement.close();
        connection.close();
        `</code></pre><h2 id="对象详解"><a href="#对象详解" class="headerlink" title="对象详解"></a>对象详解</h2><pre><code>1. 详解各个对象
    1. DriverManager
        * 驱动管理对象
        * 功能：
            1. 注册驱动
                static void registerDriver(Driver driver):注册给定的驱动程序
                写代码：Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;)
                com.mysql.cj.jdbc.Driver,使用静态代码块，调用registerDriver方</code></pre><blockquote>
<pre><code>注册驱动:
 static {
      try {
            DriverManager.registerDriver(new Driver());
     } catch (SQLException var1) {
         throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);
     }
     }</code></pre></blockquote>
<pre><code>            PS：mysql5后的驱动jar包可以省略注册驱动的步骤

        2. 连接数据库
            * 方法：static Connection getConnection(String url, String user, String password)
            * 参数:
                * url:指定连接的路径
                    * 语法
                        jdbc:mysql://ip地址(域名)：端口号/数据库名称
                    * 例子
                        jdbc:mysql://localhost:3306/books?serverTimezone=UTC
                    * 细节
                        如果连接本机的mysql服务器，而且端口号3306，可以简写为jdbc:mysql:///数据库名称
                * user:
                    数据库用户名
                * password
                    密码

2. Connection
    * 数据库连接对象
    * 功能：
        1. 获取执行SQL的对象
            * Statement createStatement()
            * PreparedStatement preparedStatement()

        2. 管理事务
            * 开启事务
                void setAutoCommit(boolean autoCommit) :参数为false,开启事务
            * 提交事务
                commit()
            * 回滚事务
                rollback()

3. Statement
    * 执行SQL对象
    * 功能：
        1. 执行SQL语句
            * int executeUpdate(String sql):执行DML(增删改)语句，DDL语句，返回值：影响的行数，判断是否执行成功（&gt;0）
            * ResultSet executeQuery(String sql):执行查询语句

4. ResultSet
    * 结果集对象，封装查询结果
    * 功能：
        * boolean next():游标向前移动一行,并判断是否是最后一行，如果是，返回False
        * getType(参数)：获取数据,一次只能获取一列数据
            * Type：数据类型，int getInt()
            * 参数：
                1. int 列的编号，getInt(1)
                2. String 列名,getString(name)
        * 使用时：
            1. 游标向下移动
            2. 判断是否存在数据
            3. 获取数据
            代码：
                 while(resultSet.next()){
                    //获取数据
                 }

5. PreparedStatement
    * 执行SQL的对象
    * SQL注入问题：在拼接sql语句时，有一些特殊的关键字参于字符串的拼接，会造成安全性问题
        1. 输入用户随便，输入密码：a&apos;or&apos;a&apos;=&apos;a,条件恒为真，
        2. sql:select * from db where name and password,所有的用户名全都查询出来

    * 解决SQL注入问题：使用PreparedStatemmet类
    * 预编译SQL:参数使用 ？作为占位符
    * 步骤：
        1. 导入驱动jar包
        2. 注册驱动
        3. 获取数据库的连接对象 Connection
        4. 定义SQL语句
        5. 获取执行SQL语句的对象 PreparedStatement = connection.preparedStatement(sql)
            * 注意：sql使用?作为占位符， select * from user where name = ? and password = ?;
        6. 给？赋值
            * 方法：
            * setType(参数1，参数2)
            * 参数1：传递参数的位置
            * 参数2: 值
        7. 处理SQL语句,接受返回结果，prearedStatement.executeQuery()
        8. 处理结果
        9. 释放资源

    * 使用PreparedStatement对象
        * 防止SQL注入问题
        * 效率更高</code></pre><h2 id="抽取JDBC工具类"><a href="#抽取JDBC工具类" class="headerlink" title="抽取JDBC工具类"></a>抽取JDBC工具类</h2><pre><code>- JDBCUtils
* 目的：简化书写
* 分析：
    1. 获取连接
        * 不传递参数，并保证工具类的通用性
        * 解决：配置文件
            jdbc.properties
                url=...

            1. 创建Properties类
            Properties properties = new Properties();
            2. 加载properties文件
            properties.load(new FileReader(&quot;jdbc.properties&quot;));
            3. 获取配置
            url = properties.getProperty(&quot;url&quot;);
    2. 释放资源</code></pre><h2 id="登陆验证实例"><a href="#登陆验证实例" class="headerlink" title="登陆验证实例"></a>登陆验证实例</h2><pre><code>1. 需求
    * 通过键盘输入用户名和密码
    * 判断用户是否合法
        根据查询结果判断是否合法

2. 实现
    * 创建表，存储用户名和密码
        CREATE TABLE IF NOT EXISTS USER (
            id INT PRIMARY KEY AUTO_INCREMENT,
            NAME VARCHAR(32) NOT NULL,
            PASSWORD VARCHAR(32) NOT NULL
        );

    * 查询数据表，
        sql = &quot;select * from db where name = &apos;name&apos; and password = &apos;password&apos;&quot;
        如果存在数据，用户合法

3. 注意
    为了预防SQL注入，导致安全性问题，使用PreparedStatement类，使用预编译SQL,不使用静态拼接SQL,Statement类，效率更高而且更安全。</code></pre><h2 id="JDBC事务控制"><a href="#JDBC事务控制" class="headerlink" title="JDBC事务控制"></a>JDBC事务控制</h2><pre><code>1. 事务：一个包含多个步骤的业务操作，如果业务被事务管理，要么全部成功，要么全部失败

2. 操作
    1. 开启事务
    2. 提交事务
    3. 回滚事务

3. 使用Connection管理事务
    * 开启事务
        void setAutoCommit(boolean autoCommit) :参数为false,开启事务
        执行sql语句之前开启事务
    * 提交事务
        commit()
        SQL执行完毕时提交
    * 回滚事务
        rollback
        try catch中进行回滚，一旦发现异常，将数据回滚</code></pre><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：
    * 容器（集合），存放数据库连接的一个容器
    * 系统初始化后，容器被创建，会申请一些连接对象，在用户访问数据库时，从容器中获取连接对象，使用完毕归还容器资源

2. 优点：
    * 节约资源：访问时直接获取，不用重复申请资源
    * 用户访问高效：拿来即用

3. 实现：
    1. 标准接口：
        DataSourse javax.sql
        * 方法:
            * 获取连接：getConnnection()
            * 归还连接：如果Connection是从连接池获取的，调用connection.close()方法，不是关闭连接，而时归还连接

    2. 实现技术，由数据库厂商提供
        * C3P0: 数据库连接池技术
        * Druid: 

4. C3P0连接池技术
    * 步骤：
        1. 导入jar包，jdbc驱动和c3p0包
        2. 定义配置文件：
            * 名称：c3p0.properties 或者 c3p0-config.xml
            * 路径：src目录下
        3. 创建数据库连接池核心数据对象：ComboPoolDataSourse
        4. 获取连接对象：getConnection()

5. Druid连接池技术
    * 步骤：
        1. 导入jar包：druid-v.jar
        2. 定义配置文件：
            * properties形式
            * 可以叫任意名称，放在任意目录下
        3. 加载配置文件
            Properties properties = new Properties();
            InputStream is = DruidDemo08.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
            properties.load(is);
        3. 创建连接池对象，使用工厂类 DruidDataSourseFactory
        4. 获取连接对象

    * 定义工具类
        1. 定义工具类
        2. 提供静态代码块加载配置文件，初始化连接池对象
        3. 提供方法
            1. 获取连接方法，获取连接对象
            2. 释放资源
            3. 获取连接池对象</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装，提供了JDBCTemplate对象
* 步骤：
    1. 导入jar包
    2. 创建JDBCTemplate对象，依赖与数据源DataSourse
        JDBCTemplate template = new JDBCTemplate(ds)
    3. 调用方法完成CRUD的操作</code></pre>]]></content>
  </entry>
  <entry>
    <title>Spring下载</title>
    <url>/2020/05/09/Spring%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code>在下载Spring时，碰到很多问题，在此记录下载流程，方便以后再次下载！</code></pre><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-搜索Spring官网-https-spring-io"><a href="#1-搜索Spring官网-https-spring-io" class="headerlink" title="1. 搜索Spring官网: https://spring.io/"></a>1. 搜索Spring官网: <a href="https://spring.io/" target="_blank" rel="noopener">https://spring.io/</a></h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_1.png" alt=""></p>
<h3 id="2-点击Projects"><a href="#2-点击Projects" class="headerlink" title="2. 点击Projects"></a>2. 点击Projects</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_2.png" alt=""></p>
<h3 id="3-点击Spring-Framework"><a href="#3-点击Spring-Framework" class="headerlink" title="3. 点击Spring Framework"></a>3. 点击Spring Framework</h3><h3 id="4-下拉界面，找到并点击-Spring-Framework-Artifacts"><a href="#4-下拉界面，找到并点击-Spring-Framework-Artifacts" class="headerlink" title="4. 下拉界面，找到并点击 Spring Framework Artifacts"></a>4. 下拉界面，找到并点击 Spring Framework Artifacts</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_3.png" alt=""></p>
<h3 id="5-找到并点击，http-repo-spring-io"><a href="#5-找到并点击，http-repo-spring-io" class="headerlink" title="5. 找到并点击，http://repo.spring.io"></a>5. 找到并点击，<a href="http://repo.spring.io" target="_blank" rel="noopener">http://repo.spring.io</a></h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_4.png" alt=""></p>
<h3 id="6-左边第二个图标，依次点击"><a href="#6-左边第二个图标，依次点击" class="headerlink" title="6.左边第二个图标，依次点击"></a>6.左边第二个图标，依次点击</h3><pre><code>libs-release-local ---&gt; org ---&gt; springframework ---&gt; spring</code></pre><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_5.png" alt=""><br><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_6.png" alt=""></p>
<h3 id="7-鼠标右键-Nature-Browser"><a href="#7-鼠标右键-Nature-Browser" class="headerlink" title="7.鼠标右键 Nature Browser"></a>7.鼠标右键 Nature Browser</h3><p><img src="http://qa4ck0m4g.bkt.clouddn.com/images/Spring_load/Spring_load_7.png" alt=""></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/2020/05/15/mybatis/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><pre><code>1. 什么是框架（Framework）？
    系统中可重用的代码部分，包括一组构件以及构件之间的交互逻辑
    软件开发中的一种解决方案，不同的框架解决不同的问题
    框架封装了很多技术细节，使用者可以方便实现功能，提高开发效率

2. 三层架构
    * 表现层：
        展示数据
    * 业务层：
        处理业务需求
    * 持久层：
        数据库交互

3. 持久层技术解决问题和方案
    1. 问题
        数据库的连接和访问，数据查询效率，操作繁琐，不能将注意力聚焦到SQL处理上
        JDBC,Spring JDBCTemplate，传统的数据库连接方法，一组解决数据库连接的规范

    2. MyBatis概述
        * 基于Java的持久层框架
        * 内部封装了jdbc的细节,使用者只需要关注SQL语句，不用关心加载驱动，数据库连接，Statement对象等过程
        * 使用ORM(Object Relation Mapping)思想实现了结果集的封装
            PS: ORM
                数据库表和实体类以及实体类的属性对应起来，可以操作实体类实现操作数据表
                    user表        User类
                    id          userId</code></pre><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="1-MyBatis入门"><a href="#1-MyBatis入门" class="headerlink" title="1. MyBatis入门"></a>1. MyBatis入门</h2><pre><code>1. 环境搭建
    1. new --&gt; project --&gt; maven 设置名称，导入坐标pom.xml
    2. 创建实体类和Dao的接口:Dao(data access object 数据访问对象)
    3. 创建mybatis的主配置文件
        * SqlMapConfig.xml ：&lt;property &gt; 标签名称需要匹配，ps:username 不是 user
    4. 创建映射配置文件
        * UserDao.xml :&lt;mapper namespace=&quot;UserDao的路径&quot;&gt;

    注意事项：
        1. 创建UserDao.xml UserDao.java，mybatis中将持久层的操作接口名称和映射文件也叫做：Mapper
            UserDao 和 UserMapper相同
        2. 在idea创建目录时，和包的创建不同
            包在创建时，com.mybatis_base_01.dao 三层结构
            目录：com.mybatis_base_01.dao 一级目录
        3. 映射配置文件位置必须和dao接口的包结构相同
        4. 映射配置文件的mapper标签的namespace属性取值为dao接口的全限定类名
        5. 映射配置文件的操作设置，id取值必须时dao接口的方法名

        在实现3，4，5后，dao的实现类由mybatis实现

2. 使用案例
    1. 配置文件
        * InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
    2. 创建SqlSessionFactory对象
        * SqlSessionFacotryBulider builder = new SqlSessionFacotryBuilder();
        * SqlSessionFacotry facotry = builder.build(in);
    3. 创建SqlSession对象
        * SqlSession session = facotry.openSession();
    4. 创建UserDao代理对象
        * UserDao userDao = session.getMapper(UserDao.class);
    5. 使用UserDao代理对象执行操作
        * List&lt;User&gt; userDao = userDao.findAll();
    6. 释放资源
        * session.close();
        * in.close();

3. 简单分析
    1. 配置文件
        Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); 
        * 使用类加载器，只能读取类路径的配置文件
        * 使用ServletContext对象的getRealPath()

    2. 创建SqlSessionFactory工厂
        * 使用了创建者模式：SqlSessionFacotryBuilder builder 构造者 builder.build(in) 建立工厂
        * 使用了工厂模式：SqlSessionFactory 降低类之间的依赖关系

    3. 创建SqlSeccion对象
    4. 创建接口实现类

4. 使用注解开发MyBatis
    1. 将UserDao.xml移除，在Dao接口的方法上使用@Select()注解，并且指定sql语句
    2. 在SqlMapConfig.xml中的Mapper配置时，使用class属性指定Dao接口的全限定类名

5. 自定义MyBatis分析
    Mybatis在使用代理Dao对象实现增删改查做了什么事？
        1. 创建代理对象
        2. 调用selectList()方法</code></pre><blockquote>
<p><code>&lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</code><br><code>&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis_test&quot;/&gt;</code><br><code>&lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</code><br><code>&lt;property name=&quot;password&quot; value=&quot;root2019&quot;/&gt;</code></p>
</blockquote>
<pre><code>连接数据库的语句，可以产生Connnection对象</code></pre><blockquote>
<p><code>&lt;mappers&gt;</code><br><code>&lt;mapper resource=&quot;com/mybatis_base_03/dao/UserDao.xml&quot;/&gt;</code><br><code>&lt;/mappers&gt;</code></p>
</blockquote>
<pre><code>映射配置信息</code></pre><blockquote>
<p><code>&lt;mapper namespace=&quot;com.mybatis_base_03.dao.UserDao&quot;&gt;</code></p>
<p><code>&lt;!--配置查询所有--&gt;</code><br><code>&lt;select id=&quot;findAll&quot; resultType=&quot;com.mybatis_base_03.domain.User&quot;&gt;</code><br>   <code>select * from user</code><br><code>&lt;/select&gt;</code></p>
</blockquote>
<pre><code>全限定类名，以及执行的SQL语句。
有了上面的三个信息，可以解析.xml配置文件。
    1. 根据配置数据库的语句，可以创建Connection对象
        注册驱动，创建连接对象
    2. 获取预处理对象PreparedStatement
        获取SQL语句
    3. 对结果进行封装
        根据实体类的全限定类名</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><pre><code>6.自定义MyBatis中涉及的实体类和接口
    1. class Resources
    2. class SqlSessionBuilder
    3. interface SqlSessionfacotry
    4. interface SqlSession
    这个过程完成了两件事：
        创建代理对象，
        实现查询语句

MyBatis将JDBC的功能进行封装，形成功能调用。SqlMapConfig.xml,daoInterfaceClass.xml里面包含对数据库的连接与查询的语句以及返回的结果类型。

SqlMapConfig.xml中的&lt;property&gt;标签包含数据库的连接对象，&lt;mappers/mapper&gt;包含接口的文件位置。
daoInterfaceClass.xml包含数据库语句，返回数据类的全限定类名，以及方法的namespace(根据查查询语句以及namespace确定方法的唯一性)。

根据这两个配置文件，可以通过对.xml文件的解析，获取相应的配置文件信息，由此构建代理对象，g根据返回数据的类型获取数据，实现整个的查询过程。</code></pre><h2 id="MyBatis的CRUD"><a href="#MyBatis的CRUD" class="headerlink" title="MyBatis的CRUD"></a>MyBatis的CRUD</h2><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛云_Hexo</title>
    <url>/2020/05/12/%E4%B8%83%E7%89%9B%E4%BA%91-Hexo/</url>
    <content><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><pre><code>1. 注册七牛云,完成之后就可以进行创建空间，
2. 注意我们添加的资源为对象存储，访问控制为公开空间
3. 点击右上角进入密钥管理，复制当前使用的AK和SK，配置的时候会用得到</code></pre><h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h2><h3 id="2-1-安装插件，进入Hexo主目录，执行："><a href="#2-1-安装插件，进入Hexo主目录，执行：" class="headerlink" title="2.1. 安装插件，进入Hexo主目录，执行："></a>2.1. 安装插件，进入Hexo主目录，执行：</h3><pre><code>`npm install hexo-qiniu-sync --save`</code></pre><h3 id="2-2-配置站点文件-config-yml"><a href="#2-2-配置站点文件-config-yml" class="headerlink" title="2.2. 配置站点文件_config.yml:"></a>2.2. 配置站点文件_config.yml:</h3><blockquote>
<p>  #plugins:<br>      #- hexo-qiniu-sync<br>    qiniu:<br>      offline: false<br>      sync: true<br>      bucket: bucket_name<br>      access_key: AccessKey<br>      secret_key: SecretKey<br>      dirPrefix:<br>      urlPrefix: <a href="http://7xqb0u.com1.z0.glb.clouddn.com" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com</a><br>      local_dir: cdn<br>      update_exist: true<br>      image:<br>        folder: images<br>        extend:<br>      js:<br>        folder: js<br>      css:<br>        folder: css</p>
</blockquote>
<h3 id="2-3-参数"><a href="#2-3-参数" class="headerlink" title="2.3. 参数"></a>2.3. 参数</h3><ul>
<li><p>bucket ：修改为你刚才申请的七牛空间名称</p>
</li>
<li><p>access_key 、 secret_key : 上传密钥AccessKey、SecretKey。即3 第3步复制的AK和SK。</p>
</li>
<li><p>urlPrefix : 七牛空间地址的前缀。 重要！必填！ 因为现在七牛已经取消了二级域名，外链前缀类似设置中的 <a href="http://7xqb0u.com1.z0.glb.clouddn.com" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com</a> ，插件不能根据 bucket 自动生成外链前缀了。你可以进入自己创建的空间在域名设置中看到自己的七牛测试域名，也可以查看一个已上传的文件外链地址，确认前缀无误。这个参数的设置是保证解析成网页文件时，外链地址正确的关键之一！<br>  配置参数的说明：</p>
</li>
<li><p>offline ：是否离线。设置为 true 将在本地预览时使用本地地址渲染，省流量； false 将使用同步到七牛空间的静态资源渲染，方便检查资源链接是否正确。</p>
</li>
<li><p>sync ：是否同步到七牛，一般都是设置 true 啦</p>
</li>
<li><p>dirPrefix ：资源将上传到七牛空间的此目录下，可像我一样设置为空。该参数会影响外链的地址，如果设置为非空值，例如默认值 static ，则 urlPrefix 为保持一致需加上目录后缀 /static ，改为 <a href="http://7xqb0u.com1.z0.glb.clouddn.com/static" target="_blank" rel="noopener">http://7xqb0u.com1.z0.glb.clouddn.com/static</a> 。</p>
</li>
<li><p>local_dir ：本地资源储存目录。在本例中，待上传的资源都储存在hexo主目录中的 cdn 文件夹（也就是与 source 目录平级）中。</p>
</li>
<li><p>update_exist ：设置为 true ，则会在文件更新之后重新上传并更新七牛空间上中的原有文件。</p>
</li>
<li><p>image/js/css ：子参数folder为不同静态资源种类的目录名称，一般不需要改动</p>
</li>
<li><p>image.extend ：使用 qnimg 标签引用图片的默认图片处理操作。可以使用 基本图片处理（imageView2）、高级图片处理（imageMogr2）、图片水印处理（watermark） 这三个图片处理接口，多个接口内容之间用 | 间隔。详见 七牛开发者中心-图片处理。</p>
</li>
</ul>
<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><pre><code>1.将图片上传到七牛云，查看照片获取照片的外链
2.在文章中引用照片外链，markdown格式:*![描述]（外链）*</code></pre><h2 id="4-感谢在使用七牛云时参考的大佬博客："><a href="#4-感谢在使用七牛云时参考的大佬博客：" class="headerlink" title="4. 感谢在使用七牛云时参考的大佬博客："></a>4. 感谢在使用七牛云时参考的大佬博客：</h2><ul>
<li><a href="http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/" target="_blank" rel="noopener">http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
